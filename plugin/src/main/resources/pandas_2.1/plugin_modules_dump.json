{
    "cms_rendner_sdfv": {
        "pandas": {
            "frame": {
                "frame_context": "from cms_rendner_sdfv.base.table_source import AbstractTableFrameGenerator\nfrom cms_rendner_sdfv.pandas.frame.table_frame_generator import TableFrameGenerator\nfrom cms_rendner_sdfv.pandas.shared.pandas_table_source_context import PandasTableSourceContext\n\n\nclass FrameContext(PandasTableSourceContext):\n    def get_table_frame_generator(self) -> AbstractTableFrameGenerator:\n        return TableFrameGenerator(self.visible_frame)\n",
                "table_frame_generator": "from typing import Any, Callable, Optional\n\nfrom pandas import get_option\nfrom pandas.core.dtypes.common import (\n    is_complex,\n    is_float,\n    is_integer,\n)\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableFrameGenerator\nfrom cms_rendner_sdfv.base.types import Region, TableFrame, TableFrameCell, TableFrameColumn, TableFrameLegend\nfrom cms_rendner_sdfv.pandas.shared.value_formatter import ValueFormatter\nfrom cms_rendner_sdfv.pandas.shared.visible_frame import Chunk, VisibleFrame\n\n\nclass _ValueFormatter(ValueFormatter):\n    def __init__(self):\n        self._precision = get_option(\"display.precision\")\n        self._float_format: Optional[Callable] = get_option(\"display.float_format\")\n\n    def _default_format(self, x: Any, fallback_formatter) -> Any:\n        if is_float(x) or is_complex(x):\n            if callable(self._float_format):\n                return self._float_format(x)\n            return f\"{x:.{self._precision}f}\"\n        elif is_integer(x):\n            return str(x)\n\n        return fallback_formatter(x)\n\n    def format_column(self, value: Any) -> str:\n        return self._default_format(value, super().format_column)\n\n    def format_index(self, value: Any) -> str:\n        return self._default_format(value, super().format_index)\n\n    def format_cell(self, value: Any) -> str:\n        return self._default_format(value, super().format_cell)\n\n\nclass TableFrameGenerator(AbstractTableFrameGenerator):\n    def __init__(self, visible_frame: VisibleFrame):\n        super().__init__(visible_frame)\n\n    def generate(self,\n                 region: Region = None,\n                 exclude_row_header: bool = False,\n                 exclude_col_header: bool = False,\n                 ) -> TableFrame:\n\n        chunk = self._visible_frame.get_chunk(region)\n        formatter = _ValueFormatter()\n\n        columns = [] if exclude_col_header else self._extract_columns(chunk, formatter)\n        index_labels = [] if exclude_row_header else self._extract_index_header_labels(chunk, formatter)\n        cells = self._extract_cells(chunk, formatter)\n        legend_label = None if exclude_col_header and exclude_row_header else self._extract_legend_label(chunk, formatter)\n\n        return TableFrame(\n            index_labels=index_labels,\n            columns=columns,\n            legend=legend_label,\n            cells=cells,\n        )\n\n    def _extract_columns(self, chunk: Chunk, formatter: ValueFormatter) -> list[TableFrameColumn]:\n        result: list[TableFrameColumn] = []\n\n        for col_offset in range(chunk.region.cols):\n            name = chunk.column_at(col_offset)\n            if isinstance(name, tuple):\n                labels = [formatter.format_column(h) for h in name]\n            else:\n                labels = [formatter.format_column(name)]\n            result.append(\n                TableFrameColumn(\n                    dtype=str(chunk.dtype_at(col_offset)),\n                    labels=labels,\n                    describe=None if self._exclude_column_describe else chunk.describe_at(col_offset),\n                )\n            )\n\n        return result\n\n    @staticmethod\n    def _extract_index_header_labels(chunk: Chunk, formatter: ValueFormatter) -> list[list[str]]:\n        result: list[list[str]] = []\n\n        for row_offset in range(chunk.region.rows):\n            name = chunk.index_at(row_offset)\n            if isinstance(name, tuple):\n                result.append([formatter.format_index(h) for h in name])\n            else:\n                result.append([formatter.format_index(name)])\n\n        return result\n\n    @staticmethod\n    def _extract_cells(chunk: Chunk, formatter: ValueFormatter) -> list[list[TableFrameCell]]:\n        result: list[list[TableFrameCell]] = []\n\n        col_range = range(chunk.region.cols)\n        for row_offset in range(chunk.region.rows):\n            result.append(\n                [TableFrameCell(\n                    value=formatter.format_cell(chunk.cell_value_at(row_offset, col_offset))\n                ) for col_offset in col_range])\n\n        return result\n\n    @staticmethod\n    def _extract_legend_label(chunk: Chunk, formatter: ValueFormatter) -> TableFrameLegend:\n        index_legend = [formatter.format_index(n) for n in chunk.index_names() if n is not None]\n        column_legend = [formatter.format_index(n) for n in chunk.column_names() if n is not None]\n        return TableFrameLegend(index=index_legend, column=column_legend) if index_legend or column_legend else None\n",
                "table_source": "from cms_rendner_sdfv.base.table_source import AbstractTableSource\nfrom cms_rendner_sdfv.base.types import TableSourceKind\nfrom cms_rendner_sdfv.pandas.frame.frame_context import FrameContext\n\n\nclass TableSource(AbstractTableSource):\n    def __init__(self, context: FrameContext, fingerprint: str):\n        super().__init__(TableSourceKind.TABLE_SOURCE, context, fingerprint)\n",
                "table_source_factory": "from typing import Any, Union\n\nfrom pandas import DataFrame\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableSource, AbstractTableSourceFactory\nfrom cms_rendner_sdfv.base.types import CreateTableSourceConfig, CreateTableSourceFailure\nfrom cms_rendner_sdfv.pandas.frame.table_source import TableSource\nfrom cms_rendner_sdfv.pandas.frame.frame_context import FrameContext\nfrom cms_rendner_sdfv.pandas.shared.create_fingerprint import create_fingerprint\nfrom cms_rendner_sdfv.pandas.shared.types import FilterCriteria\n\n\nclass TableSourceFactory(AbstractTableSourceFactory):\n\n    def _create_internal(self,\n                         data_source: Any,\n                         config: CreateTableSourceConfig,\n                         caller_globals: dict,\n                         ) -> Union[AbstractTableSource, CreateTableSourceFailure]:\n        ds_frame = None\n        if isinstance(data_source, dict):\n            if config.data_source_transform_hint == \"DictKeysAsRows\":\n                ds_frame = DataFrame.from_dict(data_source, orient='index')\n            elif all(name in data_source for name in [\"index\", \"columns\", \"data\", \"index_names\", \"column_names\"]):\n                ds_frame = DataFrame.from_dict(data_source, orient='tight')\n            else:\n                try:\n                    ds_frame = DataFrame.from_dict(data_source, orient='columns')\n                except ValueError as e:\n                    if str(e) == \"If using all scalar values, you must pass an index\":\n                        ds_frame = DataFrame(data_source, index=[0])\n        elif isinstance(data_source, DataFrame):\n            ds_frame = data_source\n        else:\n            return CreateTableSourceFailure(error_kind=\"UNSUPPORTED_DATA_SOURCE_TYPE\", info=str(type(data_source)))\n\n        pre_fingerprint = config.previous_fingerprint\n        cur_fingerprint = create_fingerprint(ds_frame, data_source)\n        if pre_fingerprint is not None and pre_fingerprint != cur_fingerprint:\n            return CreateTableSourceFailure(error_kind=\"INVALID_FINGERPRINT\", info=cur_fingerprint)\n\n        filter_frame = None\n        filter_eval_expr = config.filter_eval_expr\n        if filter_eval_expr is not None and filter_eval_expr != \"\":\n            try:\n                if config.filter_eval_expr_provide_frame:\n                    caller_globals[\"_df\"] = ds_frame\n                filter_frame = eval(filter_eval_expr, caller_globals)\n            except Exception as e:\n                return CreateTableSourceFailure(error_kind=\"FILTER_FRAME_EVAL_FAILED\", info=repr(e))\n\n            if not isinstance(filter_frame, DataFrame):\n                return CreateTableSourceFailure(error_kind=\"FILTER_FRAME_OF_WRONG_TYPE\", info=str(type(filter_frame)))\n\n        return TableSource(\n            FrameContext(ds_frame, FilterCriteria.from_frame(filter_frame)),\n            fingerprint=cur_fingerprint,\n        )\n"
            },
            "shared": {
                "create_fingerprint": "from hashlib import blake2b\nfrom typing import Any\n\nfrom pandas import DataFrame\n\n\ndef create_fingerprint(frame: DataFrame, org_data_source: Any = None) -> str:\n    fingerprint_input = [\n        id(org_data_source if org_data_source is not None else frame),\n        frame.shape,\n        frame.index[:60],\n        frame.dtypes[:60]\n    ]\n    return blake2b('-'.join(str(x) for x in fingerprint_input).encode(), digest_size=16).hexdigest()",
                "pandas_table_source_context": "from abc import ABC\nfrom typing import Optional\n\nfrom pandas import DataFrame\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableSourceContext\nfrom cms_rendner_sdfv.base.types import SortCriteria, TableStructure\nfrom cms_rendner_sdfv.pandas.shared.types import FilterCriteria\nfrom cms_rendner_sdfv.pandas.shared.visible_frame import VisibleFrame\n\n\nclass PandasTableSourceContext(AbstractTableSourceContext, ABC):\n    def __init__(self, source_frame: DataFrame, filter_criteria: Optional[FilterCriteria] = None):\n        self._source_frame = source_frame\n        self._sort_criteria: SortCriteria = SortCriteria()\n        self._filter_criteria: FilterCriteria = filter_criteria if filter_criteria is not None else FilterCriteria()\n        self._visible_frame: VisibleFrame = self._recompute_visible_frame()\n\n    @property\n    def visible_frame(self) -> VisibleFrame:\n        return self._visible_frame\n\n    def get_table_structure(self, fingerprint: str) -> TableStructure:\n        rows_count = self._visible_frame.region.rows\n        columns_count = self._visible_frame.region.cols\n        if rows_count == 0 or columns_count == 0:\n            rows_count = columns_count = 0\n        return TableStructure(\n            org_rows_count=len(self._source_frame.index),\n            org_columns_count=len(self._source_frame.columns),\n            rows_count=rows_count,\n            columns_count=columns_count,\n            fingerprint=fingerprint,\n        )\n\n    def set_sort_criteria(self, sort_by_column_index: Optional[list[int]], sort_ascending: Optional[list[bool]]):\n        new_sort_criteria = SortCriteria(sort_by_column_index, sort_ascending)\n        if new_sort_criteria != self._sort_criteria:\n            self._sort_criteria = new_sort_criteria\n            self._visible_frame = self._recompute_visible_frame()\n\n    def _get_initial_visible_frame_indexes(self):\n        return self._source_frame.index, self._source_frame.columns\n\n    def _recompute_visible_frame(self) -> VisibleFrame:\n        index, columns = self._get_initial_visible_frame_indexes()\n\n        if self._filter_criteria.index is not None:\n            index = index.intersection(self._filter_criteria.index)\n\n        if self._filter_criteria.columns is not None:\n            columns = columns.intersection(self._filter_criteria.columns)\n\n        if not self._sort_criteria.is_empty():\n            sc = self._sort_criteria\n            frame = self._source_frame.loc[index, columns]\n            frame = frame.sort_values(\n                by=[frame.columns[i] for i in sc.by_column],\n                ascending=True if sc.ascending is None or len(sc.ascending) == 0 else sc.ascending,\n            )\n            index = frame.index\n\n        return VisibleFrame(\n            self._source_frame,\n            self._source_frame.index.get_indexer_for(index),\n            self._source_frame.columns.get_indexer_for(columns),\n        )\n",
                "types": "from dataclasses import dataclass\nfrom typing import Optional\n\nfrom pandas import DataFrame, Index\n\n\n@dataclass(frozen=True)\nclass FilterCriteria:\n    index: Optional[Index] = None\n    columns: Optional[Index] = None\n\n    @staticmethod\n    def from_frame(frame: Optional[DataFrame]):\n        return None if frame is None else FilterCriteria(frame.index, frame.columns)\n\n    def is_empty(self) -> bool:\n        return self.index is None and self.columns is None\n\n    def __eq__(self, other):\n        if isinstance(other, FilterCriteria):\n            def _equals(s: Optional[Index], o: Optional[Index]) -> bool:\n                if s is None and o is None:\n                    return True\n                return s is not None and o is not None and s.equals(o)\n\n            return _equals(self.columns, other.columns) and _equals(self.index, other.index)\n        return False\n",
                "value_formatter": "from typing import Any\n\nfrom pandas.errors import OptionError\nfrom pandas.io.formats.printing import pprint_thing, get_option\n\nfrom cms_rendner_sdfv.base.constants import CELL_MAX_STR_LEN\nfrom cms_rendner_sdfv.base.helpers import truncate_str\n\n\nclass ValueFormatter:\n\n    @staticmethod\n    def format_column(value: Any) -> str:\n        return value if isinstance(value, str) else pprint_thing(value)\n\n    @staticmethod\n    def format_index(value: Any) -> str:\n        return value if isinstance(value, str) else pprint_thing(value)\n\n    @staticmethod\n    def format_cell(value: Any) -> str:\n        v = value\n        if not isinstance(v, str):\n            max_seq_items = None\n            try:\n                max_seq_items = get_option(\"display.max_seq_items\", True)\n            except OptionError:\n                pass\n            v = pprint_thing(v, max_seq_items=max_seq_items or 42)\n        return truncate_str(v, CELL_MAX_STR_LEN)\n",
                "visible_frame": "from typing import Any, Callable\n\nimport numpy as np\nfrom pandas import DataFrame, Series\n\nfrom cms_rendner_sdfv.base.constants import DESCRIBE_COL_MAX_STR_LEN\nfrom cms_rendner_sdfv.base.helpers import truncate_str\nfrom cms_rendner_sdfv.base.table_source import AbstractVisibleFrame\nfrom cms_rendner_sdfv.base.types import Region\n\n\nclass Chunk:\n    def __init__(self,\n                 visible_frame: DataFrame,\n                 region: Region,\n                 translate_into_source_frame_cell_coordinates: Callable[[tuple[int, int]], tuple[int, int]]):\n        self._visible_frame = visible_frame\n        self._region = region\n        self._translate_into_source_frame_cell_coordinates = translate_into_source_frame_cell_coordinates\n\n    @property\n    def region(self) -> Region:\n        return self._region\n\n    def cell_value_at(self, row_offset: int, col_offset: int) -> Any:\n        return self._visible_frame.iloc[\n            self.region.first_row + row_offset,\n            self.region.first_col + col_offset,\n        ]\n\n    def column_at(self, offset: int) -> Any:\n        return self._visible_frame.columns[self.region.first_col + offset]\n\n    def index_at(self, offset: int) -> Any:\n        return self._visible_frame.index[self.region.first_row + offset]\n\n    def dtype_at(self, col: int) -> Any:\n        return self._visible_frame.dtypes.iloc[self.region.first_col + col]\n\n    def describe_at(self, col: int) -> dict[str, str]:\n        s: Series = self._visible_frame.iloc[:, self.region.first_col + col]\n        try:\n            return {k: truncate_str(str(v), DESCRIBE_COL_MAX_STR_LEN) for k, v in s.describe().to_dict().items()}\n        except TypeError as e:\n            return {'error': str(e)}\n\n    def index_names(self) -> list:\n        return self._visible_frame.index.names\n\n    def column_names(self) -> list:\n        return self._visible_frame.columns.names\n\n    def to_frame(self) -> DataFrame:\n        r = self.region\n        return self._visible_frame.iloc[\n               r.first_row:r.first_row + r.rows,\n               r.first_col:r.first_col + r.cols,\n               ]\n\n    def get_translate_into_source_frame_cell_coordinates(self) -> Callable[[tuple[int, int]], tuple[int, int]]:\n        return self._translate_into_source_frame_cell_coordinates\n\n\nclass VisibleFrame(AbstractVisibleFrame):\n    def __init__(self, source_frame: DataFrame, visible_rows: np.ndarray, visible_cols: np.ndarray):\n        self._source_frame = source_frame\n        self._i_rows = visible_rows\n        self._i_cols = visible_cols\n        self._region = Region(0, 0, len(visible_rows), len(visible_cols))\n\n    @property\n    def region(self) -> Region:\n        return self._region\n\n    def get_chunk(self, region: Region = None) -> Chunk:\n        chunk_region = self._region if region is None else self.region.get_bounded_region(region)\n        visible_frame = self._source_frame.iloc[self._i_rows, self._i_cols]\n\n        def translate_into_source_frame_cell_coordinates(k: tuple[int, int]) -> tuple[int, int]:\n            return self._i_rows[chunk_region.first_row + k[0]], self._i_cols[chunk_region.first_col + k[1]]\n\n        return Chunk(visible_frame, chunk_region, translate_into_source_frame_cell_coordinates)\n\n    def get_column_indices(self, part_start: int, max_columns: int) -> list[int]:\n        return list(self._i_cols[part_start:part_start + max_columns])\n"
            },
            "styler": {
                "apply_patcher": "from typing import Optional, Union\n\nfrom pandas import DataFrame, Series\n\nfrom cms_rendner_sdfv.pandas.styler.chunk_parent_provider import ChunkParentProvider\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\n\n\nclass ApplyPatcher(TodoPatcher):\n\n    def __init__(self, todo: StylerTodo):\n        super().__init__(todo)\n\n    def create_patched_todo(self, org_frame: DataFrame, chunk: DataFrame) -> Optional[StylerTodo]:\n        subset_frame = self._create_subset_frame(org_frame, self._todo.apply_args.subset)\n        builder = self._todo.builder().with_subset(self._calculate_chunk_subset(subset_frame, chunk))\n        if self._todo.should_provide_chunk_parent():\n            builder.with_style_func(\n                ChunkParentProvider(self._styling_func, self._todo.apply_args.axis, subset_frame),\n            )\n        else:\n            builder.with_style_func(self._styling_func)\n        return builder.build()\n\n    def _styling_func(self, chunk_or_series_from_chunk: Union[DataFrame, Series], **kwargs):\n        if chunk_or_series_from_chunk.empty:\n            return chunk_or_series_from_chunk\n        return self._todo.apply_args.style_func(chunk_or_series_from_chunk, **kwargs)\n",
                "background_gradient_patcher": "from typing import Optional, Union\n\nimport numpy as np\nfrom pandas import DataFrame, Series\nfrom pandas.io.formats.style import _validate_apply_axis_arg\n\nfrom cms_rendner_sdfv.pandas.styler.chunk_parent_provider import ChunkParentProvider\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\n\n\nclass BackgroundGradientPatcher(TodoPatcher):\n\n    def __init__(self, todo: StylerTodo):\n        super().__init__(todo)\n\n    def create_patched_todo(self, org_frame: DataFrame, chunk: DataFrame) -> Optional[StylerTodo]:\n        subset_frame = self._create_subset_frame(org_frame, self._todo.apply_args.subset)\n        return self._todo.builder() \\\n            .with_subset(self._calculate_chunk_subset(subset_frame, chunk)) \\\n            .with_style_func(ChunkParentProvider(self._styling_func, self._todo.apply_args.axis, subset_frame))\\\n            .build()\n\n    def _styling_func(self,\n                      chunk_or_series_from_chunk: Union[DataFrame, Series],\n                      chunk_parent: Union[DataFrame, Series],\n                      **kwargs,\n                      ):\n        if chunk_or_series_from_chunk.empty:\n            return chunk_or_series_from_chunk\n\n\n        vmin = kwargs.get(\"vmin\", None)\n        vmax = kwargs.get(\"vmax\", None)\n        gmap = kwargs.get(\"gmap\", None)\n\n        if gmap is None:\n            gmap = chunk_parent.to_numpy(dtype=float, na_value=np.nan)\n        else:\n            gmap = _validate_apply_axis_arg(gmap, \"gmap\", float, chunk_parent)\n\n        if vmin is None or vmax is None:\n            if vmin is None:\n                vmin = np.nanmin(gmap)\n            if vmax is None:\n                vmax = np.nanmax(gmap)\n\n        gmap = self._adjust_gmap_shape_to_chunk_shape(gmap, chunk_or_series_from_chunk, chunk_parent)\n\n        return self._todo.apply_args.style_func(\n            chunk_or_series_from_chunk,\n            **dict(kwargs, vmin=vmin, vmax=vmax, gmap=gmap),\n        )\n\n    def _adjust_gmap_shape_to_chunk_shape(self,\n                                          gmap: np.ndarray,\n                                          chunk_or_series_from_chunk: Union[DataFrame, Series],\n                                          chunk_parent: Union[DataFrame, Series],\n                                          ) -> np.ndarray:\n        if isinstance(chunk_or_series_from_chunk, Series):\n            return gmap[chunk_parent.index.get_indexer_for(chunk_or_series_from_chunk.index)]\n        elif isinstance(chunk_or_series_from_chunk, DataFrame) and self._todo.apply_args.axis is None:\n            ri = chunk_parent.index.get_indexer_for(chunk_or_series_from_chunk.index)\n            ci = chunk_parent.columns.get_indexer_for(chunk_or_series_from_chunk.columns)\n            if isinstance(gmap, DataFrame):\n                return gmap.iloc[(ri, ci)]\n            elif isinstance(gmap, np.ndarray):\n                return DataFrame(data=gmap, index=chunk_parent.index, columns=chunk_parent.columns).iloc[(ri, ci)]\n        return gmap\n",
                "chunk_parent_provider": "from typing import Callable, Optional, Union\n\nfrom pandas import DataFrame, Series\nfrom pandas._typing import Axis\n\n\nclass ChunkParentProvider:\n    def __init__(self, style_func: Callable, axis: Optional[Axis], subset_frame: DataFrame):\n        self.__style_func = style_func\n        self.__axis = axis\n        self.__subset_frame = subset_frame\n\n    def __call__(self, chunk_or_series_from_chunk: Union[DataFrame, Series], *args, **kwargs):\n        if chunk_or_series_from_chunk.empty:\n            return chunk_or_series_from_chunk\n\n        kwargs['chunk_parent'] = self._get_parent(chunk_or_series_from_chunk)\n        return self.__style_func(chunk_or_series_from_chunk, *args, **kwargs)\n\n    def _get_parent(self, chunk_or_series_from_chunk: Union[DataFrame, Series]):\n        if self.__axis == 0 or self.__axis == \"index\":\n            return self.__subset_frame[chunk_or_series_from_chunk.name]\n        elif self.__axis == 1 or self.__axis == \"columns\":\n            return self.__subset_frame.loc[chunk_or_series_from_chunk.name]\n        else:\n            return self.__subset_frame\n",
                "highlight_between_patcher": "from typing import Optional, Union\n\nimport numpy as np\nfrom pandas import DataFrame, Series\nfrom pandas.io.formats.style import _validate_apply_axis_arg\n\nfrom cms_rendner_sdfv.pandas.styler.chunk_parent_provider import ChunkParentProvider\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\n\n\nclass HighlightBetweenPatcher(TodoPatcher):\n\n    def __init__(self, todo: StylerTodo):\n        super().__init__(todo)\n\n    def create_patched_todo(self, org_frame: DataFrame, chunk: DataFrame) -> Optional[StylerTodo]:\n        subset_frame = self._create_subset_frame(org_frame, self._todo.apply_args.subset)\n        return self._todo.builder() \\\n            .with_subset(self._calculate_chunk_subset(subset_frame, chunk)) \\\n            .with_style_func(ChunkParentProvider(self._styling_func, self._todo.apply_args.axis, subset_frame)) \\\n            .build()\n\n    def _styling_func(self,\n                      chunk_or_series_from_chunk: Union[DataFrame, Series],\n                      chunk_parent: Union[DataFrame, Series],\n                      **kwargs,\n                      ):\n        if chunk_or_series_from_chunk.empty:\n            return chunk_or_series_from_chunk\n\n        left = kwargs.get(\"left\", None)\n        right = kwargs.get(\"right\", None)\n\n        if np.iterable(left) and not isinstance(left, str):\n            left = _validate_apply_axis_arg(left, \"left\", None, chunk_parent)\n            left = self._adjust_range_part(left, chunk_or_series_from_chunk, chunk_parent)\n\n        if np.iterable(right) and not isinstance(right, str):\n            right = _validate_apply_axis_arg(right, \"right\", None, chunk_parent)\n            right = self._adjust_range_part(right, chunk_or_series_from_chunk, chunk_parent)\n\n        return self._todo.apply_args.style_func(\n            chunk_or_series_from_chunk,\n            **dict(kwargs, left=left, right=right),\n        )\n\n    def _adjust_range_part(self,\n                           part: np.ndarray,\n                           chunk_or_series_from_chunk: Union[DataFrame, Series],\n                           chunk_parent: Union[DataFrame, Series],\n                           ) -> np.ndarray:\n        if isinstance(chunk_or_series_from_chunk, Series):\n            return part[chunk_parent.index.get_indexer_for(chunk_or_series_from_chunk.index)]\n        elif isinstance(chunk_or_series_from_chunk, DataFrame) and self._todo.apply_args.axis is None:\n            ri = chunk_parent.index.get_indexer_for(chunk_or_series_from_chunk.index)\n            ci = chunk_parent.columns.get_indexer_for(chunk_or_series_from_chunk.columns)\n            ri_slice = slice(ri[0], ri[-1] + 1)\n            ci_slice = slice(ci[0], ci[-1] + 1)\n            return part[ri_slice, ci_slice]\n        return part\n",
                "highlight_extrema_patcher": "from typing import Optional, Union\n\nimport numpy as np\nimport pandas as pd\nfrom pandas import DataFrame, Series\n\nfrom cms_rendner_sdfv.pandas.styler.chunk_parent_provider import ChunkParentProvider\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\n\n\nclass HighlightExtremaPatcher(TodoPatcher):\n\n    def __init__(self, todo: StylerTodo, op: str):\n        super().__init__(todo)\n        self._op: str = op\n        self._attribute: str = todo.style_func_kwargs.get('props', 'background-color: yellow')\n\n    def create_patched_todo(self, org_frame: DataFrame, chunk: DataFrame) -> Optional[StylerTodo]:\n        subset_frame = self._create_subset_frame(org_frame, self._todo.apply_args.subset)\n        return self._todo.builder() \\\n            .with_subset(self._calculate_chunk_subset(subset_frame, chunk)) \\\n            .with_style_func_kwargs({}) \\\n            .with_style_func(ChunkParentProvider(self._styling_func, self._todo.apply_args.axis, subset_frame)) \\\n            .build()\n\n    def _styling_func(self,\n                      chunk_or_series_from_chunk: Union[DataFrame, Series],\n                      chunk_parent: Union[DataFrame, Series],\n                      ):\n        if chunk_or_series_from_chunk.empty:\n            return chunk_or_series_from_chunk\n\n        value = getattr(chunk_parent, self._op)(skipna=True)\n\n        if isinstance(chunk_or_series_from_chunk, DataFrame):  # min/max must be done twice to return scalar\n            value = getattr(value, self._op)(skipna=True)\n        cond = chunk_or_series_from_chunk == value\n        cond = cond.where(pd.notna(cond), False)\n        return np.where(cond, self._attribute, \"\")\n",
                "map_patcher": "from typing import Optional\n\nfrom pandas import DataFrame\n\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\n\n\nclass MapPatcher(TodoPatcher):\n\n    def __init__(self, todo: StylerTodo):\n        super().__init__(todo)\n\n    def create_patched_todo(self, org_frame: DataFrame, chunk: DataFrame) -> Optional[StylerTodo]:\n        subset_frame = self._create_subset_frame(org_frame, self._todo.apply_args.subset)\n        return self._todo.builder() \\\n            .with_subset(self._calculate_chunk_subset(subset_frame, chunk)) \\\n            .build()\n",
                "patched_styler": "from typing import Optional, Union\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableSource\nfrom cms_rendner_sdfv.base.types import Region, TableSourceKind\nfrom cms_rendner_sdfv.pandas.styler.patched_styler_context import PatchedStylerContext\nfrom cms_rendner_sdfv.pandas.styler.style_function_name_resolver import StyleFunctionNameResolver\nfrom cms_rendner_sdfv.pandas.styler.style_functions_validator import StyleFunctionValidationProblem, \\\n    StyleFunctionsValidator, ValidationStrategyType\nfrom cms_rendner_sdfv.pandas.styler.todos_patcher import TodosPatcher\nfrom cms_rendner_sdfv.pandas.styler.types import StyleFunctionInfo\n\n\nclass PatchedStyler(AbstractTableSource):\n    def __init__(self, context: PatchedStylerContext, fingerprint: str):\n        super().__init__(TableSourceKind.PATCHED_STYLER, context, fingerprint)\n\n    def validate_style_functions(self,\n                                 first_row: int,\n                                 first_col: int,\n                                 rows: int,\n                                 cols: int,\n                                 strategy: Union[ValidationStrategyType, str, None] = None,\n                                 ) -> list[StyleFunctionValidationProblem]:\n        validation_strategy = ValidationStrategyType[strategy] if isinstance(strategy, str) else strategy\n        return StyleFunctionsValidator(self._context, validation_strategy)\\\n            .validate(Region(first_row, first_col, rows, cols))\n\n    def set_sort_criteria(self,\n                          by_column_index: Optional[list[int]] = None,\n                          ascending: Optional[list[bool]] = None,\n                          ):\n        self._context.set_sort_criteria(by_column_index, ascending)\n\n    def get_style_function_info(self) -> list[StyleFunctionInfo]:\n        result = []\n\n        for i, todo in enumerate(self._context.get_styler_todos()):\n            result.append(StyleFunctionInfo(\n                index=i,\n                qname=StyleFunctionNameResolver.get_style_func_qname(todo),\n                resolved_name=StyleFunctionNameResolver.resolve_style_func_name(todo),\n                axis='' if todo.is_map() else str(todo.apply_args.axis),\n                is_pandas_builtin=todo.is_pandas_style_func(),\n                is_supported=TodosPatcher.is_style_function_supported(todo),\n                is_apply=not todo.is_map(),\n                is_chunk_parent_requested=todo.should_provide_chunk_parent(),\n            ))\n\n        return result\n",
                "patched_styler_context": "from typing import Callable, Optional\n\nfrom pandas import DataFrame, Index\nfrom pandas.io.formats.style import Styler\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableFrameGenerator, TableFrameValidator\nfrom cms_rendner_sdfv.pandas.shared.pandas_table_source_context import PandasTableSourceContext\nfrom cms_rendner_sdfv.pandas.shared.types import FilterCriteria\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todos_patcher import TodosPatcher\n\n\nclass PatchedStylerContext(PandasTableSourceContext):\n    def __init__(self, styler: Styler, filter_criteria: Optional[FilterCriteria] = None):\n        self._has_hidden_rows = len(styler.hidden_rows) > 0\n        self._has_hidden_columns = len(styler.hidden_columns) > 0\n        self._styler = styler\n        self._styler_todos = [StylerTodo.from_tuple(t) for t in styler._todo]\n        super().__init__(styler.data, filter_criteria)\n\n    def get_table_frame_generator(self) -> AbstractTableFrameGenerator:\n        from cms_rendner_sdfv.pandas.styler.table_frame_generator import TableFrameGenerator\n        return TableFrameGenerator(self)\n\n    def get_styler(self) -> Styler:\n        return self._styler\n\n    def get_styler_todos(self):\n        return self._styler_todos\n\n    def get_todo_validator(self, todo: StylerTodo) -> TableFrameValidator:\n        from cms_rendner_sdfv.pandas.styler.table_frame_generator import TableFrameGenerator\n        return TableFrameValidator(self.visible_frame.region, TableFrameGenerator(self, lambda x: x is todo))\n\n    def create_patched_todos(self,\n                             chunk: DataFrame,\n                             todos_filter: Optional[Callable[[StylerTodo], bool]] = None,\n                             ) -> list[tuple[Callable, tuple, dict]]:\n        filtered_todos = self._styler_todos if todos_filter is None else list(filter(todos_filter, self._styler_todos))\n        return TodosPatcher().patch_todos_for_chunk(filtered_todos, self._source_frame, chunk)\n\n    def _get_initial_visible_frame_indexes(self):\n        index, columns = super()._get_initial_visible_frame_indexes()\n\n        if self._has_hidden_columns:\n            columns = columns.delete(Index(self._styler.hidden_columns))\n        if self._has_hidden_rows:\n            index = index.delete(Index(self._styler.hidden_rows))\n\n        return index, columns\n",
                "style_function_name_resolver": "from functools import partial\n\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\n\n\nclass StyleFunctionNameResolver:\n\n    @staticmethod\n    def get_style_func_qname(todo: StylerTodo) -> str:\n        func = todo.apply_args.style_func\n        if isinstance(func, partial):\n            func = func.func\n        return getattr(func, '__qualname__', '')\n\n    @staticmethod\n    def resolve_style_func_name(todo: StylerTodo) -> str:\n        qname = StyleFunctionNameResolver.get_style_func_qname(todo)\n        if todo.is_pandas_style_func():\n            if StyleFunctionNameResolver.is_pandas_text_gradient(qname, todo):\n                return \"text_gradient\"\n            elif StyleFunctionNameResolver.is_pandas_background_gradient(qname):\n                return \"background_gradient\"\n            elif StyleFunctionNameResolver.is_pandas_highlight_max(qname, todo):\n                return \"highlight_max\"\n            elif StyleFunctionNameResolver.is_pandas_highlight_min(qname, todo):\n                return \"highlight_min\"\n            elif StyleFunctionNameResolver.is_pandas_highlight_null(qname):\n                return \"highlight_null\"\n            elif StyleFunctionNameResolver.is_pandas_highlight_between(qname):\n                return \"highlight_between or highlight_quantile\"\n            elif StyleFunctionNameResolver.is_pandas_set_properties(qname):\n                return \"set_properties\"\n            else:\n                return qname.rpartition('.')[2]\n        else:\n            return qname.rpartition('.')[2]\n\n    @staticmethod\n    def is_pandas_background_gradient(style_func_qname: str) -> bool:\n        return style_func_qname == '_background_gradient'\n\n    @staticmethod\n    def is_pandas_text_gradient(style_func_qname: str, todo: StylerTodo) -> bool:\n        return style_func_qname == '_background_gradient' \\\n               and todo.style_func_kwargs.get(\"text_only\", False)\n\n    @staticmethod\n    def is_pandas_highlight_max(style_func_qname: str, todo: StylerTodo) -> bool:\n        return style_func_qname == '_highlight_value' \\\n               and isinstance(todo.apply_args.style_func, partial) \\\n               and todo.apply_args.style_func.keywords.get('op', '') == 'max'\n\n    @staticmethod\n    def is_pandas_highlight_min(style_func_qname: str, todo: StylerTodo) -> bool:\n        return style_func_qname == '_highlight_value' \\\n               and isinstance(todo.apply_args.style_func, partial) \\\n               and todo.apply_args.style_func.keywords.get('op', '') == 'min'\n\n    @staticmethod\n    def is_pandas_highlight_null(style_func_qname: str) -> bool:\n        return style_func_qname.startswith('Styler.highlight_null')\n\n    @staticmethod\n    def is_pandas_highlight_between(style_func_qname: str) -> bool:\n        return style_func_qname == '_highlight_between'\n\n    @staticmethod\n    def is_pandas_set_properties(style_func_qname: str) -> bool:\n        return style_func_qname.startswith('Styler.set_properties')\n",
                "style_functions_validator": "from abc import ABC, abstractmethod\nfrom typing import Optional\n\nfrom cms_rendner_sdfv.base.types import Region\nfrom cms_rendner_sdfv.pandas.styler.patched_styler_context import PatchedStylerContext\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.types import StyleFunctionValidationProblem, ValidationStrategyType\n\n\nclass _AbstractValidationStrategy(ABC):\n    def __init__(self, strategy_type: ValidationStrategyType):\n        self._strategy_type: ValidationStrategyType = strategy_type\n\n    @property\n    def strategy_type(self):\n        return self._strategy_type\n\n    @abstractmethod\n    def get_chunk_size(self, rows_in_region: int, columns_in_region: int) -> tuple[int, int]:\n        pass\n\n    @staticmethod\n    def _ceiling_division(n, d):\n        return -(n // -d)\n\n\nclass _PrecisionValidationStrategy(_AbstractValidationStrategy):\n    def __init__(self):\n        super().__init__(ValidationStrategyType.PRECISION)\n\n    def get_chunk_size(self, rows_in_region: int, columns_in_region: int) -> tuple[int, int]:\n        cols_per_chunk = max(1, self._ceiling_division(rows_in_region, 2))\n        rows_per_chunk = max(1, self._ceiling_division(columns_in_region, 2))\n        return rows_per_chunk, cols_per_chunk\n\n\nclass _FastValidationStrategy(_AbstractValidationStrategy):\n    def __init__(self):\n        super().__init__(ValidationStrategyType.FAST)\n        self.__split_vertical = True\n\n    def get_chunk_size(self, rows_in_region: int, columns_in_region: int) -> tuple[int, int]:\n        rows_per_chunk = rows_in_region\n        cols_per_chunk = columns_in_region\n\n        if self.__split_vertical:\n            cols_per_chunk = max(1, self._ceiling_division(cols_per_chunk, 2))\n        else:\n            rows_per_chunk = max(1, self._ceiling_division(rows_per_chunk, 2))\n\n        self.__split_vertical = not self.__split_vertical\n        return rows_per_chunk, cols_per_chunk\n\n\nclass StyleFunctionsValidator:\n    def __init__(self, ctx: PatchedStylerContext, strategy_type: Optional[ValidationStrategyType] = None):\n        self.__ctx: PatchedStylerContext = ctx\n        self.__apply_todos_count: int = self.__count_apply_todos(ctx.get_styler_todos())\n        self.__validation_strategy: _AbstractValidationStrategy = self.__create_validation_strategy(strategy_type)\n\n    def validate(self, region: Region = None) -> list[StyleFunctionValidationProblem]:\n        if self.__apply_todos_count == 0:\n            return []\n\n        if region is None:\n            region = self.__ctx.visible_frame.region\n\n        rows_per_chunk, cols_per_chunk = self.__validation_strategy.get_chunk_size(region.rows, region.cols)\n\n        if self.__apply_todos_count == 1:\n            return self.__validate_todos_separately(region, rows_per_chunk, cols_per_chunk)\n\n        try:\n            validator = self.__ctx.get_table_frame_validator()\n            if validator.validate(rows_per_chunk, cols_per_chunk, region).is_equal:\n                return []\n        except Exception:\n            pass\n\n        return self.__validate_todos_separately(region, rows_per_chunk, cols_per_chunk)\n\n    def __validate_todos_separately(self,\n                                    region: Region,\n                                    rows_per_chunk: int,\n                                    cols_per_chunk: int,\n                                    ) -> list[StyleFunctionValidationProblem]:\n        validation_result = []\n\n        for i, todo in enumerate(self.__ctx.get_styler_todos()):\n            try:\n                if todo.is_map():\n                    continue\n                validator = self.__ctx.get_todo_validator(todo)\n                result = validator.validate(rows_per_chunk, cols_per_chunk, region)\n                if not result.is_equal:\n                    validation_result.append(StyleFunctionValidationProblem(i, \"NOT_EQUAL\"))\n            except Exception as e:\n                validation_result.append(StyleFunctionValidationProblem(i, \"EXCEPTION\", str(e)))\n\n        return validation_result\n\n    @staticmethod\n    def __count_apply_todos(todos: list[StylerTodo]) -> int:\n        return 0 if not todos else len([not t.is_map() for t in todos])\n\n    @staticmethod\n    def __create_validation_strategy(strategy_type: Optional[ValidationStrategyType] = None):\n        if strategy_type is ValidationStrategyType.PRECISION:\n            return _PrecisionValidationStrategy()\n        else:\n            return _FastValidationStrategy()\n",
                "styler_todo": "import inspect\nfrom dataclasses import dataclass\nfrom functools import partial\nfrom typing import Callable, Optional, Tuple, Union\n\nfrom pandas._typing import Axis\nfrom pandas.io.formats.style_render import Subset\n\n\n@dataclass(frozen=True)\nclass MapArgs:\n    style_func: Callable\n    subset: Optional[Subset]\n\n    @classmethod\n    def from_tuple(cls, args: Tuple[Callable, Optional[Subset]]):\n        return cls(args[0], args[1])\n\n    @staticmethod\n    def copy_with(style_func: Callable, subset: Optional[Subset]):\n        return MapArgs(style_func, subset)\n\n    def to_tuple(self) -> Tuple[Callable, Optional[Subset]]:\n        return self.style_func, self.subset\n\n\n@dataclass(frozen=True)\nclass ApplyArgs:\n    style_func: Callable\n    axis: Optional[Axis]\n    subset: Optional[Subset]\n\n    @classmethod\n    def from_tuple(cls, args: Tuple[Callable, Optional[Axis], Optional[Subset]]):\n        return cls(args[0], args[1], args[2])\n\n    def copy_with(self, style_func: Callable, subset: Optional[Subset]):\n        return ApplyArgs(style_func, self.axis, subset)\n\n    def to_tuple(self) -> Tuple[Callable, Optional[Axis], Optional[Subset]]:\n        return self.style_func, self.axis, self.subset\n\n\n@dataclass(frozen=True)\nclass StylerTodo:\n    apply_func: Callable\n    apply_args: Union[ApplyArgs, MapArgs]\n    style_func_kwargs: dict\n\n    @classmethod\n    def from_tuple(cls, todo: Tuple[Callable, tuple, dict]):\n        return cls(todo[0], cls._to_apply_args(todo), todo[2])\n\n    def builder(self):\n        return StylerTodoBuilder(self)\n\n    @staticmethod\n    def _to_apply_args(todo: Tuple[Callable, tuple, dict]):\n        if StylerTodo.is_map_tuple(todo):\n            return MapArgs.from_tuple(todo[1])\n        else:\n            return ApplyArgs.from_tuple(todo[1])\n\n    @classmethod\n    def is_map_tuple(cls, todo: Tuple[Callable, tuple, dict]):\n        return cls.__is_map_func(todo[0])\n\n    def is_map(self) -> bool:\n        return self.__is_map_func(self.apply_func)\n\n    @staticmethod\n    def __is_map_func(func: Callable) -> bool:\n        return getattr(func, '__qualname__', '').startswith('Styler.map')\n\n    def is_pandas_style_func(self) -> bool:\n        func = self.apply_args.style_func\n        if isinstance(func, partial):\n            func = func.func\n        inspect_result = inspect.getmodule(func)\n        return False if inspect_result is None else inspect.getmodule(func).__name__ == 'pandas.io.formats.style'\n\n    def should_provide_chunk_parent(self):\n        sig = inspect.signature(self.apply_args.style_func)\n        for param in sig.parameters.values():\n            if param.name == \"chunk_parent\" or param.kind == inspect.Parameter.VAR_KEYWORD:\n                return True\n        return False\n\n    def to_tuple(self) -> Tuple[Callable, tuple, dict]:\n        return self.apply_func, self.apply_args.to_tuple(), self.style_func_kwargs\n\n\nclass StylerTodoBuilder:\n\n    def __init__(self, source: StylerTodo):\n        self.source: StylerTodo = source\n        self.values: dict = {}\n\n    def with_subset(self, subset: Optional[Subset]):\n        self.values[\"subset\"] = subset\n        return self\n\n    def with_style_func(self, style_func: Callable):\n        self.values[\"style_func\"] = style_func\n        return self\n\n    def with_style_func_kwargs(self, style_func_kwargs: dict):\n        self.values[\"style_func_kwargs\"] = style_func_kwargs\n        return self\n\n    def build(self) -> StylerTodo:\n        return StylerTodo(\n            self.source.apply_func,\n            self.source.apply_args.copy_with(\n                style_func=self.values.get(\"style_func\", self.source.apply_args.style_func),\n                subset=self.values.get(\"subset\", self.source.apply_args.subset),\n            ),\n            self.values.get(\"style_func_kwargs\", self.source.style_func_kwargs),\n        )\n",
                "table_frame_generator": "from collections.abc import Mapping\nfrom dataclasses import dataclass\nfrom typing import Callable, Optional\n\nfrom pandas import option_context\nfrom pandas.io.formats.style import Styler\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableFrameGenerator\nfrom cms_rendner_sdfv.base.types import Region, TableFrame, TableFrameCell, TableFrameColumn, TableFrameLegend\nfrom cms_rendner_sdfv.pandas.shared.value_formatter import ValueFormatter\nfrom cms_rendner_sdfv.pandas.shared.visible_frame import Chunk\nfrom cms_rendner_sdfv.pandas.styler.patched_styler_context import PatchedStylerContext\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\n\n\n@dataclass\nclass _CSSPropsWithIndex:\n    props: dict[str, str]\n    index: int\n\n\nclass _TranslateKeysDict(Mapping, dict):\n\n    def __init__(self, org_dict: dict, translate_key: Callable):\n        self._org_dict = org_dict\n        self._translate_key = translate_key\n\n    def get(self, key, default=None):\n        return self._org_dict.get(self._translate_key(key), default)\n\n    def __contains__(self, key):\n        return self._translate_key(key) in self._org_dict\n\n    def __getitem__(self, key):\n        return self._org_dict[self._translate_key(key)]\n\n    def values(self):\n        return super().values()\n\n    def __iter__(self):\n        raise NotImplementedError\n\n    def keys(self):\n        raise NotImplementedError\n\n    def items(self):\n        raise NotImplementedError\n\n    def __len__(self):\n        return len(self._org_dict)\n\n\nclass TableFrameGenerator(AbstractTableFrameGenerator):\n    def __init__(self,\n                 styler_context: PatchedStylerContext,\n                 todos_filter: Optional[Callable[[StylerTodo], bool]] = None,\n                 ):\n        super().__init__(styler_context.visible_frame)\n        self.__styler_context: PatchedStylerContext = styler_context\n        self.__todos_filter: Optional[Callable[[StylerTodo], bool]] = todos_filter\n\n    def generate(self,\n                 region: Region = None,\n                 exclude_row_header: bool = False,\n                 exclude_col_header: bool = False,\n                 ) -> TableFrame:\n        chunk = self.__styler_context.visible_frame.get_chunk(region)\n        chunk_df = chunk.to_frame()\n\n        chunk_aware_todos = self.__styler_context.create_patched_todos(chunk_df, self.__todos_filter)\n\n        computed_styler = self.__compute_styling(\n            chunk_aware_todos=chunk_aware_todos,\n            exclude_row_header=exclude_row_header,\n            exclude_col_header=exclude_col_header,\n        )\n\n        chunk_styler = chunk_df.style\n        self.__copy_styler_state(source=computed_styler, target=chunk_styler)\n\n        translate_key = chunk.get_translate_into_source_frame_cell_coordinates()\n\n        chunk_styler.ctx = _TranslateKeysDict(computed_styler.ctx, translate_key)\n        chunk_styler.cell_context = _TranslateKeysDict(computed_styler.cell_context, translate_key)\n        chunk_styler._display_funcs = _TranslateKeysDict(computed_styler._display_funcs, translate_key)\n\n        with option_context(\n                \"styler.render.max_elements\", 262144,\n                \"styler.render.max_columns\", None,\n                \"styler.render.max_rows\", None,\n        ):\n            html_props = chunk_styler._translate(sparse_index=False, sparse_cols=False)\n\n        return self._convert_to_table_frame(\n            html_props,\n            chunk,\n            exclude_row_header=exclude_row_header,\n            exclude_col_header=exclude_col_header,\n            formatter=ValueFormatter(),\n        )\n\n    def __compute_styling(self,\n                          chunk_aware_todos: list[tuple[Callable, tuple, dict]],\n                          exclude_row_header: bool = False,\n                          exclude_col_header: bool = False,\n                          ) -> Styler:\n        styler = self.__styler_context.get_styler()\n\n        copy = styler.data.style\n        self.__copy_styler_state(source=styler, target=copy)\n\n        copy._todo = chunk_aware_todos\n\n        if exclude_row_header:\n            copy.hide(axis=\"index\")\n        if exclude_col_header:\n            copy.hide(axis=\"columns\")\n\n        copy._compute()\n        return copy\n\n    @staticmethod\n    def __copy_styler_state(source: Styler, target: Styler):\n        target.uuid = ''\n        target.uuid_len = 0\n        target.cell_ids = False\n\n        target.css = source.css\n        target.table_styles = source.table_styles\n        target.table_attributes = source.table_attributes\n        target.hide_columns_ = source.hide_columns_\n        target.hide_column_names = source.hide_column_names\n        target.hide_index_ = source.hide_index_\n        target.hide_index_names = source.hide_index_names\n        target.cell_context = source.cell_context\n        target._display_funcs = source._display_funcs\n\n    def _convert_to_table_frame(self,\n                                html_props: dict,\n                                chunk: Chunk,\n                                exclude_row_header: bool,\n                                exclude_col_header: bool,\n                                formatter: ValueFormatter,\n                                ) -> TableFrame:\n\n        columns = [] if exclude_col_header else self._extract_columns(html_props, chunk, formatter)\n        index_labels = [] if exclude_row_header else self._extract_index_header_labels(html_props, formatter)\n        cells = self._extract_cells(html_props, formatter)\n        legend_label = None if exclude_col_header and exclude_row_header else self._extract_legend_label(html_props, formatter)\n\n        return TableFrame(\n            index_labels=index_labels,\n            columns=columns,\n            legend=legend_label,\n            cells=cells,\n        )\n\n    @staticmethod\n    def _extract_legend_label(html_props: dict, formatter: ValueFormatter) -> TableFrameLegend:\n        index_legend = []\n        column_legend = []\n\n        head = html_props.get(\"head\", [])\n        if head:\n            last_row = head[-1]\n\n            for element in last_row:\n                element_classes = set(element.get(\"class\", \"\").split(\" \"))\n                if element.get(\"is_visible\", True):\n                    if \"index_name\" in element_classes:\n                        display_value = element.get(\"display_value\", \"\")\n                        index_legend.append(formatter.format_index(display_value))\n                if \"col_heading\" in element_classes:\n                    index_legend = []\n                    break\n\n            other_rows = head if not index_legend else head[:-1]\n            for row in other_rows:\n\n                for element in row:\n                    if element.get(\"is_visible\", True):\n                        element_classes = set(element.get(\"class\", \"\").split(\" \"))\n                        is_index_name = \"index_name\" in element_classes\n\n                        if is_index_name:\n                            display_value = element.get(\"display_value\", \"\")\n                            column_legend.append(formatter.format_index(display_value))\n                            break\n\n        return TableFrameLegend(index=index_legend, column=column_legend) if index_legend or column_legend else None\n\n    def _extract_columns(self, html_props: dict, chunk: Chunk, formatter: ValueFormatter) -> list[TableFrameColumn]:\n        result: list[TableFrameColumn] = []\n\n        for row in html_props.get(\"head\", []):\n\n            is_first_row = not result\n            col_heading_index = 0\n\n            for element in row:\n                if element.get(\"is_visible\", True):\n                    element_classes = set(element.get(\"class\", \"\").split(\" \"))\n                    is_column_header = \"col_heading\" in element_classes\n\n                    if is_column_header:\n                        display_value = formatter.format_column(element.get(\"display_value\", \"\"))\n                        if is_first_row:\n                            result.append(\n                                TableFrameColumn(\n                                    dtype=str(chunk.dtype_at(col_heading_index)),\n                                    labels=[display_value],\n                                    describe=None if self._exclude_column_describe else chunk.describe_at(col_heading_index),\n                                )\n                            )\n                        else:\n                            result[col_heading_index].labels.append(display_value)\n                        col_heading_index += 1\n\n        return result\n\n    @staticmethod\n    def _extract_index_header_labels(html_props: dict, formatter: ValueFormatter) -> list[list[str]]:\n        result: list[list[str]] = []\n\n        for row in html_props.get(\"body\", []):\n\n            index_label = []\n\n            for element in row:\n                if element.get(\"type\", \"\") == \"td\":\n                    break\n                if element.get(\"is_visible\", True):\n                    element_classes = set(element.get(\"class\", \"\").split(\" \"))\n                    is_index_header = \"row_heading\" in element_classes\n\n                    if is_index_header:\n                        display_value = element.get(\"display_value\", \"\")\n                        index_label.append(formatter.format_index(display_value))\n\n            if index_label:\n                result.append(index_label)\n\n        return result\n\n    def _extract_cells(self, html_props: dict, formatter: ValueFormatter) -> list[list[TableFrameCell]]:\n        result: list[list[TableFrameCell]] = []\n\n        css_dict = self.__create_css_dict(html_props)\n\n        for row in html_props.get(\"body\", []):\n\n            cells_in_row = []\n\n            for element in row:\n\n                if element.get(\"type\", \"\") == \"td\" and element.get(\"is_visible\", True):\n                    element_classes = set(element.get(\"class\", \"\").split(\" \"))\n\n                    if \"data\" in element_classes:\n                        cells_in_row.append(\n                            TableFrameCell(\n                                value=formatter.format_cell(element.get(\"display_value\", \"\")),\n                                css=self._get_css_dict(element.get(\"id\", None), element_classes, css_dict),\n                            ),\n                        )\n\n            if cells_in_row:\n                result.append(cells_in_row)\n\n        return result\n\n    @staticmethod\n    def _get_css_dict(element_id: str, element_classes: set[str], css_dict: dict[str, _CSSPropsWithIndex]) -> \\\n            Optional[dict]:\n        if not css_dict:\n            return None\n\n        matching_css_props: list[_CSSPropsWithIndex] = []\n\n        for c in element_classes:\n            css_props = css_dict.get(c, None)\n            if css_props is not None:\n                matching_css_props.append(css_props)\n\n        if matching_css_props:\n            matching_css_props.sort(key=lambda x: x.index)\n\n        id_css_props = css_dict.get(element_id, None)\n        if id_css_props is not None:\n            matching_css_props.append(id_css_props)\n\n        if not matching_css_props:\n            return None\n\n        result: dict[str, str] = {}\n        for css_props in matching_css_props:\n            result.update(css_props.props)\n\n        return result\n\n    @staticmethod\n    def __create_css_dict(html_props: dict) -> dict[str, _CSSPropsWithIndex]:\n        cellstyle = html_props.get(\"cellstyle\", None)\n        css_dict: dict[str, _CSSPropsWithIndex] = {}\n        if cellstyle is not None:\n            for index, entry in enumerate(cellstyle):\n                props = entry['props']\n                if not props:\n                    continue\n                css_props = _CSSPropsWithIndex({p[0]: p[1] for p in props}, index)\n                for s in entry.get('selectors', []):\n                    css_dict[s] = css_props\n        return css_dict\n",
                "table_source_factory": "from typing import Any, Union\n\nfrom pandas import DataFrame\nfrom pandas.io.formats.style import Styler\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableSource, AbstractTableSourceFactory\nfrom cms_rendner_sdfv.base.types import CreateTableSourceConfig, CreateTableSourceFailure\nfrom cms_rendner_sdfv.pandas.shared.create_fingerprint import create_fingerprint\nfrom cms_rendner_sdfv.pandas.shared.types import FilterCriteria\nfrom cms_rendner_sdfv.pandas.styler.patched_styler import PatchedStyler\nfrom cms_rendner_sdfv.pandas.styler.patched_styler_context import PatchedStylerContext\n\n\nclass TableSourceFactory(AbstractTableSourceFactory):\n\n    def _create_internal(self,\n                         data_source: Any,\n                         config: CreateTableSourceConfig,\n                         caller_globals: dict,\n                         ) -> Union[AbstractTableSource, CreateTableSourceFailure]:\n\n        if not isinstance(data_source, Styler):\n            return CreateTableSourceFailure(error_kind=\"UNSUPPORTED_DATA_SOURCE_TYPE\", info=str(type(data_source)))\n\n        ds_frame = data_source.data\n        ds_frame_style = data_source\n\n        pre_fingerprint = config.previous_fingerprint\n        cur_fingerprint = create_fingerprint(ds_frame, data_source)\n        if pre_fingerprint is not None and pre_fingerprint != cur_fingerprint:\n            return CreateTableSourceFailure(error_kind=\"INVALID_FINGERPRINT\", info=cur_fingerprint)\n\n        filter_frame = None\n        filter_eval_expr = config.filter_eval_expr\n        if filter_eval_expr is not None and filter_eval_expr != \"\":\n            try:\n                if config.filter_eval_expr_provide_frame:\n                    caller_globals[\"_df\"] = ds_frame\n                filter_frame = eval(filter_eval_expr, caller_globals)\n            except Exception as e:\n                return CreateTableSourceFailure(error_kind=\"FILTER_FRAME_EVAL_FAILED\", info=repr(e))\n\n            if not isinstance(filter_frame, DataFrame):\n                return CreateTableSourceFailure(error_kind=\"FILTER_FRAME_OF_WRONG_TYPE\", info=str(type(filter_frame)))\n\n        return PatchedStyler(\n            PatchedStylerContext(ds_frame_style, FilterCriteria.from_frame(filter_frame)),\n            fingerprint=cur_fingerprint,\n        )\n",
                "todo_patcher": "from abc import ABC, abstractmethod\nfrom typing import Optional\n\nfrom pandas import DataFrame\nfrom pandas.io.formats.style_render import Subset, non_reducing_slice\n\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\n\n\nclass TodoPatcher(ABC):\n\n    def __init__(self, todo: StylerTodo):\n        self._todo: StylerTodo = todo\n\n    @abstractmethod\n    def create_patched_todo(self, org_frame: DataFrame, chunk: DataFrame) -> Optional[StylerTodo]:\n        pass\n\n    @staticmethod\n    def _calculate_chunk_subset(org_subset_frame: DataFrame, chunk: DataFrame) -> Subset:\n        index_intersection = chunk.index.intersection(org_subset_frame.index)\n        column_intersection = chunk.columns.intersection(org_subset_frame.columns)\n        return index_intersection, column_intersection\n\n    @staticmethod\n    def _create_subset_frame(org_frame: DataFrame, subset: Optional[Subset]) -> DataFrame:\n        subset = slice(None) if subset is None else subset\n        subset = non_reducing_slice(subset)\n        return org_frame.loc[subset]\n",
                "todos_patcher": "from typing import Callable, Optional\n\nfrom pandas import DataFrame\n\nfrom cms_rendner_sdfv.pandas.styler.apply_patcher import ApplyPatcher\nfrom cms_rendner_sdfv.pandas.styler.background_gradient_patcher import BackgroundGradientPatcher\nfrom cms_rendner_sdfv.pandas.styler.highlight_between_patcher import HighlightBetweenPatcher\nfrom cms_rendner_sdfv.pandas.styler.highlight_extrema_patcher import HighlightExtremaPatcher\nfrom cms_rendner_sdfv.pandas.styler.map_patcher import MapPatcher\nfrom cms_rendner_sdfv.pandas.styler.style_function_name_resolver import StyleFunctionNameResolver\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\n\n\nclass TodosPatcher:\n\n    def patch_todos_for_chunk(self,\n                              todos: list[StylerTodo],\n                              org_frame: DataFrame,\n                              chunk: DataFrame,\n                              ) -> list[tuple[Callable, tuple, dict]]:\n        result: list[tuple[Callable, tuple, dict]] = []\n\n        for t in todos:\n\n            if t.is_pandas_style_func():\n                patcher = self.__get_patcher_for_pandas_style_function(t)\n            else:\n                if t.is_map():\n                    patcher = MapPatcher(t)\n                else:\n                    patcher = ApplyPatcher(t)\n\n            if patcher is not None:\n                result.append(patcher.create_patched_todo(org_frame, chunk).to_tuple())\n\n        return result\n\n    @staticmethod\n    def is_style_function_supported(todo: StylerTodo) -> bool:\n        if todo.is_pandas_style_func():\n            return TodosPatcher.__get_patcher_for_pandas_style_function(todo) is not None\n        return True\n\n    @staticmethod\n    def __get_patcher_for_pandas_style_function(todo: StylerTodo) -> Optional[TodoPatcher]:\n        qname = StyleFunctionNameResolver.get_style_func_qname(todo)\n        if StyleFunctionNameResolver.is_pandas_text_gradient(qname, todo):\n            return BackgroundGradientPatcher(todo)\n        elif StyleFunctionNameResolver.is_pandas_background_gradient(qname):\n            return BackgroundGradientPatcher(todo)\n        elif StyleFunctionNameResolver.is_pandas_highlight_max(qname, todo):\n            return HighlightExtremaPatcher(todo, 'max')\n        elif StyleFunctionNameResolver.is_pandas_highlight_min(qname, todo):\n            return HighlightExtremaPatcher(todo, 'min')\n        elif StyleFunctionNameResolver.is_pandas_highlight_null(qname):\n            return ApplyPatcher(todo)\n        elif StyleFunctionNameResolver.is_pandas_highlight_between(qname):\n            return HighlightBetweenPatcher(todo)\n        elif StyleFunctionNameResolver.is_pandas_set_properties(qname):\n            return MapPatcher(todo)\n        return None\n",
                "types": "from dataclasses import dataclass\nfrom enum import Enum\n\n\n@dataclass(frozen=True)\nclass StyleFunctionValidationProblem:\n    index: int\n    reason: str\n    message: str = \"\"\n\n\nclass ValidationStrategyType(Enum):\n    FAST = \"fast\"\n    PRECISION = \"precision\"\n\n\n@dataclass(frozen=True)\nclass StyleFunctionInfo:\n    index: int\n    qname: str\n    resolved_name: str\n    axis: str\n    is_chunk_parent_requested: bool\n    is_apply: bool\n    is_pandas_builtin: bool\n    is_supported: bool\n"
            }
        }
    }
}