{
    "cms_rendner_sdfv": {
        "pandas": {
            "frame": {
                "frame_context": "from typing import Any, Optional\n\nfrom pandas import DataFrame\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableFrameGenerator\nfrom cms_rendner_sdfv.base.types import Region, TableStructureColumnInfo, TableStructureColumn, \\\n    TableStructureLegend\nfrom cms_rendner_sdfv.pandas.frame.frame_value_formatter import FrameValueFormatter\nfrom cms_rendner_sdfv.pandas.shared.pandas_table_source_context import PandasTableSourceContext\nfrom cms_rendner_sdfv.pandas.shared.types import FilterCriteria\nfrom cms_rendner_sdfv.pandas.shared.visible_frame import VisibleFrame\n\n\nclass Chunk:\n    def __init__(self, visible_frame: VisibleFrame, region: Region):\n        self.__visible_frame = visible_frame\n        self.region = region\n\n    def cell_value_at(self, row: int, col: int):\n        return self.__visible_frame.cell_value_at(\n            self.region.first_row + row,\n            self.region.first_col + col,\n        )\n\n    def row_labels_at(self, row: int) -> list[Any]:\n        return self.__visible_frame.row_labels_at(self.region.first_row + row)\n\n\nclass FrameContext(PandasTableSourceContext):\n\n    def __init__(self, source_frame: DataFrame, filter_criteria: Optional[FilterCriteria] = None):\n        super().__init__(source_frame, filter_criteria)\n        self.__source_frame = source_frame\n\n    def unlink(self):\n        self.__source_frame = None\n        super().unlink()\n\n    def get_table_frame_generator(self) -> AbstractTableFrameGenerator:\n        from cms_rendner_sdfv.pandas.frame.table_frame_generator import TableFrameGenerator\n        return TableFrameGenerator(self)\n\n    def get_chunk(self, region: Region) -> Chunk:\n        return Chunk(self.visible_frame, self.visible_frame.region.get_bounded_region(region))\n\n    def _get_frame_column_info(self) -> TableStructureColumnInfo:\n        formatter = FrameValueFormatter()\n\n        ts_columns = []\n        dtypes = self.__source_frame.dtypes\n        nlevels = self.__source_frame.columns.nlevels\n        for col in self.visible_frame.get_column_indices():\n            col_label = self.__source_frame.columns[col]\n            labels = [col_label] if nlevels == 1 else col_label\n            labels = [formatter.format_column(lbl) for lbl in labels]\n            ts_columns.append(TableStructureColumn(dtype=str(dtypes[col_label]), labels=labels, id=col))\n\n        index_legend = [formatter.format_index(lbl) for lbl in self.visible_frame.index_names if lbl is not None]\n        column_legend = [formatter.format_index(lbl) for lbl in self.visible_frame.column_names if lbl is not None]\n\n        return TableStructureColumnInfo(\n            columns=ts_columns,\n            legend=TableStructureLegend(\n                index=index_legend,\n                column=column_legend,\n            ) if index_legend or column_legend else None\n        )\n",
                "frame_value_formatter": "from typing import Any, Callable, Optional\n\nfrom pandas import get_option\nfrom pandas.core.dtypes.common import (\n    is_complex,\n    is_float,\n    is_integer,\n)\n\nfrom cms_rendner_sdfv.pandas.shared.value_formatter import ValueFormatter\n\n\nclass FrameValueFormatter(ValueFormatter):\n    def __init__(self):\n        self.__precision = get_option(\"display.precision\")\n        self.__float_format: Optional[Callable] = get_option(\"display.float_format\")\n\n    def _default_format(self, x: Any, fallback_formatter) -> Any:\n        if is_float(x) or is_complex(x):\n            if callable(self.__float_format):\n                return self.__float_format(x)\n            return f\"{x:.{self.__precision}f}\"\n        elif is_integer(x):\n            return str(x)\n\n        return fallback_formatter(x)\n\n    def format_column(self, value: Any) -> str:\n        return self._default_format(value, super().format_column)\n\n    def format_index(self, value: Any) -> str:\n        return self._default_format(value, super().format_index)\n\n    def format_cell(self, value: Any) -> str:\n        return self._default_format(value, super().format_cell)",
                "table_frame_generator": "from cms_rendner_sdfv.base.table_source import AbstractTableFrameGenerator\nfrom cms_rendner_sdfv.base.types import Region, TableFrame, TableFrameCell\nfrom cms_rendner_sdfv.pandas.frame.frame_context import FrameContext\nfrom cms_rendner_sdfv.pandas.frame.frame_value_formatter import FrameValueFormatter\n\n\nclass TableFrameGenerator(AbstractTableFrameGenerator):\n    def __init__(self, context: FrameContext):\n        super().__init__(context.visible_frame)\n        self.__context: FrameContext = context\n\n    def generate(self,\n                 region: Region = None,\n                 exclude_row_header: bool = False,\n                 ) -> TableFrame:\n        chunk = self.__context.get_chunk(region)\n        formatter = FrameValueFormatter()\n\n        col_range = range(chunk.region.cols)\n        cells: list[list[TableFrameCell]] = []\n        index_labels: list[list[str]] = []\n\n        for r in range(chunk.region.rows):\n            if not exclude_row_header:\n                index_labels.append([formatter.format_index(lbl) for lbl in chunk.row_labels_at(r)])\n            cells.append(\n                [TableFrameCell(value=formatter.format_cell(chunk.cell_value_at(r, c))) for c in col_range]\n            )\n\n        return TableFrame(index_labels=index_labels, cells=cells)\n",
                "table_source": "from cms_rendner_sdfv.base.table_source import AbstractTableSource\nfrom cms_rendner_sdfv.base.types import TableSourceKind\nfrom cms_rendner_sdfv.pandas.frame.frame_context import FrameContext\n\n\nclass TableSource(AbstractTableSource):\n    def __init__(self, context: FrameContext, fingerprint: str):\n        super().__init__(TableSourceKind.TABLE_SOURCE, context, fingerprint)\n",
                "table_source_factory": "from typing import Any, Union\n\nfrom pandas import DataFrame\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableSource, AbstractTableSourceFactory\nfrom cms_rendner_sdfv.base.types import CreateTableSourceConfig, CreateTableSourceFailure, CreateTableSourceErrorKind\nfrom cms_rendner_sdfv.pandas.frame.table_source import TableSource\nfrom cms_rendner_sdfv.pandas.frame.frame_context import FrameContext\nfrom cms_rendner_sdfv.pandas.shared.create_fingerprint import create_fingerprint\nfrom cms_rendner_sdfv.pandas.shared.types import FilterCriteria\n\n\nclass TableSourceFactory(AbstractTableSourceFactory):\n\n    def _create_internal(self,\n                         data_source: Any,\n                         config: CreateTableSourceConfig,\n                         caller_globals: dict,\n                         ) -> Union[AbstractTableSource, CreateTableSourceFailure]:\n        ds_frame = None\n        if isinstance(data_source, dict):\n            if config.data_source_transform_hint == \"DictKeysAsRows\":\n                ds_frame = DataFrame.from_dict(data_source, orient='index')\n            elif all(name in data_source for name in [\"index\", \"columns\", \"data\", \"index_names\", \"column_names\"]):\n                ds_frame = DataFrame.from_dict(data_source, orient='tight')\n            else:\n                try:\n                    ds_frame = DataFrame.from_dict(data_source, orient='columns')\n                except ValueError as e:\n                    if str(e) == \"If using all scalar values, you must pass an index\":\n                        ds_frame = DataFrame(data_source, index=[0])\n        elif isinstance(data_source, DataFrame):\n            ds_frame = data_source\n        else:\n            return CreateTableSourceFailure(\n                error_kind=CreateTableSourceErrorKind.UNSUPPORTED_DATA_SOURCE_TYPE,\n                info=str(type(data_source)),\n            )\n\n        pre_fingerprint = config.previous_fingerprint\n        cur_fingerprint = create_fingerprint(ds_frame, data_source)\n        if pre_fingerprint is not None and pre_fingerprint != cur_fingerprint:\n            return CreateTableSourceFailure(\n                error_kind=CreateTableSourceErrorKind.INVALID_FINGERPRINT,\n                info=cur_fingerprint,\n            )\n\n        filter_frame = None\n        filter_eval_expr = config.filter_eval_expr\n        if filter_eval_expr is not None and filter_eval_expr != \"\":\n            try:\n                if config.filter_eval_expr_provide_frame:\n                    caller_globals[\"_df\"] = ds_frame\n                filter_frame = eval(filter_eval_expr, caller_globals)\n            except Exception as e:\n                return CreateTableSourceFailure(\n                    error_kind=CreateTableSourceErrorKind.FILTER_FRAME_EVAL_FAILED,\n                    info=repr(e),\n                )\n\n            if not isinstance(filter_frame, DataFrame):\n                return CreateTableSourceFailure(\n                    error_kind=CreateTableSourceErrorKind.FILTER_FRAME_OF_WRONG_TYPE,\n                    info=str(type(filter_frame)),\n                )\n\n        return TableSource(\n            FrameContext(ds_frame, FilterCriteria.from_frame(filter_frame)),\n            fingerprint=cur_fingerprint,\n        )\n"
            },
            "shared": {
                "create_fingerprint": "from hashlib import blake2b\nfrom typing import Any\n\nfrom pandas import DataFrame\n\n\ndef create_fingerprint(frame: DataFrame, org_data_source: Any = None) -> str:\n    fingerprint_input = [\n        id(org_data_source if org_data_source is not None else frame),\n        frame.shape,\n        frame.index[:60],\n        frame.dtypes[:60]\n    ]\n    return blake2b('-'.join(str(x) for x in fingerprint_input).encode(), digest_size=16).hexdigest()",
                "pandas_table_source_context": "from abc import ABC, abstractmethod\nfrom typing import Optional, Any, List, Union\n\nfrom pandas import DataFrame\n\nfrom cms_rendner_sdfv.base.helpers import fq_type\nfrom cms_rendner_sdfv.base.table_source import AbstractTableSourceContext\nfrom cms_rendner_sdfv.base.types import SortCriteria, TableStructure, TableStructureColumnInfo, CompletionVariant, \\\n    NestedCompletionVariant\nfrom cms_rendner_sdfv.pandas.shared.types import FilterCriteria\nfrom cms_rendner_sdfv.pandas.shared.visible_frame import VisibleFrame, MappedVisibleFrame\n\n\nclass PandasTableSourceContext(AbstractTableSourceContext, ABC):\n    def __init__(self, source_frame: DataFrame, filter_criteria: Optional[FilterCriteria] = None):\n        self.__source_frame = source_frame\n        self.__sort_criteria: SortCriteria = SortCriteria()\n        self.__filter_criteria: FilterCriteria = filter_criteria if filter_criteria is not None else FilterCriteria()\n        self.__visible_frame: VisibleFrame = self.__recompute_visible_frame()\n\n    def unlink(self):\n        self.__source_frame = None\n        self.__sort_criteria = None\n        self.__filter_criteria = None\n        self.__visible_frame.unlink()\n        self.__visible_frame = None\n\n    @property\n    def visible_frame(self) -> VisibleFrame:\n        return self.__visible_frame\n\n    def get_table_structure(self, fingerprint: str) -> TableStructure:\n        rows_count = self.__visible_frame.region.rows\n        columns_count = self.__visible_frame.region.cols\n        if rows_count == 0 or columns_count == 0:\n            rows_count = columns_count = 0\n        return TableStructure(\n            org_rows_count=len(self.__source_frame.index),\n            org_columns_count=len(self.__source_frame.columns),\n            rows_count=rows_count,\n            columns_count=columns_count,\n            fingerprint=fingerprint,\n            column_info=self._get_frame_column_info() if columns_count != 0\n            else TableStructureColumnInfo(columns=[], legend=None),\n        )\n\n    @abstractmethod\n    def _get_frame_column_info(self) -> TableStructureColumnInfo:\n        pass\n\n    def get_column_name_completion_variants(self, source: Any, is_synthetic_df: bool) -> List[Union[CompletionVariant, NestedCompletionVariant]]:\n        result = []\n\n        if (source is None and is_synthetic_df) or source is self.__source_frame:\n            source = self.__source_frame\n\n        if not isinstance(source, DataFrame):\n            return result\n\n        for col in source.columns:\n            if isinstance(col, tuple):\n                result.append(\n                    NestedCompletionVariant(\n                        fq_type=fq_type(col),\n                        children=[CompletionVariant(fq_type=fq_type(lvl), value=str(lvl)) for lvl in col],\n                    )\n                )\n            else:\n                result.append(CompletionVariant(fq_type=fq_type(col), value=str(col)))\n\n        return result\n\n    def set_sort_criteria(self, sort_by_column_index: Optional[list[int]], sort_ascending: Optional[list[bool]]):\n        new_sort_criteria = SortCriteria(sort_by_column_index, sort_ascending)\n        if new_sort_criteria != self.__sort_criteria:\n            self.__sort_criteria = new_sort_criteria\n            self.__visible_frame = self.__recompute_visible_frame()\n\n    def _get_initial_visible_frame_indexes(self):\n        return self.__source_frame.index, self.__source_frame.columns\n\n    def __recompute_visible_frame(self) -> VisibleFrame:\n        index, columns = self._get_initial_visible_frame_indexes()\n\n        if self.__filter_criteria.index is not None:\n            index = index.intersection(self.__filter_criteria.index)\n\n        if self.__filter_criteria.columns is not None:\n            columns = columns.intersection(self.__filter_criteria.columns)\n\n        if not self.__sort_criteria.is_empty():\n            sc = self.__sort_criteria\n            frame = self.__source_frame.loc[index, columns]\n            frame = frame.sort_values(\n                by=[frame.columns[i] for i in sc.by_column],\n                ascending=True if sc.ascending is None or len(sc.ascending) == 0 else sc.ascending,\n            )\n            index = frame.index\n\n        if index is self.__source_frame.index and columns is self.__source_frame.columns:\n            return VisibleFrame(self.__source_frame)\n\n        return MappedVisibleFrame(\n            self.__source_frame,\n            self.__source_frame.index.get_indexer_for(index).tolist(),\n            self.__source_frame.columns.get_indexer_for(columns).tolist(),\n        )\n",
                "types": "from dataclasses import dataclass\nfrom typing import Optional\n\nfrom pandas import DataFrame, Index\n\n\n@dataclass(frozen=True)\nclass FilterCriteria:\n    index: Optional[Index] = None\n    columns: Optional[Index] = None\n\n    @staticmethod\n    def from_frame(frame: Optional[DataFrame]):\n        return None if frame is None else FilterCriteria(frame.index, frame.columns)\n\n    def is_empty(self) -> bool:\n        return self.index is None and self.columns is None\n\n    def __eq__(self, other):\n        if isinstance(other, FilterCriteria):\n            def _equals(s: Optional[Index], o: Optional[Index]) -> bool:\n                if s is None and o is None:\n                    return True\n                return s is not None and o is not None and s.equals(o)\n\n            return _equals(self.columns, other.columns) and _equals(self.index, other.index)\n        return False\n",
                "value_formatter": "from typing import Any\n\nfrom pandas.errors import OptionError\nfrom pandas.io.formats.printing import pprint_thing, get_option\n\nfrom cms_rendner_sdfv.base.constants import CELL_MAX_STR_LEN\nfrom cms_rendner_sdfv.base.helpers import truncate_str\n\n\nclass ValueFormatter:\n\n    @staticmethod\n    def format_column(value: Any) -> str:\n        return value if isinstance(value, str) else pprint_thing(value)\n\n    @staticmethod\n    def format_index(value: Any) -> str:\n        return value if isinstance(value, str) else pprint_thing(value)\n\n    @staticmethod\n    def format_cell(value: Any) -> str:\n        v = value\n        if not isinstance(v, str):\n            max_seq_items = None\n            try:\n                max_seq_items = get_option(\"display.max_seq_items\", True)\n            except OptionError:\n                pass\n            v = pprint_thing(v, max_seq_items=max_seq_items or 42)\n        return truncate_str(v, CELL_MAX_STR_LEN)\n",
                "visible_frame": "from typing import Dict, Any\n\nfrom pandas import DataFrame, Series\n\nfrom cms_rendner_sdfv.base.constants import DESCRIBE_COL_MAX_STR_LEN\nfrom cms_rendner_sdfv.base.helpers import truncate_str\nfrom cms_rendner_sdfv.base.table_source import AbstractVisibleFrame\nfrom cms_rendner_sdfv.base.types import Region\n\n\nclass VisibleFrame(AbstractVisibleFrame):\n    def __init__(self, source_frame: DataFrame):\n        super().__init__(Region(first_row=0, first_col=0, rows=len(source_frame.index), cols=len(source_frame.columns)))\n        self._source_frame = source_frame\n\n    def unlink(self):\n        self._source_frame = None\n\n    @property\n    def index_names(self) -> list:\n        return self._source_frame.index.names\n\n    @property\n    def column_names(self) -> list:\n        return self._source_frame.columns.names\n\n    def cell_value_at(self, row: int, col: int):\n        return self._source_frame.iat[row, col]\n\n    def row_labels_at(self, row: int) -> list[Any]:\n        labels = self._source_frame.index[row]\n        if self._source_frame.index.nlevels == 1:\n            return [labels]\n        return list(labels)\n\n    def to_frame(self, region: Region) -> DataFrame:\n        r = self.region.get_bounded_region(region)\n        return self._source_frame.iloc[\n               r.first_row:r.first_row + r.rows,\n               r.first_col:r.first_col + r.cols,\n               ]\n\n    def to_source_frame_cell_coordinates(self, row: int, col: int):\n        return row, col\n\n    def _get_col_series(self, col_index) -> Series:\n        return self._source_frame.iloc[:, col_index]\n\n    def get_column_statistics(self, col_index: int) -> Dict[str, str]:\n        try:\n            col_series = self._get_col_series(col_index)\n            return {\n                k: truncate_str(str(v), DESCRIBE_COL_MAX_STR_LEN)\n                for k, v in col_series.describe().to_dict().items()\n            }\n        except TypeError as e:\n            return {'error': str(e)}\n\n\nclass MappedVisibleFrame(VisibleFrame):\n    def __init__(self, source_frame: DataFrame, visible_rows: list[int], visible_cols: list[int]):\n        super().__init__(source_frame)\n        self.region = Region(first_row=0, first_col=0, rows=len(visible_rows), cols=len(visible_cols))\n        self.__i_rows = visible_rows\n        self.__i_cols = visible_cols\n\n    def unlink(self):\n        super().unlink()\n        self.__i_rows = None\n        self.__i_cols = None\n\n    def cell_value_at(self, row: int, col: int):\n        return self._source_frame.iat[self.__i_rows[row], self.__i_cols[col]]\n\n    def row_labels_at(self, row: int) -> list[Any]:\n        labels = self._source_frame.index[self.__i_rows[row]]\n        if self._source_frame.index.nlevels == 1:\n            return [labels]\n        return list(labels)\n\n    def to_frame(self, region: Region) -> DataFrame:\n        r = self.region.get_bounded_region(region)\n        i_rows = self.__i_rows[r.first_row:r.first_row + r.rows]\n        i_cols = self.__i_cols[r.first_col:r.first_col + r.cols]\n        return self._source_frame.iloc[i_rows, i_cols]\n\n    def to_source_frame_cell_coordinates(self, row: int, col: int) -> tuple[int, int]:\n        return self.__i_rows[row], self.__i_cols[col]\n\n    def get_column_indices(self) -> list[int]:\n        return self.__i_cols\n\n    def _get_col_series(self, col_index) -> Series:\n        return self._source_frame.iloc[self.__i_rows, self.__i_cols[col_index]]\n"
            },
            "styler": {
                "apply_patcher": "from typing import Optional, Union\n\nfrom pandas import DataFrame, Series\n\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\n\n\nclass ApplyPatcher(TodoPatcher):\n\n    def __init__(self, org_frame: DataFrame, todo: StylerTodo):\n        super().__init__(org_frame, todo)\n\n    def create_patched_todo(self, chunk: DataFrame) -> Optional[StylerTodo]:\n        builder = self._todo_builder(chunk)\n        if self.todo.should_provide_chunk_parent():\n            builder.with_style_func(self._wrap_with_chunk_parent_provider(self._styling_func))\n        else:\n            builder.with_style_func(self._styling_func)\n        return builder.build()\n\n    def _styling_func(self, chunk_or_series_from_chunk: Union[DataFrame, Series], **kwargs):\n        if chunk_or_series_from_chunk.empty:\n            return chunk_or_series_from_chunk\n        return self.todo.apply_args.style_func(chunk_or_series_from_chunk, **kwargs)\n",
                "background_gradient_patcher": "from collections.abc import Sequence\nfrom typing import Optional, Union, Dict\n\nimport numpy as np\nfrom pandas import DataFrame, Series\nfrom pandas.io.formats.style import _validate_apply_axis_arg\n\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\n\n\nclass BackgroundGradientPatcher(TodoPatcher):\n\n    def __init__(self, org_frame: DataFrame, todo: StylerTodo):\n        super().__init__(org_frame, todo)\n        self.__computed_params_cache: Dict[str, tuple[float, float, Sequence]] = {}\n\n    def unlink(self):\n        super().unlink()\n        self.__computed_params_cache = None\n\n    def create_patched_todo(self, chunk: DataFrame) -> Optional[StylerTodo]:\n        return self._todo_builder(chunk) \\\n            .with_style_func(self._wrap_with_chunk_parent_provider(self._styling_func)) \\\n            .build()\n\n    def _styling_func(self,\n                      chunk_or_series_from_chunk: Union[DataFrame, Series],\n                      chunk_parent: Union[DataFrame, Series],\n                      **kwargs,\n                      ):\n        if chunk_or_series_from_chunk.empty:\n            return chunk_or_series_from_chunk\n\n        vmin, vmax, gmap = self.__get_or_compute_parameters(chunk_parent, kwargs)\n\n        chunk_gmap = self.__extract_chunk_gmap_from_chunk_parent_gmap(gmap, chunk_or_series_from_chunk, chunk_parent)\n\n        return self.todo.apply_args.style_func(\n            chunk_or_series_from_chunk,\n            **dict(kwargs, vmin=vmin, vmax=vmax, gmap=chunk_gmap),\n        )\n\n    def __get_or_compute_parameters(self,\n                                    chunk_parent: Union[DataFrame, Series],\n                                    kwargs: Dict,\n                                    ) -> tuple[float, float, Sequence]:\n        cache_key = \"frame\"\n        if isinstance(chunk_parent, Series):\n            cache_key = chunk_parent.name\n\n        params = self.__computed_params_cache.get(cache_key, None)\n\n        if params is None:\n            params = self.__compute_params(chunk_parent, kwargs)\n            self.__computed_params_cache[cache_key] = params\n\n        return params\n\n    @staticmethod\n    def __compute_params(chunk_parent: Union[DataFrame, Series], kwargs: Dict) -> tuple[float, float, Sequence]:\n\n        vmin = kwargs.get(\"vmin\", None)\n        vmax = kwargs.get(\"vmax\", None)\n        gmap = kwargs.get(\"gmap\", None)\n\n        if gmap is None:\n            gmap = chunk_parent.to_numpy(dtype=float, na_value=np.nan)\n        else:\n            gmap = _validate_apply_axis_arg(gmap, \"gmap\", float, chunk_parent)\n\n        if vmin is None:\n            vmin = np.nanmin(gmap)\n        if vmax is None:\n            vmax = np.nanmax(gmap)\n\n        return vmin, vmax, gmap\n\n    @staticmethod\n    def __extract_chunk_gmap_from_chunk_parent_gmap(gmap: Sequence,\n                                                    chunk_or_series_from_chunk: Union[DataFrame, Series],\n                                                    chunk_parent: Union[DataFrame, Series],\n                                                    ) -> Sequence:\n        if isinstance(chunk_parent, Series):\n            return gmap[chunk_parent.index.get_indexer_for(chunk_or_series_from_chunk.index)]\n        elif isinstance(chunk_parent, DataFrame):\n            ri = chunk_parent.index.get_indexer_for(chunk_or_series_from_chunk.index)\n            ci = chunk_parent.columns.get_indexer_for(chunk_or_series_from_chunk.columns)\n            if isinstance(gmap, DataFrame):\n                return gmap.iloc[(ri, ci)]\n            elif isinstance(gmap, np.ndarray):\n                return DataFrame(data=gmap, index=chunk_parent.index, columns=chunk_parent.columns).iloc[(ri, ci)]\n        return gmap\n",
                "highlight_between_patcher": "from typing import Optional, Union\n\nimport numpy as np\nfrom pandas import DataFrame, Series\nfrom pandas.io.formats.style import _validate_apply_axis_arg\n\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\n\n\nclass HighlightBetweenPatcher(TodoPatcher):\n\n    def __init__(self, org_frame: DataFrame, todo: StylerTodo):\n        super().__init__(org_frame, todo)\n\n    def create_patched_todo(self, chunk: DataFrame) -> Optional[StylerTodo]:\n        return self._todo_builder(chunk) \\\n            .with_style_func(self._wrap_with_chunk_parent_provider(self._styling_func)) \\\n            .build()\n\n    def _styling_func(self,\n                      chunk_or_series_from_chunk: Union[DataFrame, Series],\n                      chunk_parent: Union[DataFrame, Series],\n                      **kwargs,\n                      ):\n        if chunk_or_series_from_chunk.empty:\n            return chunk_or_series_from_chunk\n\n        left = kwargs.get(\"left\", None)\n        right = kwargs.get(\"right\", None)\n\n        if np.iterable(left) and not isinstance(left, str):\n            left = _validate_apply_axis_arg(left, \"left\", None, chunk_parent)\n            left = self.__extract_chunk_bounds_from_chunk_parent_bounds(left, chunk_or_series_from_chunk, chunk_parent)\n\n        if np.iterable(right) and not isinstance(right, str):\n            right = _validate_apply_axis_arg(right, \"right\", None, chunk_parent)\n            right = self.__extract_chunk_bounds_from_chunk_parent_bounds(right, chunk_or_series_from_chunk, chunk_parent)\n\n        return self.todo.apply_args.style_func(\n            chunk_or_series_from_chunk,\n            **dict(kwargs, left=left, right=right),\n        )\n\n    @staticmethod\n    def __extract_chunk_bounds_from_chunk_parent_bounds(bounds: np.ndarray,\n                                                        chunk_or_series_from_chunk: Union[DataFrame, Series],\n                                                        chunk_parent: Union[DataFrame, Series],\n                                                        ) -> np.ndarray:\n        if isinstance(chunk_parent, Series):\n            return bounds[chunk_parent.index.get_indexer_for(chunk_or_series_from_chunk.index)]\n        elif isinstance(chunk_parent, DataFrame):\n            ri = chunk_parent.index.get_indexer_for(chunk_or_series_from_chunk.index)\n            ci = chunk_parent.columns.get_indexer_for(chunk_or_series_from_chunk.columns)\n            if isinstance(bounds, DataFrame):\n                return bounds.iloc[(ri, ci)]\n            elif isinstance(bounds, np.ndarray):\n                return DataFrame(data=bounds, index=chunk_parent.index, columns=chunk_parent.columns).iloc[(ri, ci)]\n        return bounds\n",
                "highlight_extrema_patcher": "from typing import Optional, Union\n\nimport numpy as np\nimport pandas as pd\nfrom pandas import DataFrame, Series\n\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\n\n\nclass HighlightExtremaPatcher(TodoPatcher):\n\n    def __init__(self, org_frame: DataFrame, todo: StylerTodo):\n        super().__init__(org_frame, todo)\n        self.__attribute: str = todo.style_func_kwargs.get('props', 'background-color: yellow')\n        self.__computed_values_cache = {}\n        self._op: str = \"unset\"\n\n    def unlink(self):\n        super().unlink()\n        self.__computed_values_cache = None\n\n    def create_patched_todo(self, chunk: DataFrame) -> Optional[StylerTodo]:\n        return self._todo_builder(chunk) \\\n            .with_style_func_kwargs({}) \\\n            .with_style_func(self._wrap_with_chunk_parent_provider(self._styling_func)) \\\n            .build()\n\n    def _styling_func(self,\n                      chunk_or_series_from_chunk: Union[DataFrame, Series],\n                      chunk_parent: Union[DataFrame, Series],\n                      ):\n        if chunk_or_series_from_chunk.empty:\n            return chunk_or_series_from_chunk\n\n        value = self.__get_or_compute_extrema(chunk_parent)\n\n        cond = chunk_or_series_from_chunk == value\n        cond = cond.where(pd.notna(cond), False)\n        return np.where(cond, self.__attribute, \"\")\n\n    def __get_or_compute_extrema(self, chunk_parent: Union[DataFrame, Series]):\n        cache_key = \"frame\"\n        if isinstance(chunk_parent, Series):\n            cache_key = chunk_parent.name\n\n        value = self.__computed_values_cache.get(cache_key, None)\n\n        if value is None:\n            value = getattr(chunk_parent, self._op)(skipna=True)\n            if isinstance(chunk_parent, DataFrame):  # min/max must be done twice to return scalar\n                value = getattr(value, self._op)(skipna=True)\n\n            self.__computed_values_cache[cache_key] = value\n\n        return value\n\n\nclass HighlightMaxPatcher(HighlightExtremaPatcher):\n    def __init__(self, org_frame: DataFrame, todo: StylerTodo):\n        super().__init__(org_frame, todo)\n        self._op: str = \"max\"\n\n\nclass HighlightMinPatcher(HighlightExtremaPatcher):\n    def __init__(self, org_frame: DataFrame, todo: StylerTodo):\n        super().__init__(org_frame, todo)\n        self._op: str = \"min\"\n",
                "map_patcher": "from typing import Optional\n\nfrom pandas import DataFrame\n\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\n\n\nclass MapPatcher(TodoPatcher):\n\n    def __init__(self, org_frame: DataFrame, todo: StylerTodo):\n        super().__init__(org_frame, todo)\n\n    def create_patched_todo(self, chunk: DataFrame) -> Optional[StylerTodo]:\n        return self._todo_builder(chunk).build()\n",
                "patched_styler": "from cms_rendner_sdfv.base.table_source import AbstractTableSource\nfrom cms_rendner_sdfv.base.types import Region, TableSourceKind\nfrom cms_rendner_sdfv.pandas.styler.patched_styler_context import PatchedStylerContext\nfrom cms_rendner_sdfv.pandas.styler.style_functions_validator import StyleFunctionsValidator\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\nfrom cms_rendner_sdfv.pandas.styler.types import ValidatedTableFrame\n\n\nclass PatchedStyler(AbstractTableSource):\n    def __init__(self, context: PatchedStylerContext, fingerprint: str):\n        super().__init__(TableSourceKind.PATCHED_STYLER, context, fingerprint)\n        self.__patchers_to_skip_in_validation: list[TodoPatcher] = []\n\n    def validate_and_compute_chunk_table_frame(self,\n                                               first_row: int,\n                                               first_col: int,\n                                               rows: int,\n                                               cols: int,\n                                               exclude_row_header: bool = False,\n                                               ) -> str:\n        region = Region(first_row, first_col, rows, cols)\n        validator = StyleFunctionsValidator(\n            self._context,\n            self.__patchers_to_skip_in_validation,\n        )\n        frame = ValidatedTableFrame(\n            frame=self._context.get_table_frame_generator().generate(\n                region=region,\n                exclude_row_header=exclude_row_header,\n            ),\n            problems=validator.validate(region),\n        )\n        self.__patchers_to_skip_in_validation.extend(validator.failed_patchers)\n        return self.serialize(frame)\n",
                "patched_styler_context": "from typing import Optional, Any, Union\n\nfrom pandas import Index, DataFrame\nfrom pandas.io.formats.style import Styler\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableFrameGenerator\nfrom cms_rendner_sdfv.base.types import Region, TableStructureColumn, TableStructureColumnInfo, \\\n    TableStructureLegend\nfrom cms_rendner_sdfv.pandas.shared.pandas_table_source_context import PandasTableSourceContext\nfrom cms_rendner_sdfv.pandas.shared.types import FilterCriteria\nfrom cms_rendner_sdfv.pandas.shared.value_formatter import ValueFormatter\nfrom cms_rendner_sdfv.pandas.shared.visible_frame import VisibleFrame\nfrom cms_rendner_sdfv.pandas.styler.apply_patcher import ApplyPatcher\nfrom cms_rendner_sdfv.pandas.styler.background_gradient_patcher import BackgroundGradientPatcher\nfrom cms_rendner_sdfv.pandas.styler.highlight_between_patcher import HighlightBetweenPatcher\nfrom cms_rendner_sdfv.pandas.styler.highlight_extrema_patcher import HighlightMaxPatcher, HighlightMinPatcher\nfrom cms_rendner_sdfv.pandas.styler.map_patcher import MapPatcher\nfrom cms_rendner_sdfv.pandas.styler.style_function_name_resolver import StyleFunctionNameResolver\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\n\n\nclass StyledChunk:\n    def __init__(self, styler: Styler, visible_frame: VisibleFrame, region: Region):\n        self.__styler = styler\n        self.__visible_frame = visible_frame\n        self.region = region\n\n    @property\n    def row_labels_hidden(self) -> bool:\n        return self.__styler.hide_index_names or all(self.__styler.hide_index_)\n\n    def cell_css_at(self, row: int, col: int) -> list[tuple[str, Union[str, float]]]:\n        return self.__styler.ctx[(row, col)]\n\n    def row_labels_at(self, row: int) -> list[Any]:\n        labels = self.__visible_frame.row_labels_at(self.region.first_row + row)\n        org_row = self.__to_source_frame_cell_coordinates(row, 0)[0]\n        return [\n            self.__styler._display_funcs_index[(org_row, lvl)](lbl)\n            for lvl, lbl in enumerate(labels)\n            if not self.__styler.hide_index_[lvl]\n        ]\n\n    def cell_value_at(self, row: int, col: int) -> str:\n        v = self.__visible_frame.cell_value_at(\n            self.region.first_row + row,\n            self.region.first_col + col,\n        )\n        return self.__styler._display_funcs[self.__to_source_frame_cell_coordinates(row, col)](v)\n\n    def __to_source_frame_cell_coordinates(self, row: int, col: int):\n        return self.__visible_frame.to_source_frame_cell_coordinates(\n            self.region.first_row + row,\n            self.region.first_col + col,\n        )\n\n\nclass StyledChunkComputer:\n    def __init__(self,\n                 visible_frame: VisibleFrame,\n                 org_styler: Styler,\n                 todo_patcher_list: list[TodoPatcher],\n                 ):\n        self.__visible_frame: VisibleFrame = visible_frame\n        self.__org_styler: Styler = org_styler\n        self.__todo_patcher_list: list[TodoPatcher] = todo_patcher_list\n\n    def compute(self, region: Region) -> StyledChunk:\n        region = self.__visible_frame.region.get_bounded_region(region)\n        chunk_df = self.__visible_frame.to_frame(region)\n\n        chunk_styler = chunk_df.style\n\n        chunk_styler._todo = [\n            p.create_patched_todo(chunk_df).to_tuple()\n            for p in self.__todo_patcher_list\n        ]\n        chunk_styler._compute()\n\n        chunk_styler._display_funcs = self.__org_styler._display_funcs\n        chunk_styler._display_funcs_index = self.__org_styler._display_funcs_index\n        chunk_styler._display_funcs_columns = self.__org_styler._display_funcs_columns\n\n        chunk_styler.hide_index_ = self.__org_styler.hide_index_\n        chunk_styler.hide_index_names = self.__org_styler.hide_index_names\n\n        chunk_styler.hide_columns_ = self.__org_styler.hide_columns_\n        chunk_styler.hide_column_names = self.__org_styler.hide_column_names\n\n        return StyledChunk(\n            styler=chunk_styler,\n            visible_frame=self.__visible_frame,\n            region=region,\n        )\n\n\nclass PatchedStylerContext(PandasTableSourceContext):\n    def __init__(self, styler: Styler, filter_criteria: Optional[FilterCriteria] = None):\n        self.__has_hidden_rows: bool = len(styler.hidden_rows) > 0\n        self.__has_hidden_columns: bool = len(styler.hidden_columns) > 0\n        self.__styler: Styler = styler\n        self.__todo_patcher_list: list[TodoPatcher] = self.__create_patchers(styler)\n        super().__init__(styler.data, filter_criteria)\n\n    def unlink(self):\n        super().unlink()\n        self.__styler = None\n        [x.unlink() for x in self.__todo_patcher_list]\n        self.__todo_patcher_list = None\n\n    def create_styled_chunk_computer_for_validation(self, chunk: DataFrame, patcher: TodoPatcher) -> 'StyledChunkComputer':\n        return StyledChunkComputer(\n            visible_frame=VisibleFrame(chunk),\n            org_styler=self.__styler,\n            todo_patcher_list=[patcher.patcher_for_style_func_validation(chunk)]\n        )\n\n    def get_table_frame_generator(self) -> AbstractTableFrameGenerator:\n        from cms_rendner_sdfv.pandas.styler.table_frame_generator import TableFrameGenerator\n        return TableFrameGenerator(self)\n\n    def get_todo_patcher_list(self) -> list[TodoPatcher]:\n        return self.__todo_patcher_list\n\n    def compute_styled_chunk(self, region: Region) -> StyledChunk:\n        return StyledChunkComputer(\n            visible_frame=self.visible_frame,\n            org_styler=self.__styler,\n            todo_patcher_list=self.__todo_patcher_list,\n        ).compute(region)\n\n    def _get_frame_column_info(self) -> TableStructureColumnInfo:\n        formatter = ValueFormatter()\n        frame = self.__styler.data\n\n        ts_columns = []\n        dtypes = frame.dtypes\n        nlevels = frame.columns.nlevels\n        for col in self.visible_frame.get_column_indices():\n            col_label = frame.columns[col]\n            labels = [col_label] if nlevels == 1 else col_label\n            labels = [\n                formatter.format_column(\n                    self.__styler._display_funcs_columns[(lvl, col)](labels[lvl])\n                )\n                for lvl in range(nlevels)\n                if not self.__styler.hide_columns_[lvl]\n            ]\n            ts_columns.append(TableStructureColumn(dtype=str(dtypes[col_label]), labels=labels, id=col))\n\n        index_legend = [\n            formatter.format_index(lbl)\n            for lvl, lbl in enumerate(self.visible_frame.index_names)\n            if lbl is not None and not self.__styler.hide_index_[lvl]\n        ]\n\n        column_legend = [\n            formatter.format_index(lbl)\n            for lvl, lbl in enumerate(self.visible_frame.column_names)\n            if lbl is not None and not self.__styler.hide_columns_[lvl]\n        ]\n\n        legend = TableStructureLegend(\n            index=index_legend,\n            column=column_legend,\n        ) if index_legend or column_legend else None\n\n        return TableStructureColumnInfo(columns=ts_columns, legend=legend)\n\n    def _get_initial_visible_frame_indexes(self):\n        index, columns = super()._get_initial_visible_frame_indexes()\n\n        if self.__has_hidden_columns:\n            columns = columns.delete(Index(self.__styler.hidden_columns))\n        if self.__has_hidden_rows:\n            index = index.delete(Index(self.__styler.hidden_rows))\n\n        return index, columns\n\n    def __create_patchers(self, styler: Styler) -> list[TodoPatcher]:\n        result: list[TodoPatcher] = []\n\n        org_frame = styler.data\n        for idx, t in enumerate(styler._todo):\n            st = StylerTodo.from_tuple(idx, t)\n            if st.is_pandas_style_func():\n                patcher = self.__get_patcher_for_supported_pandas_style_functions(org_frame, st)\n            else:\n                patcher = MapPatcher(org_frame, st) if st.is_map() else ApplyPatcher(org_frame, st)\n\n            if patcher is not None:\n                result.append(patcher)\n\n        return result\n\n    @staticmethod\n    def __get_patcher_for_supported_pandas_style_functions(org_frame: DataFrame, todo: StylerTodo) -> Optional[TodoPatcher]:\n        qname = StyleFunctionNameResolver.get_style_func_qname(todo)\n        if StyleFunctionNameResolver.is_pandas_text_gradient(qname, todo):\n            return BackgroundGradientPatcher(org_frame, todo)\n        elif StyleFunctionNameResolver.is_pandas_background_gradient(qname):\n            return BackgroundGradientPatcher(org_frame, todo)\n        elif StyleFunctionNameResolver.is_pandas_highlight_max(qname, todo):\n            return HighlightMaxPatcher(org_frame, todo)\n        elif StyleFunctionNameResolver.is_pandas_highlight_min(qname, todo):\n            return HighlightMinPatcher(org_frame, todo)\n        elif StyleFunctionNameResolver.is_pandas_highlight_null(qname):\n            return ApplyPatcher(org_frame, todo)\n        elif StyleFunctionNameResolver.is_pandas_highlight_between(qname):\n            return HighlightBetweenPatcher(org_frame, todo)\n        elif StyleFunctionNameResolver.is_pandas_set_properties(qname):\n            return MapPatcher(org_frame, todo)\n        return None\n",
                "style_func_with_chunk_parent": "from typing import Callable, Optional, Union\n\nfrom pandas import DataFrame, Series\nfrom pandas._typing import Axis\n\n\nclass StyleFuncWithChunkParent:\n    def __init__(self, delegate: Callable, axis: Optional[Axis], subset_frame: DataFrame):\n        self.__delegate = delegate\n        self.__axis = axis\n        self.__subset_frame = subset_frame\n\n    def __call__(self, chunk_or_series_from_chunk: Union[DataFrame, Series], *args, **kwargs):\n        if chunk_or_series_from_chunk.empty:\n            return chunk_or_series_from_chunk\n\n        kwargs['chunk_parent'] = self._get_parent(chunk_or_series_from_chunk)\n        return self.__delegate(chunk_or_series_from_chunk, *args, **kwargs)\n\n    def _get_parent(self, chunk_or_series_from_chunk: Union[DataFrame, Series]):\n        if self.__axis == 0 or self.__axis == \"index\":\n            return self.__subset_frame[chunk_or_series_from_chunk.name]\n        elif self.__axis == 1 or self.__axis == \"columns\":\n            return self.__subset_frame.loc[chunk_or_series_from_chunk.name]\n        else:\n            return self.__subset_frame\n",
                "style_function_name_resolver": "from functools import partial\n\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\n\n\nclass StyleFunctionNameResolver:\n\n    @staticmethod\n    def get_style_func_qname(todo: StylerTodo) -> str:\n        func = todo.apply_args.style_func\n        if isinstance(func, partial):\n            func = func.func\n        return getattr(func, '__qualname__', '')\n\n    @staticmethod\n    def resolve_style_func_name(todo: StylerTodo) -> str:\n        qname = StyleFunctionNameResolver.get_style_func_qname(todo)\n        if todo.is_pandas_style_func():\n            if StyleFunctionNameResolver.is_pandas_text_gradient(qname, todo):\n                return \"text_gradient\"\n            elif StyleFunctionNameResolver.is_pandas_background_gradient(qname):\n                return \"background_gradient\"\n            elif StyleFunctionNameResolver.is_pandas_highlight_max(qname, todo):\n                return \"highlight_max\"\n            elif StyleFunctionNameResolver.is_pandas_highlight_min(qname, todo):\n                return \"highlight_min\"\n            elif StyleFunctionNameResolver.is_pandas_highlight_null(qname):\n                return \"highlight_null\"\n            elif StyleFunctionNameResolver.is_pandas_highlight_between(qname):\n                return \"highlight_between or highlight_quantile\"\n            elif StyleFunctionNameResolver.is_pandas_set_properties(qname):\n                return \"set_properties\"\n            else:\n                return qname.rpartition('.')[2]\n        else:\n            return qname.rpartition('.')[2]\n\n    @staticmethod\n    def is_pandas_background_gradient(style_func_qname: str) -> bool:\n        return style_func_qname == '_background_gradient'\n\n    @staticmethod\n    def is_pandas_text_gradient(style_func_qname: str, todo: StylerTodo) -> bool:\n        return style_func_qname == '_background_gradient' \\\n               and todo.style_func_kwargs.get(\"text_only\", False)\n\n    @staticmethod\n    def is_pandas_highlight_max(style_func_qname: str, todo: StylerTodo) -> bool:\n        return style_func_qname == '_highlight_value' \\\n               and isinstance(todo.apply_args.style_func, partial) \\\n               and todo.apply_args.style_func.keywords.get('op', '') == 'max'\n\n    @staticmethod\n    def is_pandas_highlight_min(style_func_qname: str, todo: StylerTodo) -> bool:\n        return style_func_qname == '_highlight_value' \\\n               and isinstance(todo.apply_args.style_func, partial) \\\n               and todo.apply_args.style_func.keywords.get('op', '') == 'min'\n\n    @staticmethod\n    def is_pandas_highlight_null(style_func_qname: str) -> bool:\n        return style_func_qname.startswith('Styler.highlight_null')\n\n    @staticmethod\n    def is_pandas_highlight_between(style_func_qname: str) -> bool:\n        return style_func_qname == '_highlight_between'\n\n    @staticmethod\n    def is_pandas_set_properties(style_func_qname: str) -> bool:\n        return style_func_qname.startswith('Styler.set_properties')\n",
                "style_functions_validator": "from typing import Optional\n\nfrom cms_rendner_sdfv.base.types import Region\nfrom cms_rendner_sdfv.pandas.styler.patched_styler_context import PatchedStylerContext, StyledChunk, StyledChunkComputer\nfrom cms_rendner_sdfv.pandas.styler.style_function_name_resolver import StyleFunctionNameResolver\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\nfrom cms_rendner_sdfv.pandas.styler.types import StyleFunctionValidationProblem, StyleFunctionInfo\n\n\nclass StyleFunctionsValidator:\n    def __init__(self, ctx: PatchedStylerContext, ignore_list: list[TodoPatcher] = None):\n        self.__ctx: PatchedStylerContext = ctx\n        self.__ignore_list = ignore_list or []\n        self.failed_patchers: list[TodoPatcher] = []\n\n    def validate(self, region: Optional[Region] = None) -> list[StyleFunctionValidationProblem]:\n        region = self.__ctx.visible_frame.region.get_bounded_region(region)\n\n        if region.is_empty():\n            return []\n\n        patchers_to_validate = [\n            p for p in self.__ctx.get_todo_patcher_list()\n            if not p.todo.is_map() and p not in self.__ignore_list\n        ]\n\n        if not patchers_to_validate:\n            return []\n\n        chunk_df = self.__ctx.visible_frame.to_frame(region)\n\n        validation_result = []\n        for patcher in patchers_to_validate:\n            is_equal = False\n\n            styled_chunk_computer = self.__ctx.create_styled_chunk_computer_for_validation(chunk_df, patcher)\n\n            try:\n                chunk = styled_chunk_computer.compute(region)\n\n                if patcher.todo.apply_args.axis_is_index():\n                    is_equal = self.__validate_horizontal_splitted(region, styled_chunk_computer, chunk)\n                elif patcher.todo.apply_args.axis_is_columns():\n                    is_equal = self.__validate_vertical_splitted(region, styled_chunk_computer, chunk)\n                else:\n                    is_equal = self.__validate_horizontal_splitted(region, styled_chunk_computer, chunk)\n                    if is_equal:\n                        is_equal = self.__validate_vertical_splitted(region, styled_chunk_computer, chunk)\n\n                if not is_equal:\n                    self.failed_patchers.append(patcher)\n                    validation_result.append(\n                        StyleFunctionValidationProblem(\n                            reason=\"NOT_EQUAL\",\n                            message=\"\",\n                            func_info=self.__create_style_func_info(patcher),\n                        )\n                    )\n\n            except Exception as e:\n                self.failed_patchers.append(patcher)\n                validation_result.append(\n                    StyleFunctionValidationProblem(\n                        reason=\"EXCEPTION\",\n                        message=str(e),\n                        func_info=self.__create_style_func_info(patcher),\n                    )\n                )\n\n        return validation_result\n\n    def __validate_horizontal_splitted(self, region: Region, computer: StyledChunkComputer, chunk: StyledChunk) -> bool:\n        for sub_region in region.iterate_local_chunkwise(self.__half_or_one(region.rows), region.cols):\n            sub_chunk = computer.compute(sub_region.translate(region.first_row, region.first_col))\n            if not self.__has_same_cell_styling(chunk, sub_chunk, sub_region):\n                return False\n        return True\n\n    def __validate_vertical_splitted(self, region: Region, computer: StyledChunkComputer, chunk: StyledChunk) -> bool:\n        for sub_region in region.iterate_local_chunkwise(region.rows, self.__half_or_one(region.cols)):\n            sub_chunk = computer.compute(sub_region.translate(region.first_row, region.first_col))\n            if not self.__has_same_cell_styling(chunk, sub_chunk, sub_region):\n                return False\n        return True\n\n    @staticmethod\n    def __create_style_func_info(patcher: TodoPatcher) -> StyleFunctionInfo:\n        todo = patcher.todo\n        return StyleFunctionInfo(\n            index=todo.index_in_org_styler,\n            qname=StyleFunctionNameResolver.get_style_func_qname(todo),\n            resolved_name=StyleFunctionNameResolver.resolve_style_func_name(todo),\n            axis='' if todo.is_map() else str(todo.apply_args.axis),\n            is_pandas_builtin=todo.is_pandas_style_func(),\n            is_supported=patcher.todo.is_pandas_style_func(),\n            is_apply=not todo.is_map(),\n            is_chunk_parent_requested=todo.should_provide_chunk_parent(),\n        )\n\n    @staticmethod\n    def __has_same_cell_styling(chunk: StyledChunk, sub_chunk: StyledChunk, sub_region: Region) -> bool:\n        for r in range(sub_region.rows):\n            for c in range(sub_region.cols):\n                expected = chunk.cell_css_at(sub_region.first_row + r, sub_region.first_col + c)\n                actual = sub_chunk.cell_css_at(r, c)\n                if expected != actual:\n                    return False\n        return True\n\n    @staticmethod\n    def __half_or_one(number: int):\n        return -(number // -2)\n",
                "styler_todo": "import inspect\nfrom dataclasses import dataclass\nfrom functools import partial\nfrom typing import Callable, Optional, Tuple, Union\n\nfrom pandas._typing import Axis\nfrom pandas.io.formats.style_render import Subset\n\n\n@dataclass(frozen=True)\nclass MapArgs:\n    style_func: Callable\n    subset: Optional[Subset]\n\n    @classmethod\n    def from_tuple(cls, args: Tuple[Callable, Optional[Subset]]):\n        return cls(args[0], args[1])\n\n    @staticmethod\n    def copy_with(style_func: Callable, subset: Optional[Subset]):\n        return MapArgs(style_func, subset)\n\n    def to_tuple(self) -> Tuple[Callable, Optional[Subset]]:\n        return self.style_func, self.subset\n\n\n@dataclass(frozen=True)\nclass ApplyArgs:\n    style_func: Callable\n    axis: Optional[Axis]\n    subset: Optional[Subset]\n\n    @classmethod\n    def from_tuple(cls, args: Tuple[Callable, Optional[Axis], Optional[Subset]]):\n        return cls(args[0], args[1], args[2])\n\n    def copy_with(self, style_func: Callable, subset: Optional[Subset]):\n        return ApplyArgs(style_func, self.axis, subset)\n\n    def to_tuple(self) -> Tuple[Callable, Optional[Axis], Optional[Subset]]:\n        return self.style_func, self.axis, self.subset\n\n    def axis_is_index(self) -> bool:\n        return self.axis == 'index' or self.axis == 0\n\n    def axis_is_columns(self) -> bool:\n        return self.axis == 'columns' or self.axis == 1\n\n\n@dataclass(frozen=True)\nclass StylerTodo:\n    index_in_org_styler: int\n    apply_func: Callable\n    apply_args: Union[ApplyArgs, MapArgs]\n    style_func_kwargs: dict\n\n    @classmethod\n    def from_tuple(cls, index_in_org_styler: int, todo: Tuple[Callable, tuple, dict]):\n        return cls(index_in_org_styler, todo[0], cls._to_apply_args(todo), todo[2])\n\n    @staticmethod\n    def _to_apply_args(todo: Tuple[Callable, tuple, dict]):\n        if StylerTodo.is_map_tuple(todo):\n            return MapArgs.from_tuple(todo[1])\n        else:\n            return ApplyArgs.from_tuple(todo[1])\n\n    @classmethod\n    def is_map_tuple(cls, todo: Tuple[Callable, tuple, dict]):\n        return cls.__is_map_func(todo[0])\n\n    def is_map(self) -> bool:\n        return self.__is_map_func(self.apply_func)\n\n    @staticmethod\n    def __is_map_func(func: Callable) -> bool:\n        return getattr(func, '__qualname__', '').startswith('Styler.map')\n\n    def is_pandas_style_func(self) -> bool:\n        func = self.apply_args.style_func\n        if isinstance(func, partial):\n            func = func.func\n        inspect_result = inspect.getmodule(func)\n        return False if inspect_result is None else inspect.getmodule(func).__name__ == 'pandas.io.formats.style'\n\n    def should_provide_chunk_parent(self):\n        sig = inspect.signature(self.apply_args.style_func)\n        for param in sig.parameters.values():\n            if param.name == \"chunk_parent\" or param.kind == inspect.Parameter.VAR_KEYWORD:\n                return True\n        return False\n\n    def to_tuple(self) -> Tuple[Callable, tuple, dict]:\n        return self.apply_func, self.apply_args.to_tuple(), self.style_func_kwargs\n\n\nclass StylerTodoBuilder:\n\n    def __init__(self, source: StylerTodo):\n        self.source: StylerTodo = source\n        self.values: dict = {}\n\n    def with_subset(self, subset: Optional[Subset]):\n        self.values[\"subset\"] = subset\n        return self\n\n    def with_style_func(self, style_func: Callable):\n        self.values[\"style_func\"] = style_func\n        return self\n\n    def with_style_func_kwargs(self, style_func_kwargs: dict):\n        self.values[\"style_func_kwargs\"] = style_func_kwargs\n        return self\n\n    def build(self) -> StylerTodo:\n        return StylerTodo(\n            self.source.index_in_org_styler,\n            self.source.apply_func,\n            self.source.apply_args.copy_with(\n                style_func=self.values.get(\"style_func\", self.source.apply_args.style_func),\n                subset=self.values.get(\"subset\", self.source.apply_args.subset),\n            ),\n            self.values.get(\"style_func_kwargs\", self.source.style_func_kwargs),\n        )\n",
                "table_frame_generator": "from cms_rendner_sdfv.base.table_source import AbstractTableFrameGenerator\nfrom cms_rendner_sdfv.base.types import Region, TableFrame, TableFrameCell\nfrom cms_rendner_sdfv.pandas.shared.value_formatter import ValueFormatter\nfrom cms_rendner_sdfv.pandas.styler.patched_styler_context import PatchedStylerContext\n\n\nclass TableFrameGenerator(AbstractTableFrameGenerator):\n    def __init__(self, styler_context: PatchedStylerContext):\n        super().__init__(styler_context.visible_frame)\n        self.__styler_context: PatchedStylerContext = styler_context\n\n    def generate(self,\n                 region: Region = None,\n                 exclude_row_header: bool = False,\n                 ) -> TableFrame:\n        formatter = ValueFormatter()\n        styled_chunk = self.__styler_context.compute_styled_chunk(region)\n\n        if styled_chunk.row_labels_hidden:\n            exclude_row_header = True\n\n        col_range = range(styled_chunk.region.cols)\n        cells: list[list[TableFrameCell]] = []\n        index_labels: list[list[str]] = []\n        for r in range(styled_chunk.region.rows):\n            if not exclude_row_header:\n                index_labels.append([formatter.format_index(lbl) for lbl in styled_chunk.row_labels_at(r)])\n\n            row_cells = []\n            cells.append(row_cells)\n            for c in col_range:\n                css = styled_chunk.cell_css_at(r, c)\n                row_cells.append(\n                    TableFrameCell(\n                        value=formatter.format_cell(styled_chunk.cell_value_at(r, c)),\n                        css=None if not css or css is None else {k: str(v) for k, v in css},\n                    ),\n                )\n\n        return TableFrame(index_labels=index_labels, cells=cells)\n",
                "table_source_factory": "from typing import Any, Union\n\nfrom pandas import DataFrame\nfrom pandas.io.formats.style import Styler\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableSource, AbstractTableSourceFactory\nfrom cms_rendner_sdfv.base.types import CreateTableSourceConfig, CreateTableSourceFailure, CreateTableSourceErrorKind\nfrom cms_rendner_sdfv.pandas.shared.create_fingerprint import create_fingerprint\nfrom cms_rendner_sdfv.pandas.shared.types import FilterCriteria\nfrom cms_rendner_sdfv.pandas.styler.patched_styler import PatchedStyler\nfrom cms_rendner_sdfv.pandas.styler.patched_styler_context import PatchedStylerContext\n\n\nclass TableSourceFactory(AbstractTableSourceFactory):\n\n    def _create_internal(self,\n                         data_source: Any,\n                         config: CreateTableSourceConfig,\n                         caller_globals: dict,\n                         ) -> Union[AbstractTableSource, CreateTableSourceFailure]:\n\n        if not isinstance(data_source, Styler):\n            return CreateTableSourceFailure(\n                error_kind=CreateTableSourceErrorKind.UNSUPPORTED_DATA_SOURCE_TYPE,\n                info=str(type(data_source)),\n            )\n\n        ds_frame = data_source.data\n        ds_frame_style = data_source\n\n        pre_fingerprint = config.previous_fingerprint\n        cur_fingerprint = create_fingerprint(ds_frame, data_source)\n        if pre_fingerprint is not None and pre_fingerprint != cur_fingerprint:\n            return CreateTableSourceFailure(\n                error_kind=CreateTableSourceErrorKind.INVALID_FINGERPRINT,\n                info=cur_fingerprint,\n            )\n\n        filter_frame = None\n        filter_eval_expr = config.filter_eval_expr\n        if filter_eval_expr is not None and filter_eval_expr != \"\":\n            try:\n                if config.filter_eval_expr_provide_frame:\n                    caller_globals[\"_df\"] = ds_frame\n                filter_frame = eval(filter_eval_expr, caller_globals)\n            except Exception as e:\n                return CreateTableSourceFailure(\n                    error_kind=CreateTableSourceErrorKind.FILTER_FRAME_EVAL_FAILED,\n                    info=repr(e),\n                )\n\n            if not isinstance(filter_frame, DataFrame):\n                return CreateTableSourceFailure(\n                    error_kind=CreateTableSourceErrorKind.FILTER_FRAME_OF_WRONG_TYPE,\n                    info=str(type(filter_frame)),\n                )\n\n        return PatchedStyler(\n            PatchedStylerContext(ds_frame_style, FilterCriteria.from_frame(filter_frame)),\n            fingerprint=cur_fingerprint,\n        )\n",
                "todo_patcher": "from abc import ABC, abstractmethod\nfrom typing import Optional, Callable\n\nfrom pandas import DataFrame\nfrom pandas.io.formats.style_render import Subset, non_reducing_slice\n\nfrom cms_rendner_sdfv.pandas.styler.style_func_with_chunk_parent import StyleFuncWithChunkParent\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo, StylerTodoBuilder\n\n\nclass TodoPatcher(ABC):\n\n    def __init__(self, org_frame: DataFrame, todo: StylerTodo):\n        self.__org_subset_frame: DataFrame = self.__compute_org_subset_frame(org_frame, todo.apply_args.subset)\n        self.todo: StylerTodo = StylerTodoBuilder(todo).with_subset(None).build()\n\n    def unlink(self):\n        self.__org_subset_frame = None\n\n    def patcher_for_style_func_validation(self, chunk: DataFrame) -> 'TodoPatcher':\n        subset = self.__calculate_chunk_subset(chunk)\n        return self.__class__(self.__org_subset_frame.loc[subset], self.todo)\n\n    @abstractmethod\n    def create_patched_todo(self, chunk: DataFrame) -> Optional[StylerTodo]:\n        pass\n\n    def _todo_builder(self, chunk: DataFrame) -> StylerTodoBuilder:\n        return StylerTodoBuilder(self.todo).with_subset(self.__calculate_chunk_subset(chunk))\n\n    def _wrap_with_chunk_parent_provider(self, style_func: Callable):\n        return StyleFuncWithChunkParent(style_func, self.todo.apply_args.axis, self.__org_subset_frame)\n\n    def __calculate_chunk_subset(self, chunk: DataFrame) -> Subset:\n        index_intersection = chunk.index.intersection(self.__org_subset_frame.index)\n        column_intersection = chunk.columns.intersection(self.__org_subset_frame.columns)\n        return index_intersection, column_intersection\n\n    @staticmethod\n    def __compute_org_subset_frame(org_frame: DataFrame, subset: Optional[Subset]) -> DataFrame:\n        subset_frame = org_frame\n\n        if subset is not None:\n\n            subset = slice(None) if subset is None else subset\n            subset = non_reducing_slice(subset)\n            subset_frame = org_frame.loc[subset]\n\n            if org_frame.shape == subset_frame.shape:\n                subset_frame = org_frame\n\n        return subset_frame\n",
                "types": "from dataclasses import dataclass\nfrom typing import Optional\n\nfrom cms_rendner_sdfv.base.types import TableFrame\n\n\n@dataclass(frozen=True)\nclass StyleFunctionInfo:\n    index: int\n    qname: str\n    resolved_name: str\n    axis: str\n    is_chunk_parent_requested: bool\n    is_apply: bool\n    is_pandas_builtin: bool\n    is_supported: bool\n\n\n@dataclass(frozen=True)\nclass StyleFunctionValidationProblem:\n    reason: str\n    message: str\n    func_info: StyleFunctionInfo\n\n\n@dataclass(frozen=True)\nclass ValidatedTableFrame:\n    frame: Optional[TableFrame] = None\n    problems: Optional[list[StyleFunctionValidationProblem]] = None\n"
            }
        }
    }
}