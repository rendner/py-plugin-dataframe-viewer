#  Copyright 2021-2024 cms.rendner (Daniel Schmidt)
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import inspect
import os
import traceback
import gc
from typing import Set, Any, List, Union


class DebuggerInternals:

    __id_counter = 0
    __traces = []
    __trace_step = 0

    @staticmethod
    def eval(expression: str):
        callers_frame = inspect.currentframe().f_back
        DebuggerInternals.__trace_input("eval", expression, callers_frame)

        try:
            result = eval(expression, callers_frame.f_globals, callers_frame.f_locals)
        except BaseException as exc:
            DebuggerInternals.__print_exception(exc)
            return

        DebuggerInternals.__bind_and_print_result(result, expression, callers_frame)

    @staticmethod
    def exec(value: str):
        callers_frame = inspect.currentframe().f_back
        DebuggerInternals.__trace_input("exec", value, callers_frame)

        try:
            exec(value, callers_frame.f_globals, callers_frame.f_locals)
        except BaseException as exc:
            DebuggerInternals.__print_exception(exc)

    @staticmethod
    def find_referrer_chains(obj_name: str, max_levels: int = 6):
        callers_frame = inspect.currentframe().f_back
        DebuggerInternals.__trace_input("find_referrer_chains", "", callers_frame)

        try:
            # resolve to obj inside try/catch to handle possible "NameError: name '...' is not defined"
            obj = eval(obj_name, callers_frame.f_globals, callers_frame.f_locals)
            if not gc.is_tracked(obj):
                return []

            # run gc to clear garbage
            gc.collect()
            # collect ids of all tracked objects
            # (required to ignore all references generated by the code in this method)
            object_ids = set(id(i) for i in gc.get_objects())

            chains = set()

            class ChainInfo:
                def __init__(self, chain: List[str], ids_seen: Set[int], level: int):
                    self.chain: List[str] = chain.copy()
                    self.ids_seen: Set[int] = ids_seen.copy()
                    self.level: int = level

                def is_cycle(self, o: Any):
                    return id(o) in self.ids_seen

                def next(self, o: Any):
                    n = ChainInfo(self.chain,  self.ids_seen, self.level + 1)
                    n.ids_seen.add(id(o))
                    if inspect.ismodule(o):
                        n.chain.append(inspect.getmodule(o).__name__)
                    else:
                        n.chain.append(str(type(o)))
                    return n

                def chain_to_str(self):
                    # "chain" contains the referrers in reversed order
                    return ", ".join(reversed(self.chain))

            def traverse_chain(o, info: ChainInfo):
                if info.level >= max_levels or inspect.ismodule(o):
                    chains.add(info.chain_to_str())
                    return

                for ref in [x for x in gc.get_referrers(o) if id(x) in object_ids]:
                    if inspect.isbuiltin(ref) or inspect.isframe(ref) or inspect.isfunction(ref):
                        continue
                    if info.is_cycle(ref):
                        chains.add(info.next(ref).chain_to_str())
                        continue
                    else:
                        traverse_chain(ref, info.next(ref))

            traverse_chain(obj, ChainInfo([], set(), -1).next(obj))
            DebuggerInternals.__bind_and_print_result(list(chains), None, callers_frame)
        except BaseException as exc:
            DebuggerInternals.__print_exception(exc)

    @staticmethod
    def __full_type(o) -> str:
        klass = getattr(o, '__class__', '')
        module = getattr(klass, '__module__', '')
        qname = getattr(klass, '__qualname__', '')
        return f'{module}:{qname}'

    @staticmethod
    def __print_exception(exc):
        DebuggerInternals.__trace_output(exc)
        print(traceback.format_exc())
        print(f'@_@EXC@_@{DebuggerInternals.__full_type(exc)} {exc}@_@EXC@_@')

    @staticmethod
    def __bind_and_print_result(result: Any, expression: Union[str, None], callers_frame):
        DebuggerInternals.__trace_output(result)

        if expression in callers_frame.f_locals:
            # expression is an existing identifier
            ref_key = expression
        else:
            # store created object and make it accessible
            ref_key = f'__dbg_ref_id_{DebuggerInternals.__id_counter}'
            DebuggerInternals.__id_counter += 1
            callers_frame.f_locals[ref_key] = result

        print(f'@_@RESULT@_@{DebuggerInternals.__full_type(result)} {ref_key} {result}@_@RESULT@_@')

    @staticmethod
    def __trace_input(cmd: str, value: str, callers_frame):
        DebuggerInternals.__trace_step += 1
        if DebuggerInternals.__trace_step > 1:
            DebuggerInternals.__traces.append("\n")

        if callers_frame:
            DebuggerInternals.__traces.append(f"locals: {str(callers_frame.f_locals)}")
        else:
            DebuggerInternals.__traces.append(f"locals: ?")

        DebuggerInternals.__traces.append(f"in[{DebuggerInternals.__trace_step}][{cmd}]: {value}")

    @staticmethod
    def __trace_output(value: str):
        DebuggerInternals.__traces.append(f"out[{DebuggerInternals.__trace_step}]: {value}")

    @staticmethod
    def dump_traces_on_exit(file_path: str):
        import signal
        import atexit
        from pathlib import Path

        def write_to_file():
            try:
                # remove restrictions - no need to restore old mask afterward (is executed on exit)
                os.umask(0)

                file = Path(f"{os.environ['TRANSFER_OUT_DIR']}/{file_path}")
                file.parent.mkdir(parents=True, exist_ok=True)
                file.write_text("\n".join(DebuggerInternals.__traces))

            except BaseException as exc:
                print(exc)

        atexit.register(write_to_file)
        signal.signal(signal.SIGINT, write_to_file)
        signal.signal(signal.SIGTERM, write_to_file)
