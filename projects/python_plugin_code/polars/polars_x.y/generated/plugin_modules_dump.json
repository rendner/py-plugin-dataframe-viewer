{
    "cms_rendner_sdfv": {
        "polars": {
            "chunk_data_generator": "from dataclasses import dataclass\n\nimport polars as pl\n\nfrom cms_rendner_sdfv.base.table_source import ChunkDataGenerator as BaseChunkDataGenerator\nfrom cms_rendner_sdfv.base.types import Region, ChunkDataResponse, Cell\nfrom cms_rendner_sdfv.polars.meta_computer import MetaComputer\nfrom cms_rendner_sdfv.polars.visible_frame import VisibleFrame\n\n\n@dataclass(frozen=True)\nclass FormatOptions:\n    str_len: int\n    cell_list_len: int\n\n\nclass ChunkDataGenerator(BaseChunkDataGenerator):\n    def __init__(self,\n                 visible_frame: VisibleFrame,\n                 format_options: FormatOptions,\n                 meta_computer: MetaComputer,\n                 ):\n        super().__init__(visible_frame.region)\n        self.__visible_frame = visible_frame\n        self.__format_options = format_options\n        self.__meta_computer = meta_computer\n\n    def _compute_cells(self, region: Region, response: ChunkDataResponse):\n        with pl.Config() as cfg:\n            cfg.set_fmt_str_lengths(self.__format_options.str_len)\n            cfg.set_fmt_table_cell_list_len(self.__format_options.cell_list_len)\n\n            response.cells = []\n            is_first_cols_iteration = True\n            for c in range(region.cols):\n                series = self.__visible_frame.series_at(region.first_col + c)\n                for r, row_in_series in enumerate(self.__visible_frame.row_idx_iter(region)):\n                    raw_v = series.item(row_in_series)\n                    v = series._s.get_fmt(row_in_series, self.__format_options.str_len)\n                    if v[0] == '\"':\n                        v = v[1:]\n                    if v[-1] == '\"':\n                        v = v[0:-1]\n\n                    org_col_idx = self.__visible_frame.get_col_index_in_source_frame(region.first_col + c)\n                    cell = Cell(\n                        value=v,\n                        meta=self.__meta_computer.compute_cell_meta(org_col_idx, raw_v),\n                    )\n\n                    if is_first_cols_iteration:\n                        response.cells.append([cell])\n                    else:\n                        response.cells[r].append(cell)\n\n                is_first_cols_iteration = False\n",
            "create_fingerprint": "from hashlib import blake2b\nfrom typing import Any\n\nfrom polars import DataFrame\n\n\ndef create_fingerprint(frame: DataFrame, org_data_source: Any = None) -> str:\n    fingerprint_input = [\n        id(org_data_source if org_data_source is not None else frame),\n        frame.shape,\n        frame.columns[:60],\n        frame.dtypes[:60]\n    ]\n    return blake2b('-'.join(str(x) for x in fingerprint_input).encode(), digest_size=16).hexdigest()\n",
            "frame_context": "import os\nfrom typing import List, Optional, Union, Any, Dict\n\nfrom polars import DataFrame, DataType, datatypes\n\nfrom cms_rendner_sdfv.base.constants import CELL_MAX_STR_LEN, CELL_MAX_LIST_LEN\nfrom cms_rendner_sdfv.base.helpers import fq_type\nfrom cms_rendner_sdfv.base.table_source import AbstractTableSourceContext\nfrom cms_rendner_sdfv.base.types import SortCriteria, TableStructure, TableStructureColumnInfo, TableStructureColumn, \\\n    CompletionVariant, NestedCompletionVariant, TextAlign\nfrom cms_rendner_sdfv.polars.chunk_data_generator import ChunkDataGenerator, FormatOptions\nfrom cms_rendner_sdfv.polars.meta_computer import MetaComputer\nfrom cms_rendner_sdfv.polars.visible_frame import VisibleFrame\n\n\ndef _compute_format_options() -> FormatOptions:\n    def get_min_value(key: str, fallback: int) -> int:\n        try:\n            return min(fallback, int(os.environ.get(key, str(fallback))))\n        except:\n            return fallback\n\n    return FormatOptions(\n        str_len=get_min_value(\"POLARS_FMT_STR_LEN\", CELL_MAX_STR_LEN),\n        cell_list_len=get_min_value(\"POLARS_FMT_TABLE_CELL_LIST_LEN\", CELL_MAX_LIST_LEN)\n    )\n\n\nclass FrameContext(AbstractTableSourceContext):\n    def __init__(self, source_frame: DataFrame, filtered_frame: Union[DataFrame, None] = None):\n        self.__source_frame = source_frame\n        self.__filtered_frame = filtered_frame\n        self.__sort_criteria: SortCriteria = SortCriteria()\n        self.__visible_frame: VisibleFrame = self._recompute_visible_frame()\n        self.__format_options = _compute_format_options()\n        self.__meta_computer = MetaComputer(source_frame)\n\n    def unlink(self):\n        self.__source_frame = None\n        self.__filtered_frame = None\n        self.__sort_criteria = None\n        self.__visible_frame = None\n        self.__meta_computer.unlink()\n        self.__meta_computer = None\n\n    @property\n    def visible_frame(self) -> VisibleFrame:\n        return self.__visible_frame\n\n    def get_column_statistics(self, col_index: int) -> Dict[str, str]:\n        return self.__visible_frame.get_column_statistics(col_index)\n\n    def get_column_name_completion_variants(self, source: Any, is_synthetic_df: bool) -> List[\n        Union[CompletionVariant, NestedCompletionVariant]]:\n        result = []\n\n        if (source is None and is_synthetic_df) or source is self.__source_frame:\n            source = self.__source_frame\n\n        if not isinstance(source, DataFrame):\n            return result\n\n        str_fqt = fq_type(\"\")\n        for col in source.columns:\n            result.append(CompletionVariant(fq_type=str_fqt, value=col))\n\n        return result\n\n    def set_sort_criteria(self, sort_by_column_index: Optional[List[int]], sort_ascending: Optional[List[bool]]):\n        new_sort_criteria = SortCriteria(sort_by_column_index, sort_ascending)\n        if new_sort_criteria != self.__sort_criteria:\n            self.__sort_criteria = new_sort_criteria\n            self.__visible_frame = self._recompute_visible_frame()\n\n    def get_table_structure(self, fingerprint: str) -> TableStructure:\n        rows_count, columns_count = self.__visible_frame.region.frame_shape\n        org_rows_count, org_cols_count = self.__source_frame.shape\n        if rows_count == 0 or columns_count == 0:\n            rows_count = columns_count = 0\n        return TableStructure(\n            org_rows_count=org_rows_count,\n            org_columns_count=org_cols_count,\n            rows_count=rows_count,\n            columns_count=columns_count,\n            fingerprint=fingerprint,\n            column_info=self._get_frame_column_info() if columns_count != 0\n            else TableStructureColumnInfo(columns=[], legend=None),\n        )\n\n    def _get_frame_column_info(self) -> TableStructureColumnInfo:\n        ts_columns: List[TableStructureColumn] = []\n\n        col_names = self.__source_frame.columns\n        col_dtypes = self.__source_frame.dtypes\n        for col in self.visible_frame.get_column_indices():\n            col_dtype = col_dtypes[col]\n            ts_columns.append(\n                TableStructureColumn(\n                    dtype=str(col_dtype),\n                    labels=[col_names[col]],\n                    id=col,\n                    text_align=self._get_column_text_align(col_dtype),\n                )\n            )\n\n        return TableStructureColumnInfo(columns=ts_columns, legend=None)\n\n    @staticmethod\n    def _get_column_text_align(col_dtype: DataType) -> Union[None, TextAlign]:\n        if col_dtype.is_numeric() and col_dtype is not datatypes.Boolean:\n            return TextAlign.RIGHT\n        return None\n\n    def get_chunk_data_generator(self):\n        return ChunkDataGenerator(self.__visible_frame, self.__format_options, self.__meta_computer)\n\n    def _recompute_visible_frame(self) -> VisibleFrame:\n        col_idx = None\n\n        if self.__filtered_frame is None:\n            data_frame = self.__source_frame\n        else:\n            col_idx = []\n            org_col_names = self.__source_frame.columns\n            for c_name in self.__filtered_frame.columns:\n                try:\n                    col_idx.append(org_col_names.index(c_name))\n                except ValueError:\n                    pass\n\n            if not col_idx:\n                return VisibleFrame(DataFrame(), None, None)\n\n            data_frame = self.__filtered_frame\n\n        sorted_row_idx = None\n        if not self.__sort_criteria.is_empty():\n            col_names = data_frame.columns\n\n            row_idx_col_name: str = \"cms_render_sdfv__row_nr\"\n\n            if hasattr(data_frame, 'with_row_index'):\n                frame_with_index = data_frame.with_row_index(row_idx_col_name)\n            else:\n                frame_with_index = data_frame.with_row_count(row_idx_col_name)\n\n            by_names = [col_names[i] for i in self.__sort_criteria.by_column]\n            sorted_row_idx = frame_with_index \\\n                .sort(by_names, descending=[not asc for asc in self.__sort_criteria.ascending]) \\\n                .get_column(row_idx_col_name)\n\n        return VisibleFrame(unsorted_source_frame=data_frame, sorted_row_idx=sorted_row_idx, org_col_idx=col_idx)\n",
            "meta_computer": "from typing import Any\n\nfrom polars import DataFrame, Series, datatypes\n\nfrom cms_rendner_sdfv.base.table_source import AbstractMetaComputer\n\n\nclass MetaComputer(AbstractMetaComputer):\n    def __init__(self, source_frame: DataFrame):\n        super().__init__()\n        self.__source_frame = source_frame\n\n    def unlink(self):\n        self.__source_frame = None\n\n    def _compute_min_max_at(self, col: int) -> (Any, Any):\n        name = self.__source_frame.columns[col]\n        column: Series = self.__source_frame.get_column(name)\n        if column.dtype.is_numeric() and column.dtype is not datatypes.Boolean:\n            return column.min(), column.max()\n        return None, None\n",
            "table_source": "from cms_rendner_sdfv.base.table_source import AbstractTableSource\nfrom cms_rendner_sdfv.base.types import TableSourceKind\nfrom cms_rendner_sdfv.polars.frame_context import FrameContext\n\n\nclass TableSource(AbstractTableSource):\n    def __init__(self, context: FrameContext, fingerprint: str):\n        super().__init__(TableSourceKind.TABLE_SOURCE, context, fingerprint)\n",
            "table_source_factory": "from typing import Any, Union\n\nimport polars as pl\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableSource, AbstractTableSourceFactory\nfrom cms_rendner_sdfv.base.types import CreateTableSourceConfig, CreateTableSourceFailure, CreateTableSourceErrorKind\nfrom cms_rendner_sdfv.polars.create_fingerprint import create_fingerprint\nfrom cms_rendner_sdfv.polars.frame_context import FrameContext\nfrom cms_rendner_sdfv.polars.table_source import TableSource\n\n\nclass TableSourceFactory(AbstractTableSourceFactory):\n\n    def _create_internal(self,\n                         data_source: Any,\n                         config: CreateTableSourceConfig,\n                         caller_globals: dict,\n                         ) -> Union[AbstractTableSource, CreateTableSourceFailure]:\n        ds_frame = None\n        if isinstance(data_source, dict):\n            ds_frame = pl.from_dict(data_source)\n        elif isinstance(data_source, pl.DataFrame):\n            ds_frame = data_source\n        else:\n            return CreateTableSourceFailure(\n                error_kind=CreateTableSourceErrorKind.UNSUPPORTED_DATA_SOURCE_TYPE,\n                info=str(type(data_source)),\n            )\n\n        pre_fingerprint = config.previous_fingerprint\n        cur_fingerprint = create_fingerprint(ds_frame, data_source)\n        if pre_fingerprint is not None and pre_fingerprint != cur_fingerprint:\n            return CreateTableSourceFailure(\n                error_kind=CreateTableSourceErrorKind.INVALID_FINGERPRINT,\n                info=cur_fingerprint,\n            )\n\n        filtered_frame = None\n        filter_eval_expr = config.filter_eval_expr\n        if filter_eval_expr is not None and filter_eval_expr != \"\":\n            try:\n                if config.filter_eval_expr_provide_frame:\n                    caller_globals[\"_df\"] = ds_frame\n                filtered_frame = eval(filter_eval_expr, caller_globals)\n            except Exception as e:\n                return CreateTableSourceFailure(\n                    error_kind=CreateTableSourceErrorKind.FILTER_FRAME_EVAL_FAILED,\n                    info=repr(e),\n                )\n\n            if not isinstance(filtered_frame, pl.DataFrame):\n                return CreateTableSourceFailure(\n                    error_kind=CreateTableSourceErrorKind.FILTER_FRAME_OF_WRONG_TYPE,\n                    info=str(type(filtered_frame)),\n                )\n\n        return TableSource(FrameContext(ds_frame, filtered_frame), fingerprint=cur_fingerprint)\n",
            "visible_frame": "from typing import Dict, Iterator, List, Union\n\nimport polars as pl\n\nfrom cms_rendner_sdfv.base.constants import COL_STATISTIC_ENTRY_MAX_STR_LEN\nfrom cms_rendner_sdfv.base.types import Region\n\n\nclass VisibleFrame:\n    def __init__(self,\n                 unsorted_source_frame: pl.DataFrame,\n                 sorted_row_idx: Union[None, pl.Series] = None,\n                 org_col_idx: Union[None, List[int]] = None,\n                 ):\n        self.region = Region.with_frame_shape(unsorted_source_frame.shape)\n        self.__unsorted_source_frame: pl.DataFrame = unsorted_source_frame\n        self.__column_names: List[str] = unsorted_source_frame.columns\n        self.__sorted_row_idx: Union[None, pl.Series] = sorted_row_idx\n        self.__org_col_idx: Union[None, List[int]] = org_col_idx\n\n    def unlink(self):\n        self.__unsorted_source_frame = None\n        self.__column_names = None\n        self.__sorted_row_idx = None\n        self.__org_col_idx = None\n\n    def row_idx_iter(self, region: Region = None) -> Iterator[int]:\n        region = self.region.get_bounded_region(region)\n        r = 0\n        while r < region.rows:\n            if self.__sorted_row_idx is None:\n                yield r + region.first_row\n            else:\n                yield self.__sorted_row_idx[r + region.first_row]\n            r += 1\n\n    def series_at(self, col: int) -> pl.Series:\n        name = self.__column_names[self.region.first_col + col]\n        return self.__unsorted_source_frame.get_column(name)\n\n    def get_column_indices(self) -> List[int]:\n        if self.__org_col_idx is None:\n            return list(range(self.region.cols))\n        return self.__org_col_idx\n\n    def get_col_index_in_source_frame(self, col: int) -> int:\n        return col if self.__org_col_idx is None else self.__org_col_idx[col]\n\n    def get_column_statistics(self, col_index: int) -> Dict[str, str]:\n        def truncate(v) -> str:\n            vs = str(v)\n            return vs if len(vs) <= COL_STATISTIC_ENTRY_MAX_STR_LEN else vs[:COL_STATISTIC_ENTRY_MAX_STR_LEN - 1] + '\u2026'\n\n        try:\n            s = self.series_at(col_index)\n            df = s.describe()\n            keys = df.get_column(df.columns[0]).to_list()\n            values = [truncate(v) for v in df.get_column(df.columns[1]).to_list()]\n            return dict(zip(keys, values))\n        except TypeError as e:\n            return {'error': str(e)}\n"
        }
    }
}