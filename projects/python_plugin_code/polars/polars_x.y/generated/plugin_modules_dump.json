{
    "cms_rendner_sdfv": {
        "polars": {
            "constants": "CELL_MAX_LIST_LEN = 60\n",
            "create_fingerprint": "from hashlib import blake2b\nfrom typing import Any\n\nfrom polars import DataFrame\n\n\ndef create_fingerprint(frame: DataFrame, org_data_source: Any = None) -> str:\n    fingerprint_input = [\n        id(org_data_source if org_data_source is not None else frame),\n        frame.shape,\n        frame.columns[:60],\n        frame.dtypes[:60]\n    ]\n    return blake2b('-'.join(str(x) for x in fingerprint_input).encode(), digest_size=16).hexdigest()\n",
            "frame_context": "from typing import List, Optional\n\nfrom polars import DataFrame\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableFrameGenerator, AbstractTableSourceContext\nfrom cms_rendner_sdfv.base.types import SortCriteria, TableStructure\nfrom cms_rendner_sdfv.polars.visible_frame import VisibleFrame\n\n\nclass FrameContext(AbstractTableSourceContext):\n    def __init__(self, source_frame: DataFrame):\n        self.__source_frame = source_frame\n        self.__sort_criteria: SortCriteria = SortCriteria()\n        self.__visible_frame: VisibleFrame = self._recompute_visible_frame()\n\n    @property\n    def visible_frame(self) -> VisibleFrame:\n        return self.__visible_frame\n\n    def set_sort_criteria(self, sort_by_column_index: Optional[List[int]], sort_ascending: Optional[List[bool]]):\n        new_sort_criteria = SortCriteria(sort_by_column_index, sort_ascending)\n        if new_sort_criteria != self.__sort_criteria:\n            self.__sort_criteria = new_sort_criteria\n            self.__visible_frame = self._recompute_visible_frame()\n\n    def get_table_structure(self, fingerprint: str) -> TableStructure:\n        rows_count, columns_count = self.__visible_frame.region.frame_shape\n        org_rows_count, org_cols_count = self.__source_frame.shape\n        if rows_count == 0 or columns_count == 0:\n            rows_count = columns_count = 0\n        return TableStructure(\n            org_rows_count=org_rows_count,\n            org_columns_count=org_cols_count,\n            rows_count=rows_count,\n            columns_count=columns_count,\n            fingerprint=fingerprint,\n        )\n\n    def get_table_frame_generator(self) -> AbstractTableFrameGenerator:\n        from cms_rendner_sdfv.polars.table_frame_generator import TableFrameGenerator\n        return TableFrameGenerator(self.__visible_frame)\n\n    def _recompute_visible_frame(self) -> VisibleFrame:\n        row_idx = None\n        if not self.__sort_criteria.is_empty():\n            col_names = self.__source_frame.columns\n\n            row_idx_col_name: str = \"cms_render_sdfv__row_nr\"\n\n            if hasattr(self.__source_frame, 'with_row_index'):\n                frame_with_index = self.__source_frame.with_row_index(row_idx_col_name)\n            else:\n                frame_with_index = self.__source_frame.with_row_count(row_idx_col_name)\n\n            by_names = [col_names[i] for i in self.__sort_criteria.by_column]\n            row_idx = frame_with_index \\\n                .sort(by_names, descending=[not asc for asc in self.__sort_criteria.ascending]) \\\n                .get_column(row_idx_col_name)\n\n        return VisibleFrame(self.__source_frame, row_idx)\n",
            "table_frame_generator": "import os\nfrom typing import List\n\nimport polars as pl\n\nfrom cms_rendner_sdfv.base.constants import CELL_MAX_STR_LEN\nfrom cms_rendner_sdfv.base.table_source import AbstractTableFrameGenerator\nfrom cms_rendner_sdfv.base.types import Region, TableFrame, TableFrameCell, TableFrameColumn\nfrom cms_rendner_sdfv.polars.constants import CELL_MAX_LIST_LEN\nfrom cms_rendner_sdfv.polars.visible_frame import VisibleFrame, Chunk\n\n\nclass TableFrameGenerator(AbstractTableFrameGenerator):\n    def __init__(self, visible_frame: VisibleFrame):\n        super().__init__(visible_frame)\n\n    def generate(self,\n                 region: Region = None,\n                 exclude_row_header: bool = False,\n                 exclude_col_header: bool = False,\n                 ) -> TableFrame:\n        chunk = self._visible_frame.get_chunk(region)\n\n        columns = [] if exclude_col_header else self._extract_columns(chunk)\n        cells = self._extract_cells(chunk)\n\n        return TableFrame(\n            index_labels=None,\n            columns=columns,\n            legend=None,\n            cells=cells,\n        )\n\n    @staticmethod\n    def _extract_columns(chunk: Chunk) -> List[TableFrameColumn]:\n        result: List[TableFrameColumn] = []\n\n        for c in range(chunk.region.cols):\n            series = chunk.series_at(c)\n            result.append(\n                TableFrameColumn(\n                    dtype=str(series.dtype),\n                    labels=[series.name],\n                    describe=chunk.describe(series),\n                )\n            )\n\n        return result\n\n    @staticmethod\n    def _extract_cells(chunk: Chunk) -> List[List[TableFrameCell]]:\n        result: List[List[TableFrameCell]] = []\n\n        if chunk.region.is_empty():\n            return result\n\n        with pl.Config() as cfg:\n            str_len = int(os.environ.get(\"POLARS_FMT_STR_LEN\", str(CELL_MAX_STR_LEN)))\n            cfg.set_fmt_str_lengths(min(str_len, CELL_MAX_STR_LEN))\n\n            cell_list_len = int(os.environ.get(\"POLARS_FMT_TABLE_CELL_LIST_LEN\", str(CELL_MAX_LIST_LEN)))\n            cfg.set_fmt_table_cell_list_len(min(cell_list_len, CELL_MAX_LIST_LEN))\n\n            for c in range(chunk.region.cols):\n                series = chunk.series_at(c)\n                should_create_row = not result\n                for r, row_in_series in enumerate(chunk.row_idx_iter()):\n                    v = series._s.get_fmt(row_in_series, str_len)\n                    if v[0] == '\"':\n                        v = v[1:]\n                    if v[-1] == '\"':\n                        v = v[0:-1]\n\n                    if should_create_row:\n                        result.append([TableFrameCell(v)])\n                    else:\n                        result[r].append(TableFrameCell(v))\n\n        return result\n",
            "table_source": "from cms_rendner_sdfv.base.table_source import AbstractTableSource\nfrom cms_rendner_sdfv.base.types import TableSourceKind\nfrom cms_rendner_sdfv.polars.frame_context import FrameContext\n\n\nclass TableSource(AbstractTableSource):\n    def __init__(self, context: FrameContext, fingerprint: str):\n        super().__init__(TableSourceKind.TABLE_SOURCE, context, fingerprint)\n",
            "table_source_factory": "from typing import Any, Union\n\nimport polars as pl\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableSource, AbstractTableSourceFactory\nfrom cms_rendner_sdfv.base.types import CreateTableSourceConfig, CreateTableSourceFailure, CreateTableSourceErrorKind\nfrom cms_rendner_sdfv.polars.create_fingerprint import create_fingerprint\nfrom cms_rendner_sdfv.polars.frame_context import FrameContext\nfrom cms_rendner_sdfv.polars.table_source import TableSource\n\n\nclass TableSourceFactory(AbstractTableSourceFactory):\n\n    def _create_internal(self,\n                         data_source: Any,\n                         config: CreateTableSourceConfig,\n                         caller_globals: dict,\n                         ) -> Union[AbstractTableSource, CreateTableSourceFailure]:\n        ds_frame = None\n        if isinstance(data_source, dict):\n            ds_frame = pl.from_dict(data_source)\n        elif isinstance(data_source, pl.DataFrame):\n            ds_frame = data_source\n        else:\n            return CreateTableSourceFailure(\n                error_kind=CreateTableSourceErrorKind.UNSUPPORTED_DATA_SOURCE_TYPE,\n                info=str(type(data_source)),\n            )\n\n        pre_fingerprint = config.previous_fingerprint\n        cur_fingerprint = create_fingerprint(ds_frame, data_source)\n        if pre_fingerprint is not None and pre_fingerprint != cur_fingerprint:\n            return CreateTableSourceFailure(\n                error_kind=CreateTableSourceErrorKind.INVALID_FINGERPRINT,\n                info=cur_fingerprint,\n            )\n\n        return TableSource(FrameContext(ds_frame), fingerprint=cur_fingerprint)\n",
            "visible_frame": "from typing import Union, Dict, Iterator\n\nimport polars as pl\n\nfrom cms_rendner_sdfv.base.table_source import AbstractVisibleFrame\nfrom cms_rendner_sdfv.base.types import Region\n\n\nclass Chunk:\n    def __init__(self, frame: 'VisibleFrame', region: Region):\n        self.__frame = frame\n        self.region = region\n\n    def series_at(self, offset: int) -> pl.Series:\n        return self.__frame.series_at(self.region.first_col + offset)\n\n    @staticmethod\n    def describe(s: pl.Series) -> Dict[str, str]:\n        def truncate(v) -> str:\n            vs = str(v)\n            return vs if len(vs) <= 120 else vs[:120] + '\u2026'\n        try:\n            df = s.describe()\n            keys = df.get_column(df.columns[0]).to_list()\n            values = [truncate(v) for v in df.get_column(df.columns[1]).to_list()]\n            return dict(zip(keys, values))\n        except TypeError as e:\n            return {'error': str(e)}\n\n    def row_idx_iter(self) -> Iterator[int]:\n        return self.__frame.row_idx_iter(self.region)\n\n\nclass VisibleFrame(AbstractVisibleFrame):\n    def __init__(self, source_frame: pl.DataFrame, row_idx: Union[None, pl.Series]):\n        super().__init__(Region.with_frame_shape(source_frame.shape))\n        self.__source_frame = source_frame\n        self.__column_names = source_frame.columns\n        self.__row_idx = row_idx\n\n    def row_idx_iter(self, region: Region = None) -> Iterator[int]:\n        region = self.region.get_bounded_region(region)\n        r = 0\n        while r < region.rows:\n            if self.__row_idx is None:\n                yield r + region.first_row\n            else:\n                yield self.__row_idx[r + region.first_row]\n            r += 1\n\n    def series_at(self, col: int) -> pl.Series:\n        name = self.__column_names[self.region.first_col + col]\n        return self.__source_frame.get_column(name)\n\n    def get_chunk(self, region: Region = None) -> Chunk:\n        return Chunk(self, self.region.get_bounded_region(region))\n"
        }
    }
}