{
    "cms_rendner_sdfv": {
        "base": {
            "constants": "\nCELL_MAX_STR_LEN = 200\nDESCRIBE_COL_MAX_STR_LEN = 120\n\n",
            "helpers": "\n\ndef truncate_str(s: str, max_length: int) -> str:\n    return s if len(s) <= max_length else s[:max_length - 1] + '\u2026'\n",
            "table_source": "import inspect\nfrom abc import ABC, abstractmethod\nfrom typing import Any, List, Union, TypeVar\n\nfrom cms_rendner_sdfv.base.temp import TEMP_VARS, EvaluatedVarsCleaner\nfrom cms_rendner_sdfv.base.transforms import to_json\nfrom cms_rendner_sdfv.base.types import CreateTableSourceConfig, CreateTableSourceFailure, Region, TableFrame, \\\n    TableSourceKind, TableStructure, CreateTableSourceErrorKind\n\n\nclass AbstractVisibleFrame(ABC):\n    def __init__(self, region: Region):\n        self.region = region\n\n    def get_column_indices(self, part_start: int, max_columns: int) -> List[int]:\n        end = min(part_start + max_columns, self.region.cols)\n        return [] if end <= part_start or part_start < 0 else list(range(part_start, end))\n\n\nVF = TypeVar('VF', bound=AbstractVisibleFrame)\n\n\nclass AbstractTableFrameGenerator(ABC):\n    def __init__(self, visible_frame: VF):\n        self._visible_frame: VF = visible_frame\n\n    @abstractmethod\n    def generate(self,\n                 region: Region = None,\n                 exclude_row_header: bool = False,\n                 exclude_col_header: bool = False,\n                 ) -> TableFrame:\n        pass\n\n    def generate_by_combining_chunks(self,\n                                     rows_per_chunk: int,\n                                     cols_per_chunk: int,\n                                     region: Region = None,\n                                     ) -> TableFrame:\n        result = None\n\n        if region is None:\n            region = self._visible_frame.region\n\n        for local_chunk in region.iterate_local_chunkwise(rows_per_chunk, cols_per_chunk):\n\n            chunk_contains_elements_of_first_row = local_chunk.first_row == 0\n            chunk_contains_row_start_element = local_chunk.first_col == 0\n\n            chunk_table = self.generate(\n                region=local_chunk.translate(region.first_row, region.first_col),\n                exclude_row_header=not chunk_contains_row_start_element,\n                exclude_col_header=not chunk_contains_elements_of_first_row,\n            )\n\n            if result is None:\n                result = chunk_table\n            else:\n                if chunk_contains_elements_of_first_row:\n                    result.columns.extend(chunk_table.columns)\n                if chunk_contains_row_start_element:\n                    if result.index_labels is not None:\n                        assert chunk_table.index_labels is not None\n                        result.index_labels.extend(chunk_table.index_labels)\n                    result.cells.extend(chunk_table.cells)\n                else:\n                    for i, row in enumerate(chunk_table.cells):\n                        result.cells[i + local_chunk.first_row].extend(row)\n\n        return result if result is not None else TableFrame(index_labels=[], columns=[], legend=None, cells=[])\n\n\nclass AbstractColumnNameCompleter(ABC):\n    def get_variants(self,\n                     source: Any,\n                     is_synthetic_df: bool,\n                     name_to_complete: Union[None, str, int],\n                     max_matches: int = 200,\n                     ) -> List[str]:\n        matches: List[str] = []\n        column_names = self._resolve_column_names(source, is_synthetic_df)\n\n        def add_variant_formatted(v: Union[str, int]) -> int:\n            matches.append(f'\"{v}\"' if isinstance(v, str) else str(v))\n            return len(matches)\n\n        if name_to_complete is None:\n            for cn in column_names:\n                if not isinstance(cn, (int, str)):\n                    continue\n                if add_variant_formatted(cn) >= max_matches:\n                    break\n        else:\n            prefix = str(name_to_complete).lower()\n            variant_type = type(name_to_complete)\n\n            for cn in column_names:\n                if not isinstance(cn, variant_type):\n                    continue\n                if not prefix or str(cn).lower().startswith(prefix):\n                    if add_variant_formatted(cn) >= max_matches:\n                        break\n\n        return matches\n\n    @abstractmethod\n    def _resolve_column_names(self, source: Any, is_synthetic_df: bool) -> List[Any]:\n        pass\n\n\nclass AbstractTableSourceContext(ABC):\n    def set_sort_criteria(self, sort_by_column_index: Union[None, List[int]], sort_ascending: Union[None, List[bool]]):\n        pass\n\n    def get_column_name_completer(self) -> Union[None, AbstractColumnNameCompleter]:\n        return None\n\n    @property\n    @abstractmethod\n    def visible_frame(self) -> AbstractVisibleFrame:\n        pass\n\n    @abstractmethod\n    def get_table_structure(self, fingerprint: str) -> TableStructure:\n        pass\n\n    @abstractmethod\n    def get_table_frame_generator(self) -> AbstractTableFrameGenerator:\n        pass\n\n\nT = TypeVar('T', bound=AbstractTableSourceContext)\n\n\nclass AbstractTableSource(ABC):\n    def __init__(self, kind: TableSourceKind, context: T, fingerprint: str):\n        self.__kind = kind\n        self._context = context\n        self.__fingerprint = fingerprint\n\n    def get_kind(self) -> TableSourceKind:\n        return self.__kind\n\n    def get_column_name_variants(self,\n                                 source: Any,\n                                 is_synthetic_df: bool,\n                                 name_to_complete: Union[str, int],\n                                 ) -> List[str]:\n        completer = self._context.get_column_name_completer()\n        return [] if completer is None else completer.get_variants(\n            source=source,\n            is_synthetic_df=is_synthetic_df,\n            name_to_complete=name_to_complete,\n        )\n\n    @staticmethod\n    def jsonify(data: Any) -> str:\n        return to_json(data)\n\n    def get_org_indices_of_visible_columns(self, part_start: int, max_columns: int) -> List[int]:\n        return self._context.visible_frame.get_column_indices(part_start, max_columns)\n\n    def get_table_structure(self) -> TableStructure:\n        return self._context.get_table_structure(self.__fingerprint)\n\n    def set_sort_criteria(self,\n                          by_column_index: Union[None, List[int]] = None,\n                          ascending: Union[None, List[bool]] = None,\n                          ):\n        self._context.set_sort_criteria(by_column_index, ascending)\n\n    def compute_chunk_table_frame(self,\n                                  first_row: int,\n                                  first_col: int,\n                                  rows: int,\n                                  cols: int,\n                                  exclude_row_header: bool = False,\n                                  exclude_col_header: bool = False\n                                  ) -> TableFrame:\n        return self._context.get_table_frame_generator().generate(\n            region=Region(first_row, first_col, rows, cols),\n            exclude_row_header=exclude_row_header,\n            exclude_col_header=exclude_col_header,\n        )\n\n    def clear(self, id_names: List[str]):\n        EvaluatedVarsCleaner.clear(id_names, 1)\n        return self\n\n\nclass AbstractTableSourceFactory(ABC):\n    def create(self,\n               data_source: Any,\n               create_config: Union[CreateTableSourceConfig, dict] = None,\n               ) -> Union[AbstractTableSource, str]:\n        try:\n            config = create_config\n\n            if isinstance(config, dict):\n                config = CreateTableSourceConfig(**config)\n            elif config is None:\n                config = CreateTableSourceConfig()\n\n            caller_globals = {}\n            caller_frame = inspect.currentframe().f_back\n            if caller_frame:\n                caller_globals.update(caller_frame.f_globals)\n                caller_globals.update(caller_frame.f_locals)\n\n            table_source = self._create_internal(data_source, config, caller_globals)\n            if not isinstance(table_source, AbstractTableSource):\n                if isinstance(table_source, CreateTableSourceFailure):\n                    return to_json(table_source)\n                expected_type = type(AbstractTableSource)\n                actual_type = type(table_source)\n                raise ValueError(\n                    f\"Created table_source is of type: {actual_type}, expected: ${expected_type}.\"\n                )\n\n            if config.temp_var_slot_id is not None:\n                TEMP_VARS[config.temp_var_slot_id] = table_source\n\n            return table_source\n        except Exception as e:\n            return to_json(\n                CreateTableSourceFailure(\n                    error_kind=CreateTableSourceErrorKind.EVAL_EXCEPTION,\n                    info=repr(e),\n                ),\n            )\n\n    @abstractmethod\n    def _create_internal(self,\n                         data_source: Any,\n                         config: CreateTableSourceConfig,\n                         caller_globals: dict,\n                         ) -> Union[AbstractTableSource, CreateTableSourceFailure]:\n        pass\n",
            "temp": "import inspect\nfrom typing import List\n\nTEMP_VARS = {}\n\n\nclass EvaluatedVarsCleaner:\n\n    @staticmethod\n    def clear(id_names: List[str], frame_offset: int = 0):\n        not_found = []\n        names_to_check = id_names\n\n        for name in names_to_check:\n            if TEMP_VARS.pop(name, None) is None:\n                not_found.append(name)\n\n        if not not_found:\n            return\n\n        frame = inspect.currentframe().f_back\n        if frame is None:\n            return\n\n        for i in range(frame_offset):\n            frame = frame.f_back\n            if frame is None:\n                return\n\n        for i in range(10):\n            names_to_check = not_found\n            not_found = []\n            f_locals = frame.f_locals\n\n            for name in names_to_check:\n                if name in f_locals:\n                    f_locals[name] = None\n                else:\n                    not_found.append(name)\n\n            if not not_found:\n                return\n\n            frame = frame.f_back\n            if frame is None:\n                return\n",
            "transforms": "import json\nfrom dataclasses import asdict, is_dataclass\nfrom enum import Enum\nfrom typing import Any\n\n\nclass _CustomJSONEncoder(json.JSONEncoder):\n    def default(self, obj: Any):\n        if is_dataclass(obj):\n            return asdict(obj)\n        if isinstance(obj, Enum):\n            return obj.name\n        return str(obj)\n\n\ndef to_json(data: Any, **kwargs) -> str:\n    return json.dumps(data, **kwargs, cls=_CustomJSONEncoder)\n",
            "types": "import dataclasses\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom typing import Any, Dict, List, Tuple, Union\n\n\n@dataclass(frozen=True)\nclass TableStructure:\n    org_rows_count: int\n    org_columns_count: int\n    rows_count: int\n    columns_count: int\n    fingerprint: str\n\n\n@dataclass(frozen=True)\nclass TableFrameCell:\n    value: str\n    css: Union[None, Dict[str, str]] = None\n\n\n@dataclass(frozen=True)\nclass TableFrameColumn:\n    dtype: str\n    labels: List[str]\n    describe: Union[None, Dict[str, str]] = None\n\n\n@dataclass(frozen=True)\nclass TableFrameLegend:\n    index: List[str]\n    column: List[str]\n\n\n@dataclass(frozen=True)\nclass TableFrame:\n    index_labels: Union[None, List[List[str]]]\n    columns: Union[None, List[TableFrameColumn]]\n    cells: List[List[TableFrameCell]]\n    legend: Union[None, TableFrameLegend] = None\n\n\n@dataclass(frozen=True)\nclass Region:\n    first_row: int = 0\n    first_col: int = 0\n    rows: int = 0\n    cols: int = 0\n\n    @classmethod\n    def with_frame_shape(cls, shape: Tuple[int, int]):\n        return cls(rows=shape[0], cols=shape[1])\n\n    def translate(self, row_offset: int, col_offset: int):\n        return dataclasses.replace(self, first_row=self.first_row + row_offset, first_col=self.first_col + col_offset)\n\n    def is_empty(self) -> bool:\n        return self.rows == 0 or self.cols == 0\n\n    def is_valid(self) -> bool:\n        return self.first_row >= 0 and self.first_col >= 0 and self.rows >= 0 and self.cols >= 0\n\n    @property\n    def frame_shape(self) -> Tuple[int, int]:\n        return self.rows, self.cols\n\n    def iterate_local_chunkwise(self, rows_per_chunk: int, cols_per_chunk: int):\n        if not self.is_valid():\n            raise ValueError(\"Invalid Regions can't be iterated chunkwise.\")\n        if rows_per_chunk <= 0 or cols_per_chunk <= 0:\n            raise ValueError(f\"rows_per_chunk ({rows_per_chunk}) and cols_per_chunk ({cols_per_chunk}) must be > 0\")\n\n        rows_processed = 0\n        while rows_processed < self.rows:\n            rows = min(rows_per_chunk, self.rows - rows_processed)\n            cols_in_row_processed = 0\n            while cols_in_row_processed < self.cols:\n                cols = min(cols_per_chunk, self.cols - cols_in_row_processed)\n\n                yield Region(rows_processed, cols_in_row_processed, rows, cols)\n\n                cols_in_row_processed += cols\n            rows_processed += rows\n\n    def get_bounded_region(self, unbound_region: Union[None, 'Region']) -> 'Region':\n        if unbound_region is None:\n            return self\n        if not self.is_valid():\n            raise ValueError(\"No valid bounds.\")\n        if not unbound_region.is_valid():\n            raise ValueError(\"Can't compute a bounded region against an invalid Region.\")\n        first_row = max(unbound_region.first_row, self.first_row)\n        first_col = max(unbound_region.first_col, self.first_col)\n        last_row = min(unbound_region.first_row + unbound_region.rows, self.first_row + self.rows)\n        last_col = min(unbound_region.first_col + unbound_region.cols, self.first_col + self.cols)\n        result = Region(first_row, first_col, last_row - first_row, last_col - first_col)\n        return result if result.is_valid() else Region(\n            first_row=unbound_region.first_row,\n            first_col=unbound_region.first_col\n        )\n\n\n@dataclass(frozen=True)\nclass SortCriteria:\n    by_column: Union[None, List[int]] = None\n    ascending: Union[None, List[bool]] = None\n\n    def is_empty(self) -> bool:\n        return not self.by_column\n\n    def __eq__(self, other):\n        if isinstance(other, SortCriteria):\n            def _equals(s: Union[None, List[Any]], o: Union[None, List[Any]]) -> bool:\n                return (not s and not o) or s == o\n\n            return _equals(self.by_column, other.by_column) and _equals(self.ascending, other.ascending)\n        return False\n\n\n@dataclass(frozen=True)\nclass CreateTableSourceConfig:\n    temp_var_slot_id: Union[None, str] = None\n    data_source_transform_hint: Union[None, str] = None\n    previous_fingerprint: Union[None, str] = None\n    filter_eval_expr: Union[None, str] = None\n    filter_eval_expr_provide_frame: Union[None, bool] = None\n\n\nclass CreateTableSourceErrorKind(Enum):\n    EVAL_EXCEPTION = 0,\n    RE_EVAL_DATA_SOURCE_OF_WRONG_TYPE = 1,\n    UNSUPPORTED_DATA_SOURCE_TYPE = 2,\n    INVALID_FINGERPRINT = 3,\n    FILTER_FRAME_EVAL_FAILED = 4,\n    FILTER_FRAME_OF_WRONG_TYPE = 5\n\n\n@dataclass(frozen=True)\nclass CreateTableSourceFailure:\n    error_kind: CreateTableSourceErrorKind\n    info: str\n\n\nclass TableSourceKind(Enum):\n    TABLE_SOURCE = 1\n    PATCHED_STYLER = 2\n\n"
        }
    }
}