{
    "cms_rendner_sdfv": {
        "base": {
            "constants": "CELL_MAX_LIST_LEN = 42\nCELL_MAX_STR_LEN = 200\nCOL_STATISTIC_ENTRY_MAX_STR_LEN = 120\n\n",
            "helpers": "\n\ndef truncate_str(s: str, max_length: int) -> str:\n    return s if len(s) <= max_length else s[:max_length - 1] + '\u2026'\n\n\ndef fq_type(o) -> str:\n    klass = getattr(o, '__class__', '')\n    module = getattr(klass, '__module__', '')\n    qname = getattr(klass, '__qualname__', '')\n    return f'{module}.{qname}'\n",
            "table_source": "import inspect\nimport math\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass, field\nfrom typing import Any, List, Union, TypeVar, Dict, Callable\n\nfrom cms_rendner_sdfv.base.temp import TEMP_VARS, EvaluatedVarsCleaner\nfrom cms_rendner_sdfv.base.transforms import to_json\nfrom cms_rendner_sdfv.base.types import CreateTableSourceConfig, CreateTableSourceFailure, Region, ChunkDataResponse, \\\n    TableSourceKind, TableStructure, CreateTableSourceErrorKind, TableInfo, \\\n    CompletionVariant, NestedCompletionVariant, ChunkDataRequest, CellMeta, TextAlign\nimport cms_rendner_sdfv.base.types as _types\n\n\n@dataclass\nclass MinMaxInfo:\n    min: Any\n    max: Any\n    is_inf: bool = field(init=False)\n\n    def __post_init__(self):\n        vmin = self.min.real if isinstance(self.min, complex) else self.min\n        vmax = self.max.real if isinstance(self.max, complex) else self.max\n        try:\n            self.is_inf = (vmin is not None and math.isinf(vmin)) or (vmax is not None and math.isinf(vmax))\n        except:\n            self.is_inf = False\n\n\nclass AbstractMetaComputer:\n    def __init__(self):\n        self.__min_max_cache: Dict[int, Union[None, MinMaxInfo]] = dict()\n\n    def clear_min_max_cache(self):\n        self.__min_max_cache.clear()\n\n    @abstractmethod\n    def _compute_min_max_at(self, col: int) -> (Any, Any):\n        pass\n\n    def _is_nan(self, v: Any) -> bool:\n        return math.isnan(v)\n\n    def __get_min_max_info_at(self, col: int) -> Union[None, MinMaxInfo]:\n        if col not in self.__min_max_cache:\n            try:\n                min, max = self._compute_min_max_at(col)\n            except:\n                min, max = None, None\n\n            if min is None or max is None:\n                self.__min_max_cache[col] = None\n            else:\n                self.__min_max_cache[col] = MinMaxInfo(min=min, max=max)\n\n        return self.__min_max_cache.get(col)\n\n    def compute_cell_meta(self,\n                          col: int,\n                          value: Any,\n                          css: Union[None, Dict[str, str]] = None,\n                          ) -> Union[None, str]:\n        info = self.__get_min_max_info_at(col)\n        if info is None:\n            return None\n\n        if value is None:\n            meta = CellMeta(cmap_value=-1)\n        else:\n            try:\n                is_nan = self._is_nan(value)\n            except:\n                is_nan = False\n\n            if is_nan:\n                meta = CellMeta.nan()\n            else:\n                meta = CellMeta(\n                    is_min=value == info.min,\n                    is_max=value == info.max,\n                    cmap_value=self.__compute_cmap_value(info, value),\n                )\n\n        if css is not None:\n            meta.background_color = css.get('background-color')\n            meta.text_color = css.get('color')\n            meta.text_align = TextAlign.from_css(css.get('text-align'))\n\n        return meta.pack()\n\n    @staticmethod\n    def __compute_cmap_value(info: MinMaxInfo, value: Any) -> Union[None, int]:\n        if info.is_inf:\n            return -1\n        try:\n            if info.min is None or info.max is None:\n                return None\n            if info.min == info.max:\n                return 0\n            vmin = info.min\n            vmax = info.max\n            if isinstance(vmin, complex):\n                vmin = vmin.real\n            if isinstance(vmax, complex):\n                vmax = vmax.real\n            if isinstance(value, complex):\n                value = value.real\n            normalized = (value - vmin) / (vmax - vmin)\n            return int(100_000 * normalized)\n        except:\n            return None\n\n\nclass ChunkDataGenerator(ABC):\n    def __init__(self, bounds: Region):\n        self.__bounds = bounds\n\n    def _before_generate(self, region: Region):\n        pass\n\n    def _after_generate(self, region: Region):\n        pass\n\n    def _compute_row_headers(self, region: Region, response: ChunkDataResponse):\n        pass\n\n    def _compute_cells(self, region: Region, response: ChunkDataResponse):\n        pass\n\n    def generate(self,\n                 region: Union[None, Region] = None,\n                 request: Union[None, ChunkDataRequest] = None,\n                 ) -> ChunkDataResponse:\n        if request is None:\n            request = ChunkDataRequest()\n\n        region = self.__bounds.get_bounded_region(region)\n        response = ChunkDataResponse()\n\n        self._before_generate(region=region)\n\n        if request.with_row_headers:\n            self._compute_row_headers(region, response)\n\n        if request.with_cells:\n            self._compute_cells(region, response)\n\n        self._after_generate(region=region)\n\n        return response\n\n    def generate_by_combining_chunks(self,\n                                     rows_per_chunk: int,\n                                     cols_per_chunk: int,\n                                     region: Region = None,\n                                     ) -> ChunkDataResponse:\n        result = None\n\n        if region is None:\n            region = self.__bounds\n\n        for local_chunk_region in region.iterate_local_chunkwise(rows_per_chunk, cols_per_chunk):\n\n            chunk_contains_row_start_element = local_chunk_region.first_col == 0\n\n            chunk_data = self.generate(\n                region=local_chunk_region.translate(region.first_row, region.first_col),\n                request=ChunkDataRequest(with_row_headers=chunk_contains_row_start_element),\n            )\n\n            assert chunk_data.cells is not None\n\n            if result is None:\n                result = chunk_data\n            else:\n                if chunk_contains_row_start_element:\n                    if result.row_headers is not None:\n                        assert chunk_data.row_headers is not None\n                        result.row_headers.extend(chunk_data.row_headers)\n                    result.cells.extend(chunk_data.cells)\n                else:\n                    for i, row in enumerate(chunk_data.cells):\n                        result.cells[i + local_chunk_region.first_row].extend(row)\n\n        return result if result is not None else ChunkDataResponse()\n\n\nclass AbstractTableSourceContext(ABC):\n    @abstractmethod\n    def unlink(self):\n        pass\n\n    def set_sort_criteria(self, sort_by_column_index: Union[None, List[int]], sort_ascending: Union[None, List[bool]]):\n        pass\n\n    def get_column_name_completion_variants(self, source: Any, is_synthetic_df: bool) -> List[\n        Union[CompletionVariant, NestedCompletionVariant]]:\n        pass\n\n    @abstractmethod\n    def get_column_statistics(self, col_index: int) -> Dict[str, str]:\n        pass\n\n    @abstractmethod\n    def get_table_structure(self, fingerprint: str) -> TableStructure:\n        pass\n\n    @abstractmethod\n    def get_chunk_data_generator(self) -> ChunkDataGenerator:\n        pass\n\n\nTSC = TypeVar('TSC', bound=AbstractTableSourceContext)\n\n\nclass AbstractTableSource(ABC):\n    def __init__(self, kind: TableSourceKind, context: TSC, fingerprint: str):\n        self.__kind = kind\n        self._context = context\n        self._fingerprint = fingerprint\n\n    def unlink(self):\n        self._context.unlink()\n        self._context = None\n\n    @staticmethod\n    def serialize(data: Any) -> str:\n        return to_json(data)\n\n    def invoke_with_typed_kwargs(self, method_name: str, kwargs_factory: Callable[[Any], Dict[str, Any]]):\n        kwargs = kwargs_factory(_types)\n        method = getattr(self, method_name)\n        return method(**kwargs)\n\n    def get_column_name_completion_variants(self, source: Any, is_synthetic_df: bool) -> str:\n        return self.serialize(\n            self._context.get_column_name_completion_variants(\n                source=source,\n                is_synthetic_df=is_synthetic_df,\n            )\n        )\n\n    def get_info(self) -> str:\n        return self.serialize(\n            TableInfo(\n                kind=TableSourceKind(self.__kind).name,\n                structure=self._context.get_table_structure(self._fingerprint),\n            )\n        )\n\n    def get_column_statistics(self, col_index: int) -> str:\n        return self.serialize(self._context.get_column_statistics(col_index))\n\n    def set_sort_criteria(self,\n                          by_column_index: Union[None, List[int]] = None,\n                          ascending: Union[None, List[bool]] = None,\n                          ) -> 'AbstractTableSource':\n        self._context.set_sort_criteria(by_column_index, ascending)\n        return self\n\n    def compute_chunk_data(self,\n                           region: Region,\n                           request: Union[None, ChunkDataRequest] = None,\n                           ) -> str:\n        return self.serialize(\n            self._context.get_chunk_data_generator().generate(region=region, request=request)\n        )\n\n    def clear(self, id_names: List[str]) -> 'AbstractTableSource':\n        EvaluatedVarsCleaner.clear(id_names, 1)\n        return self\n\n\nclass AbstractTableSourceFactory(ABC):\n    def create(self,\n               data_source: Any,\n               create_config: Union[CreateTableSourceConfig, dict] = None,\n               ) -> Union[AbstractTableSource, str]:\n        try:\n            config = create_config\n\n            if isinstance(config, dict):\n                config = CreateTableSourceConfig(**config)\n            elif config is None:\n                config = CreateTableSourceConfig()\n\n            caller_globals = {}\n            caller_frame = inspect.currentframe().f_back\n            if caller_frame:\n                caller_globals.update(caller_frame.f_globals)\n                caller_globals.update(caller_frame.f_locals)\n\n            table_source = self._create_internal(data_source, config, caller_globals)\n            if not isinstance(table_source, AbstractTableSource):\n                if isinstance(table_source, CreateTableSourceFailure):\n                    return to_json(table_source)\n                expected_type = type(AbstractTableSource)\n                actual_type = type(table_source)\n                raise ValueError(\n                    f\"Created table_source is of type: {actual_type}, expected: ${expected_type}.\"\n                )\n\n            if config.temp_var_slot_id is not None:\n                TEMP_VARS[config.temp_var_slot_id] = table_source\n\n            return table_source\n        except Exception as e:\n            return to_json(\n                CreateTableSourceFailure(\n                    error_kind=CreateTableSourceErrorKind.EVAL_EXCEPTION,\n                    info=repr(e),\n                ),\n            )\n\n    @abstractmethod\n    def _create_internal(self,\n                         data_source: Any,\n                         config: CreateTableSourceConfig,\n                         caller_globals: dict,\n                         ) -> Union[AbstractTableSource, CreateTableSourceFailure]:\n        pass\n",
            "temp": "import inspect\nfrom typing import List\n\nTEMP_VARS = {}\n\n\nclass EvaluatedVarsCleaner:\n\n    @staticmethod\n    def clear(id_names: List[str], frame_offset: int = 0):\n        not_found = []\n        names_to_check = id_names\n\n        for name in names_to_check:\n            temp_var = TEMP_VARS.pop(name, None)\n            if temp_var is None:\n                not_found.append(name)\n            else:\n                if hasattr(temp_var, 'unlink'):\n                    temp_var.unlink()\n\n        if not not_found:\n            return\n\n        frame = inspect.currentframe().f_back\n        if frame is None:\n            return\n\n        for i in range(frame_offset):\n            frame = frame.f_back\n            if frame is None:\n                return\n\n        for i in range(10):\n            names_to_check = not_found\n            not_found = []\n            f_locals = frame.f_locals\n\n            for name in names_to_check:\n                if name in f_locals:\n                    local_var = f_locals[name]\n                    f_locals[name] = None\n                    if hasattr(local_var, 'unlink'):\n                        local_var.unlink()\n                else:\n                    not_found.append(name)\n\n            if not not_found:\n                return\n\n            frame = frame.f_back\n            if frame is None:\n                return\n",
            "transforms": "import json\nfrom dataclasses import asdict, is_dataclass\nfrom enum import Enum\nfrom typing import Any\n\n\nclass _CustomJSONEncoder(json.JSONEncoder):\n    def default(self, obj: Any):\n        if is_dataclass(obj):\n            return asdict(obj)\n        if isinstance(obj, Enum):\n            return obj.name\n        return str(obj)\n\n\ndef to_json(data: Any, **kwargs) -> str:\n    return json.dumps(data, **kwargs, cls=_CustomJSONEncoder)\n",
            "types": "import dataclasses\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom typing import Any, List, Tuple, Union\n\n\nclass TextAlign(Enum):\n    LEFT = 'L'\n    CENTER = 'C'\n    RIGHT = 'R'\n\n    @staticmethod\n    def from_css(text_align: Union[None, str]) -> Union[None, 'TextAlign']:\n        if text_align == 'left' or text_align == 'start':\n            return TextAlign.LEFT\n        if text_align == 'right' or text_align == 'end':\n            return TextAlign.RIGHT\n        if text_align == 'center':\n            return TextAlign.CENTER\n        return None\n\n    @staticmethod\n    def from_value(value: Union[None, str]) -> Union[None, 'TextAlign']:\n        if value == 'L':\n            return TextAlign.LEFT\n        if value == 'R':\n            return TextAlign.RIGHT\n        if value == 'C':\n            return TextAlign.CENTER\n        return None\n\n\n@dataclass(frozen=True)\nclass TableStructureColumn:\n    dtype: str\n    labels: List[str]\n    id: int\n    text_align: Union[None, TextAlign] = None\n\n\n@dataclass(frozen=True)\nclass TableStructureLegend:\n    index: List[str]\n    column: List[str]\n\n\n@dataclass(frozen=True)\nclass TableStructureColumnInfo:\n    columns: List[TableStructureColumn]\n    legend: Union[None, TableStructureLegend]\n\n\n@dataclass(frozen=True)\nclass TableStructure:\n    org_rows_count: int\n    org_columns_count: int\n    rows_count: int\n    columns_count: int\n    fingerprint: str\n    column_info: TableStructureColumnInfo\n\n\n@dataclass(frozen=True)\nclass TableInfo:\n    kind: str\n    structure: TableStructure\n\n\n@dataclass\nclass CellMeta:\n    is_nan: bool = False\n    is_min: bool = False\n    is_max: bool = False\n    cmap_value: Union[None, int] = None\n    background_color: Union[None, str] = None\n    text_color: Union[None, str] = None\n    text_align: Union[None, TextAlign] = None\n\n    @staticmethod\n    def min(background_color: Union[None, str] = None, text_color: Union[None, str] = None) -> 'CellMeta':\n        return CellMeta(is_min=True, cmap_value=0, background_color=background_color, text_color=text_color)\n\n    @staticmethod\n    def min_max(background_color: Union[None, str] = None, text_color: Union[None, str] = None) -> 'CellMeta':\n        return CellMeta(is_min=True, is_max=True, cmap_value=0, background_color=background_color,\n                        text_color=text_color)\n\n    @staticmethod\n    def max(background_color: Union[None, str] = None, text_color: Union[None, str] = None) -> 'CellMeta':\n        return CellMeta(is_max=True, cmap_value=100000, background_color=background_color, text_color=text_color)\n\n    @staticmethod\n    def nan(background_color: Union[None, str] = None, text_color: Union[None, str] = None) -> 'CellMeta':\n        return CellMeta(is_nan=True, cmap_value=-1, background_color=background_color, text_color=text_color)\n\n    def pack(self) -> str:\n        result: str = ''\n        result += self.__to_flag(self.is_nan)\n        result += self.__to_flag(self.is_min)\n        result += self.__to_flag(self.is_max)\n        result += self.__to_optional_part(self.cmap_value)\n        result += self.__to_optional_part(None if self.text_align is None else self.text_align.value)\n        result += self.__to_optional_part(self.background_color, 120)\n        result += self.__to_optional_part(self.text_color, 120)\n        return result\n\n    @staticmethod\n    def from_packed(data: str) -> 'CellMeta':\n        is_nan = data[0] == 'T'\n        is_min = data[1] == 'T'\n        is_max = data[2] == 'T'\n        parts = data[3:].split('|')\n        return CellMeta(\n            is_nan=is_nan,\n            is_min=is_min,\n            is_max=is_max,\n            cmap_value=int(parts[0]) if parts[0] else None,\n            text_align=TextAlign.from_value(parts[1]),\n            background_color=parts[2] if parts[2] else None,\n            text_color=parts[3] if parts[3] else None,\n        )\n\n    @staticmethod\n    def __to_flag(v: bool) -> str:\n        return 'T' if v else 'F'\n\n    @staticmethod\n    def __to_optional_part(part: Any, max_length: int = 99999) -> str:\n        part_end_marker = '|'\n        if part is None:\n            return part_end_marker\n        s = str(part)\n        if len(s) > max_length or part_end_marker in s:\n            return part_end_marker\n        return s + part_end_marker\n\n\n@dataclass(frozen=True)\nclass Cell:\n    value: str\n    meta: Union[None, str] = None\n\n\n@dataclass(frozen=True)\nclass Region:\n    first_row: int = 0\n    first_col: int = 0\n    rows: int = 0\n    cols: int = 0\n\n    @classmethod\n    def with_frame_shape(cls, shape: Tuple[int, int]):\n        return cls(rows=shape[0], cols=shape[1])\n\n    def translate(self, row_offset: int, col_offset: int):\n        return dataclasses.replace(self, first_row=self.first_row + row_offset, first_col=self.first_col + col_offset)\n\n    def is_empty(self) -> bool:\n        return self.rows == 0 or self.cols == 0\n\n    def is_valid(self) -> bool:\n        return self.first_row >= 0 and self.first_col >= 0 and self.rows >= 0 and self.cols >= 0\n\n    @property\n    def frame_shape(self) -> Tuple[int, int]:\n        return self.rows, self.cols\n\n    def iterate_local_chunkwise(self, rows_per_chunk: int, cols_per_chunk: int):\n        if not self.is_valid():\n            raise ValueError(\"Invalid Regions can't be iterated chunkwise.\")\n        if rows_per_chunk <= 0 or cols_per_chunk <= 0:\n            raise ValueError(f\"rows_per_chunk ({rows_per_chunk}) and cols_per_chunk ({cols_per_chunk}) must be > 0\")\n\n        rows_processed = 0\n        while rows_processed < self.rows:\n            rows = min(rows_per_chunk, self.rows - rows_processed)\n            cols_in_row_processed = 0\n            while cols_in_row_processed < self.cols:\n                cols = min(cols_per_chunk, self.cols - cols_in_row_processed)\n\n                yield Region(rows_processed, cols_in_row_processed, rows, cols)\n\n                cols_in_row_processed += cols\n            rows_processed += rows\n\n    def get_bounded_region(self, unbound_region: Union[None, 'Region']) -> 'Region':\n        if unbound_region is None:\n            return self\n        if not self.is_valid():\n            raise ValueError(\"No valid bounds.\")\n        if not unbound_region.is_valid():\n            raise ValueError(\"Can't compute a bounded region against an invalid Region.\")\n        first_row = max(unbound_region.first_row, self.first_row)\n        first_col = max(unbound_region.first_col, self.first_col)\n        last_row = min(unbound_region.first_row + unbound_region.rows, self.first_row + self.rows)\n        last_col = min(unbound_region.first_col + unbound_region.cols, self.first_col + self.cols)\n        result = Region(first_row, first_col, last_row - first_row, last_col - first_col)\n        return result if result.is_valid() else Region(\n            first_row=unbound_region.first_row,\n            first_col=unbound_region.first_col\n        )\n\n\n@dataclass\nclass ChunkDataResponse:\n    cells: Union[None, List[List[Cell]]] = None\n    row_headers: Union[None, List[List[str]]] = None\n\n\n@dataclass(frozen=True)\nclass ChunkDataRequest:\n    with_cells: bool = True\n    with_row_headers: bool = True\n\n\n@dataclass(frozen=True)\nclass SortCriteria:\n    by_column: Union[None, List[int]] = None\n    ascending: Union[None, List[bool]] = None\n\n    def is_empty(self) -> bool:\n        return not self.by_column\n\n    def __eq__(self, other):\n        if isinstance(other, SortCriteria):\n            def _equals(s: Union[None, List[Any]], o: Union[None, List[Any]]) -> bool:\n                return (not s and not o) or s == o\n\n            return _equals(self.by_column, other.by_column) and _equals(self.ascending, other.ascending)\n        return False\n\n\n@dataclass(frozen=True)\nclass CreateTableSourceConfig:\n    temp_var_slot_id: Union[None, str] = None\n    data_source_transform_hint: Union[None, str] = None\n    previous_fingerprint: Union[None, str] = None\n    filter_eval_expr: Union[None, str] = None\n    filter_eval_expr_provide_frame: Union[None, bool] = None\n\n\nclass CreateTableSourceErrorKind(Enum):\n    EVAL_EXCEPTION = 0\n    RE_EVAL_DATA_SOURCE_OF_WRONG_TYPE = 1\n    UNSUPPORTED_DATA_SOURCE_TYPE = 2\n    INVALID_FINGERPRINT = 3\n    FILTER_FRAME_EVAL_FAILED = 4\n    FILTER_FRAME_OF_WRONG_TYPE = 5\n\n\n@dataclass(frozen=True)\nclass CreateTableSourceFailure:\n    error_kind: CreateTableSourceErrorKind\n    info: str\n\n\nclass TableSourceKind(Enum):\n    TABLE_SOURCE = 1\n    PATCHED_STYLER = 2\n\n\n@dataclass(frozen=True)\nclass CompletionVariant:\n    fq_type: str\n    value: str\n\n\n@dataclass(frozen=True)\nclass NestedCompletionVariant:\n    fq_type: str\n    children: List[CompletionVariant]\n"
        }
    }
}