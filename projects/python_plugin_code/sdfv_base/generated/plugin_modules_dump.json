{
    "cms_rendner_sdfv": {
        "base": {
            "constants": "\nCELL_MAX_STR_LEN = 200\nDESCRIBE_COL_MAX_STR_LEN = 120\n\n",
            "helpers": "\n\ndef truncate_str(s: str, max_length: int) -> str:\n    return s if len(s) <= max_length else s[:max_length - 1] + '\u2026'\n",
            "table_source": "import inspect\nimport typing\nfrom abc import ABC, abstractmethod\nfrom typing import Any, List, Optional, Union\n\nfrom cms_rendner_sdfv.base.transforms import to_json\nfrom cms_rendner_sdfv.base.types import CreateTableSourceConfig, CreateTableSourceFailure, Region, TableFrame, \\\n    TableFrameValidationResult, TableSourceKind, TableStructure\n\n\nclass AbstractVisibleFrame(ABC):\n    @property\n    @abstractmethod\n    def region(self) -> Region:\n        pass\n\n    def get_column_indices(self, part_start: int, max_columns: int) -> typing.List[int]:\n        end = min(part_start + max_columns, self.region.cols)\n        return [] if end <= part_start or part_start < 0 else list(range(part_start, end))\n\n\nVF = typing.TypeVar('VF', bound=AbstractVisibleFrame)\n\n\nclass AbstractTableFrameGenerator(ABC):\n    def __init__(self, visible_frame: VF):\n        self._visible_frame: VF = visible_frame\n        self._exclude_headers: bool = False\n\n    @abstractmethod\n    def generate(self,\n                 region: Region = None,\n                 exclude_row_header: bool = False,\n                 exclude_col_header: bool = False,\n                 ) -> TableFrame:\n        pass\n\n    def exclude_headers(self):\n        self._exclude_headers = True\n\n    def generate_by_combining_chunks(self,\n                                     rows_per_chunk: int,\n                                     cols_per_chunk: int,\n                                     region: Region = None,\n                                     ) -> TableFrame:\n        result = None\n\n        if region is None:\n            region = self._visible_frame.region\n\n        for local_chunk in region.iterate_local_chunkwise(rows_per_chunk, cols_per_chunk):\n\n            chunk_contains_elements_of_first_row = local_chunk.first_row == 0\n            chunk_contains_row_start_element = local_chunk.first_col == 0\n\n            chunk_table = self.generate(\n                region=local_chunk.translate(region.first_row, region.first_col),\n                exclude_row_header=not chunk_contains_row_start_element,\n                exclude_col_header=not chunk_contains_elements_of_first_row,\n            )\n\n            if result is None:\n                result = chunk_table\n            else:\n                if chunk_contains_elements_of_first_row:\n                    result.columns.extend(chunk_table.columns)\n                if chunk_contains_row_start_element:\n                    if result.index_labels is not None:\n                        assert chunk_table.index_labels is not None\n                        result.index_labels.extend(chunk_table.index_labels)\n                    result.cells.extend(chunk_table.cells)\n                else:\n                    for i, row in enumerate(chunk_table.cells):\n                        result.cells[i + local_chunk.first_row].extend(row)\n\n        return result if result is not None else TableFrame(index_labels=[], columns=[], legend=None, cells=[])\n\n\nclass TableFrameValidator:\n    def __init__(self, frame_region: Region, generator: AbstractTableFrameGenerator):\n        self.__frame_region = frame_region\n        self.__generator = generator\n\n    def validate(self,\n                 rows_per_chunk: int,\n                 cols_per_chunk: int,\n                 region: Region = None,\n                 ) -> TableFrameValidationResult:\n        if region is None:\n            region = self.__frame_region\n        else:\n            region = self.__frame_region.get_bounded_region(region)\n\n        if region.is_empty():\n            return TableFrameValidationResult('', '', True)\n        combined_table = self.__generator.generate_by_combining_chunks(rows_per_chunk, cols_per_chunk, region)\n        expected_table = self.__generator.generate(region)\n        combined_json = to_json(combined_table, indent=2)\n        expected_json = to_json(expected_table, indent=2)\n        return TableFrameValidationResult(combined_json, expected_json, combined_json == expected_json)\n\n\nclass AbstractTableSourceContext(ABC):\n    def set_sort_criteria(self, sort_by_column_index: Optional[List[int]], sort_ascending: Optional[List[bool]]):\n        pass\n\n    @property\n    @abstractmethod\n    def visible_frame(self) -> AbstractVisibleFrame:\n        pass\n\n    @abstractmethod\n    def get_table_structure(self, fingerprint: str) -> TableStructure:\n        pass\n\n    @abstractmethod\n    def get_table_frame_generator(self) -> AbstractTableFrameGenerator:\n        pass\n\n    def get_table_frame_validator(self) -> TableFrameValidator:\n        generator = self.get_table_frame_generator()\n        generator.exclude_headers()\n        return TableFrameValidator(self.visible_frame.region, generator)\n\n\nT = typing.TypeVar('T', bound=AbstractTableSourceContext)\n\n\nclass AbstractTableSource(ABC):\n    def __init__(self, kind: TableSourceKind, context: T, fingerprint: str):\n        self._kind = kind\n        self._context = context\n        self._fingerprint = fingerprint\n\n    def get_kind(self) -> TableSourceKind:\n        return self._kind\n\n    @staticmethod\n    def jsonify(data: Any) -> str:\n        return to_json(data)\n\n    def get_org_indices_of_visible_columns(self, part_start: int, max_columns: int) -> List[int]:\n        return self._context.visible_frame.get_column_indices(part_start, max_columns)\n\n    def get_table_structure(self) -> TableStructure:\n        return self._context.get_table_structure(self._fingerprint)\n\n    def set_sort_criteria(self,\n                          by_column_index: Optional[List[int]] = None,\n                          ascending: Optional[List[bool]] = None,\n                          ):\n        self._context.set_sort_criteria(by_column_index, ascending)\n\n    def compute_chunk_table_frame(self,\n                                  first_row: int,\n                                  first_col: int,\n                                  rows: int,\n                                  cols: int,\n                                  exclude_row_header: bool = False,\n                                  exclude_col_header: bool = False\n                                  ) -> TableFrame:\n        return self._context.get_table_frame_generator().generate(\n            region=Region(first_row, first_col, rows, cols),\n            exclude_row_header=exclude_row_header,\n            exclude_col_header=exclude_col_header,\n        )\n\n\nTEMP_VARS = {}\n\n\nclass AbstractTableSourceFactory(ABC):\n    def create(self,\n               data_source: Any,\n               create_config: Union[CreateTableSourceConfig, dict] = None,\n               ) -> Union[AbstractTableSource, str]:\n        try:\n            config = create_config\n\n            if isinstance(config, dict):\n                config = CreateTableSourceConfig(**config)\n            elif config is None:\n                config = CreateTableSourceConfig()\n\n            caller_globals = {}\n            caller_frame = inspect.currentframe().f_back\n            if caller_frame:\n                caller_globals.update(caller_frame.f_globals)\n                caller_globals.update(caller_frame.f_locals)\n\n            table_source = self._create_internal(data_source, config, caller_globals)\n            if not isinstance(table_source, AbstractTableSource):\n                if isinstance(table_source, CreateTableSourceFailure):\n                    return to_json(table_source)\n                expected_type = type(AbstractTableSource)\n                actual_type = type(table_source)\n                raise ValueError(\n                    f\"Created table_source is of type: {actual_type}, expected: ${expected_type}.\"\n                )\n\n            if config.temp_var_slot_id is not None:\n                TEMP_VARS[config.temp_var_slot_id] = table_source\n\n            return table_source\n        except Exception as e:\n            return to_json(CreateTableSourceFailure(error_kind=\"EVAL_EXCEPTION\", info=repr(e)))\n\n    @abstractmethod\n    def _create_internal(self,\n                         data_source: Any,\n                         config: CreateTableSourceConfig,\n                         caller_globals: dict,\n                         ) -> Union[AbstractTableSource, CreateTableSourceFailure]:\n        pass\n",
            "transforms": "import json\nfrom dataclasses import asdict, is_dataclass\nfrom typing import Any\n\n\nclass _CustomJSONEncoder(json.JSONEncoder):\n    def default(self, obj: Any):\n        if is_dataclass(obj):\n            return asdict(obj)\n        return str(obj)\n\n\ndef to_json(data: Any, **kwargs) -> str:\n    return json.dumps(data, **kwargs, cls=_CustomJSONEncoder)\n",
            "types": "import dataclasses\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Tuple, Union\n\n\n@dataclass(frozen=True)\nclass TableStructure:\n    org_rows_count: int\n    org_columns_count: int\n    rows_count: int\n    columns_count: int\n    fingerprint: str\n\n\n@dataclass(frozen=True)\nclass TableFrameCell:\n    value: str\n    css: Dict[str, str] = None\n\n\n@dataclass(frozen=True)\nclass TableFrameColumn:\n    dtype: str\n    labels: List[str]\n    describe: Dict[str, str] = None\n\n\n@dataclass(frozen=True)\nclass TableFrameLegend:\n    index: List[str]\n    column: List[str]\n\n\n@dataclass(frozen=True)\nclass TableFrame:\n    index_labels: Union[None, List[List[str]]]\n    columns: Union[None, List[TableFrameColumn]]\n    cells: List[List[TableFrameCell]]\n    legend: Union[None, TableFrameLegend] = None\n\n\n@dataclass(frozen=True)\nclass TableFrameValidationResult:\n    actual: str\n    expected: str\n    is_equal: bool\n\n\n@dataclass(frozen=True)\nclass Region:\n    first_row: int = 0\n    first_col: int = 0\n    rows: int = 0\n    cols: int = 0\n\n    @classmethod\n    def with_frame_shape(cls, shape: Tuple[int, int]):\n        return cls(rows=shape[0], cols=shape[1])\n\n    def translate(self, row_offset: int, col_offset: int):\n        return dataclasses.replace(self, first_row=self.first_row + row_offset, first_col=self.first_col + col_offset)\n\n    def is_empty(self) -> bool:\n        return self.rows == 0 or self.cols == 0\n\n    def is_valid(self) -> bool:\n        return self.first_row >= 0 and self.first_col >= 0 and self.rows >= 0 and self.cols >= 0\n\n    @property\n    def frame_shape(self) -> Tuple[int, int]:\n        return self.rows, self.cols\n\n    def iterate_local_chunkwise(self, rows_per_chunk: int, cols_per_chunk: int):\n        if not self.is_valid():\n            raise ValueError(\"Invalid Regions can't be iterated chunkwise.\")\n        if rows_per_chunk <= 0 or cols_per_chunk <= 0:\n            raise ValueError(f\"rows_per_chunk ({rows_per_chunk}) and cols_per_chunk ({cols_per_chunk}) must be > 0\")\n\n        rows_processed = 0\n        while rows_processed < self.rows:\n            rows = min(rows_per_chunk, self.rows - rows_processed)\n            cols_in_row_processed = 0\n            while cols_in_row_processed < self.cols:\n                cols = min(cols_per_chunk, self.cols - cols_in_row_processed)\n\n                yield Region(rows_processed, cols_in_row_processed, rows, cols)\n\n                cols_in_row_processed += cols\n            rows_processed += rows\n\n    def get_bounded_region(self, region_to_bound: 'Region') -> 'Region':\n        if not self.is_valid():\n            raise ValueError(\"No valid bounds.\")\n        if not region_to_bound.is_valid():\n            raise ValueError(\"Can't compute a bounded region against an invalid Region.\")\n        first_row = max(region_to_bound.first_row, self.first_row)\n        first_col = max(region_to_bound.first_col, self.first_col)\n        last_row = min(region_to_bound.first_row + region_to_bound.rows, self.first_row + self.rows)\n        last_col = min(region_to_bound.first_col + region_to_bound.cols, self.first_col + self.cols)\n        result = Region(first_row, first_col, last_row - first_row, last_col - first_col)\n        return result if result.is_valid() else Region(\n            first_row=region_to_bound.first_row,\n            first_col=region_to_bound.first_col\n        )\n\n\n@dataclass(frozen=True)\nclass SortCriteria:\n    by_column: Optional[List[int]] = None\n    ascending: Optional[List[bool]] = None\n\n    def is_empty(self) -> bool:\n        return not self.by_column\n\n    def __eq__(self, other):\n        if isinstance(other, SortCriteria):\n            def _equals(s: Optional[List[Any]], o: Optional[List[Any]]) -> bool:\n                return (not s and not o) or s == o\n\n            return _equals(self.by_column, other.by_column) and _equals(self.ascending, other.ascending)\n        return False\n\n\n@dataclass(frozen=True)\nclass CreateTableSourceConfig:\n    temp_var_slot_id: Optional[str] = None\n    data_source_transform_hint: Optional[str] = None\n    previous_fingerprint: Optional[str] = None\n    filter_eval_expr: Optional[str] = None\n    filter_eval_expr_provide_frame: Optional[bool] = None\n\n\n@dataclass(frozen=True)\nclass CreateTableSourceFailure:\n    error_kind: str\n    info: str\n\n\nclass TableSourceKind(Enum):\n    TABLE_SOURCE = 1\n    PATCHED_STYLER = 2\n\n"
        }
    }
}