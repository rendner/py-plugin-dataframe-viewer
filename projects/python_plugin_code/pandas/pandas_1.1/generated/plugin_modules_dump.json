{
    "cms_rendner_sdfv": {
        "pandas": {
            "frame": {
                "frame_context": "from typing import List, Any\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableFrameGenerator\nfrom cms_rendner_sdfv.base.types import Region\nfrom cms_rendner_sdfv.pandas.shared.pandas_table_source_context import PandasTableSourceContext\nfrom cms_rendner_sdfv.pandas.shared.visible_frame import VisibleFrame\n\n\nclass Chunk:\n    def __init__(self, visible_frame: VisibleFrame, region: Region):\n        self.__visible_frame = visible_frame\n        self.region = region\n\n    def cell_value_at(self, row: int, col: int):\n        return self.__visible_frame.cell_value_at(\n            self.region.first_row + row,\n            self.region.first_col + col,\n        )\n\n    def col_labels_at(self, col: int) -> List[Any]:\n        labels = self.__visible_frame.column_at(self.region.first_col + col)\n        if not isinstance(labels, tuple):\n            labels = [labels]\n        return labels\n\n    def row_labels_at(self, row: int) -> List[Any]:\n        labels = self.__visible_frame.index_at(self.region.first_row + row)\n        if not isinstance(labels, tuple):\n            labels = [labels]\n        return labels\n\n\nclass FrameContext(PandasTableSourceContext):\n    def get_table_frame_generator(self) -> AbstractTableFrameGenerator:\n        from cms_rendner_sdfv.pandas.frame.table_frame_generator import TableFrameGenerator\n        return TableFrameGenerator(self)\n\n    def get_chunk(self, region: Region) -> Chunk:\n        return Chunk(self.visible_frame, self.visible_frame.region.get_bounded_region(region))\n",
                "table_frame_generator": "from typing import Any, Callable, List, Optional\n\nfrom pandas import get_option\nfrom pandas.core.dtypes.common import (\n    is_complex,\n    is_float,\n    is_integer,\n)\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableFrameGenerator\nfrom cms_rendner_sdfv.base.types import Region, TableFrame, TableFrameCell, TableFrameColumn, TableFrameLegend\nfrom cms_rendner_sdfv.pandas.frame.frame_context import Chunk, FrameContext\nfrom cms_rendner_sdfv.pandas.shared.value_formatter import ValueFormatter\n\n\nclass _ValueFormatter(ValueFormatter):\n    def __init__(self):\n        self.__precision = get_option(\"display.precision\")\n        self.__float_format: Optional[Callable] = get_option(\"display.float_format\")\n\n    def _default_format(self, x: Any, fallback_formatter) -> Any:\n        if is_float(x) or is_complex(x):\n            if callable(self.__float_format):\n                return self.__float_format(x)\n            return f\"{x:.{self.__precision}f}\"\n        elif is_integer(x):\n            return str(x)\n\n        return fallback_formatter(x)\n\n    def format_column(self, value: Any) -> str:\n        return self._default_format(value, super().format_column)\n\n    def format_index(self, value: Any) -> str:\n        return self._default_format(value, super().format_index)\n\n    def format_cell(self, value: Any) -> str:\n        return self._default_format(value, super().format_cell)\n\n\nclass TableFrameGenerator(AbstractTableFrameGenerator):\n    def __init__(self, context: FrameContext):\n        super().__init__(context.visible_frame)\n        self.__context: FrameContext = context\n\n    def generate(self,\n                 region: Region = None,\n                 exclude_row_header: bool = False,\n                 exclude_col_header: bool = False,\n                 ) -> TableFrame:\n        chunk = self.__context.get_chunk(region)\n        formatter = _ValueFormatter()\n\n        return TableFrame(\n            index_labels=[] if exclude_row_header else self._extract_index_header_labels(chunk, formatter),\n            columns=[] if exclude_col_header else self._extract_columns(chunk, formatter),\n            legend=None if exclude_col_header and exclude_row_header else self._extract_legend_label(formatter),\n            cells=self._extract_cells(chunk, formatter),\n        )\n\n    def _extract_columns(self, chunk: Chunk, formatter: ValueFormatter) -> List[TableFrameColumn]:\n        result: List[TableFrameColumn] = []\n\n        for c in range(chunk.region.cols):\n            labels = [formatter.format_column(lbl) for lbl in chunk.col_labels_at(c)]\n            info = self._visible_frame.get_column_info(chunk.region.first_col + c)\n            result.append(TableFrameColumn(dtype=str(info.dtype), labels=labels, describe=info.describe()))\n\n        return result\n\n    @staticmethod\n    def _extract_index_header_labels(chunk: Chunk, formatter: ValueFormatter) -> List[List[str]]:\n        result: List[List[str]] = []\n\n        for r in range(chunk.region.rows):\n            result.append([formatter.format_index(lbl) for lbl in chunk.row_labels_at(r)])\n\n        return result\n\n    @staticmethod\n    def _extract_cells(chunk: Chunk, formatter: ValueFormatter) -> List[List[TableFrameCell]]:\n        result: List[List[TableFrameCell]] = []\n\n        col_range = range(chunk.region.cols)\n        for r in range(chunk.region.rows):\n            result.append([TableFrameCell(value=formatter.format_cell(chunk.cell_value_at(r, c))) for c in col_range])\n\n        return result\n\n    def _extract_legend_label(self, formatter: ValueFormatter) -> TableFrameLegend:\n        index_legend = [formatter.format_index(n) for n in self._visible_frame.index_names if n is not None]\n        column_legend = [formatter.format_index(n) for n in self._visible_frame.column_names if n is not None]\n        return TableFrameLegend(index=index_legend, column=column_legend) if index_legend or column_legend else None\n",
                "table_source": "from cms_rendner_sdfv.base.table_source import AbstractTableSource\nfrom cms_rendner_sdfv.base.types import TableSourceKind\nfrom cms_rendner_sdfv.pandas.frame.frame_context import FrameContext\n\n\nclass TableSource(AbstractTableSource):\n    def __init__(self, context: FrameContext, fingerprint: str):\n        super().__init__(TableSourceKind.TABLE_SOURCE, context, fingerprint)\n",
                "table_source_factory": "from typing import Any, Union\n\nfrom pandas import DataFrame\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableSource, AbstractTableSourceFactory\nfrom cms_rendner_sdfv.base.types import CreateTableSourceConfig, CreateTableSourceFailure\nfrom cms_rendner_sdfv.pandas.frame.table_source import TableSource\nfrom cms_rendner_sdfv.pandas.frame.frame_context import FrameContext\nfrom cms_rendner_sdfv.pandas.shared.create_fingerprint import create_fingerprint\nfrom cms_rendner_sdfv.pandas.shared.types import FilterCriteria\n\n\nclass TableSourceFactory(AbstractTableSourceFactory):\n\n    def _create_internal(self,\n                         data_source: Any,\n                         config: CreateTableSourceConfig,\n                         caller_globals: dict,\n                         ) -> Union[AbstractTableSource, CreateTableSourceFailure]:\n        ds_frame = None\n        if isinstance(data_source, dict):\n            if config.data_source_transform_hint == \"DictKeysAsRows\":\n                ds_frame = DataFrame.from_dict(data_source, orient='index')\n            else:\n                try:\n                    ds_frame = DataFrame.from_dict(data_source, orient='columns')\n                except ValueError as e:\n                    if str(e) == \"If using all scalar values, you must pass an index\":\n                        ds_frame = DataFrame(data_source, index=[0])\n        elif isinstance(data_source, DataFrame):\n            ds_frame = data_source\n        else:\n            return CreateTableSourceFailure(error_kind=\"UNSUPPORTED_DATA_SOURCE_TYPE\", info=str(type(data_source)))\n\n        pre_fingerprint = config.previous_fingerprint\n        cur_fingerprint = create_fingerprint(ds_frame, data_source)\n        if pre_fingerprint is not None and pre_fingerprint != cur_fingerprint:\n            return CreateTableSourceFailure(error_kind=\"INVALID_FINGERPRINT\", info=cur_fingerprint)\n\n        filter_frame = None\n        filter_eval_expr = config.filter_eval_expr\n        if filter_eval_expr is not None and filter_eval_expr != \"\":\n            try:\n                if config.filter_eval_expr_provide_frame:\n                    caller_globals[\"_df\"] = ds_frame\n                filter_frame = eval(filter_eval_expr, caller_globals)\n            except Exception as e:\n                return CreateTableSourceFailure(error_kind=\"FILTER_FRAME_EVAL_FAILED\", info=repr(e))\n\n            if not isinstance(filter_frame, DataFrame):\n                return CreateTableSourceFailure(error_kind=\"FILTER_FRAME_OF_WRONG_TYPE\", info=str(type(filter_frame)))\n\n        return TableSource(\n            FrameContext(ds_frame, FilterCriteria.from_frame(filter_frame)),\n            fingerprint=cur_fingerprint,\n        )\n"
            },
            "shared": {
                "create_fingerprint": "from hashlib import blake2b\nfrom typing import Any\n\nfrom pandas import DataFrame\n\n\ndef create_fingerprint(frame: DataFrame, org_data_source: Any = None) -> str:\n    fingerprint_input = [\n        id(org_data_source if org_data_source is not None else frame),\n        frame.shape,\n        frame.index[:60],\n        frame.dtypes[:60]\n    ]\n    return blake2b('-'.join(str(x) for x in fingerprint_input).encode(), digest_size=16).hexdigest()\n",
                "pandas_table_source_context": "from abc import ABC\nfrom typing import List, Optional\n\nfrom pandas import DataFrame\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableSourceContext\nfrom cms_rendner_sdfv.base.types import SortCriteria, TableStructure\nfrom cms_rendner_sdfv.pandas.shared.types import FilterCriteria\nfrom cms_rendner_sdfv.pandas.shared.visible_frame import VisibleFrame, MappedVisibleFrame\n\n\nclass PandasTableSourceContext(AbstractTableSourceContext, ABC):\n    def __init__(self, source_frame: DataFrame, filter_criteria: Optional[FilterCriteria] = None):\n        self.__source_frame = source_frame\n        self.__sort_criteria: SortCriteria = SortCriteria()\n        self.__filter_criteria: FilterCriteria = filter_criteria if filter_criteria is not None else FilterCriteria()\n        self.__visible_frame: VisibleFrame = self.__recompute_visible_frame()\n\n    @property\n    def visible_frame(self) -> VisibleFrame:\n        return self.__visible_frame\n\n    def get_table_structure(self, fingerprint: str) -> TableStructure:\n        rows_count = self.__visible_frame.region.rows\n        columns_count = self.__visible_frame.region.cols\n        if rows_count == 0 or columns_count == 0:\n            rows_count = columns_count = 0\n        return TableStructure(\n            org_rows_count=len(self.__source_frame.index),\n            org_columns_count=len(self.__source_frame.columns),\n            rows_count=rows_count,\n            columns_count=columns_count,\n            fingerprint=fingerprint,\n        )\n\n    def set_sort_criteria(self, sort_by_column_index: Optional[List[int]], sort_ascending: Optional[List[bool]]):\n        new_sort_criteria = SortCriteria(sort_by_column_index, sort_ascending)\n        if new_sort_criteria != self.__sort_criteria:\n            self.__sort_criteria = new_sort_criteria\n            self.__visible_frame = self.__recompute_visible_frame()\n\n    def _get_initial_visible_frame_indexes(self):\n        return self.__source_frame.index, self.__source_frame.columns\n\n    def __recompute_visible_frame(self) -> VisibleFrame:\n        index, columns = self._get_initial_visible_frame_indexes()\n\n        if self.__filter_criteria.index is not None:\n            index = index.intersection(self.__filter_criteria.index)\n\n        if self.__filter_criteria.columns is not None:\n            columns = columns.intersection(self.__filter_criteria.columns)\n\n        if not self.__sort_criteria.is_empty():\n            sc = self.__sort_criteria\n            frame = self.__source_frame.loc[index, columns]\n            frame = frame.sort_values(\n                by=[frame.columns[i] for i in sc.by_column],\n                ascending=True if sc.ascending is None or len(sc.ascending) == 0 else sc.ascending,\n            )\n            index = frame.index\n\n        if index is self.__source_frame.index and columns is self.__source_frame.columns:\n            return VisibleFrame(self.__source_frame)\n\n        return MappedVisibleFrame(\n            self.__source_frame,\n            self.__source_frame.index.get_indexer_for(index),\n            self.__source_frame.columns.get_indexer_for(columns),\n        )\n",
                "types": "from dataclasses import dataclass\nfrom typing import Optional\n\nfrom pandas import DataFrame, Index\n\n\n@dataclass(frozen=True)\nclass FilterCriteria:\n    index: Optional[Index] = None\n    columns: Optional[Index] = None\n\n    @staticmethod\n    def from_frame(frame: Optional[DataFrame]):\n        return None if frame is None else FilterCriteria(frame.index, frame.columns)\n\n    def is_empty(self) -> bool:\n        return self.index is None and self.columns is None\n\n    def __eq__(self, other):\n        if isinstance(other, FilterCriteria):\n            def _equals(s: Optional[Index], o: Optional[Index]) -> bool:\n                if s is None and o is None:\n                    return True\n                return s is not None and o is not None and s.equals(o)\n\n            return _equals(self.columns, other.columns) and _equals(self.index, other.index)\n        return False\n",
                "value_formatter": "from typing import Any\n\nfrom pandas.errors import OptionError\nfrom pandas.io.formats.printing import pprint_thing, get_option\n\nfrom cms_rendner_sdfv.base.constants import CELL_MAX_STR_LEN\nfrom cms_rendner_sdfv.base.helpers import truncate_str\n\n\nclass ValueFormatter:\n\n    @staticmethod\n    def format_column(value: Any) -> str:\n        return value if isinstance(value, str) else pprint_thing(value)\n\n    @staticmethod\n    def format_index(value: Any) -> str:\n        return value if isinstance(value, str) else pprint_thing(value)\n\n    @staticmethod\n    def format_cell(value: Any) -> str:\n        v = value\n        if not isinstance(v, str):\n            max_seq_items = None\n            try:\n                max_seq_items = get_option(\"display.max_seq_items\", True)\n            except OptionError:\n                pass\n            v = pprint_thing(v, max_seq_items=max_seq_items or 42)\n        return truncate_str(v, CELL_MAX_STR_LEN)\n",
                "visible_frame": "from typing import List, Tuple, Dict\n\nimport numpy as np\nfrom pandas import DataFrame, Series\n\nfrom cms_rendner_sdfv.base.constants import DESCRIBE_COL_MAX_STR_LEN\nfrom cms_rendner_sdfv.base.helpers import truncate_str\nfrom cms_rendner_sdfv.base.table_source import AbstractVisibleFrame\nfrom cms_rendner_sdfv.base.types import Region\n\n\nclass VisibleColumnInfo:\n    def __init__(self, column: Series):\n        self.__column = column\n\n    @property\n    def dtype(self):\n        return self.__column.dtype\n\n    def describe(self) -> Dict[str, str]:\n        try:\n            return {\n                k: truncate_str(str(v), DESCRIBE_COL_MAX_STR_LEN)\n                for k, v in self.__column.describe().to_dict().items()\n            }\n        except TypeError as e:\n            return {'error': str(e)}\n\n\nclass VisibleFrame(AbstractVisibleFrame):\n    def __init__(self, source_frame: DataFrame):\n        super().__init__(Region(0, 0, len(source_frame.index), len(source_frame.columns)))\n        self._source_frame = source_frame\n\n    @property\n    def index_names(self) -> list:\n        return self._source_frame.index.names\n\n    @property\n    def column_names(self) -> list:\n        return self._source_frame.columns.names\n\n    def cell_value_at(self, row: int, col: int):\n        return self._source_frame.iat[row, col]\n\n    def column_at(self, col: int):\n        return self._source_frame.columns[col]\n\n    def index_at(self, row: int):\n        return self._source_frame.index[row]\n\n    def get_column_info(self, col: int) -> VisibleColumnInfo:\n        return VisibleColumnInfo(self._source_frame.iloc[:, col])\n\n    def to_frame(self, region: Region) -> DataFrame:\n        r = self.region.get_bounded_region(region)\n        return self._source_frame.iloc[\n               r.first_row:r.first_row + r.rows,\n               r.first_col:r.first_col + r.cols,\n               ]\n\n    def to_source_frame_cell_coordinates(self, row: int, col: int):\n        return row, col\n\n    def get_column_indices(self, part_start: int, max_columns: int):\n        r = self.region.get_bounded_region(Region(part_start, 0, max_columns, 0))\n        return list(range(r.first_row, r.first_row + r.rows))\n\n\nclass MappedVisibleFrame(VisibleFrame):\n    def __init__(self, source_frame: DataFrame, visible_rows: np.ndarray, visible_cols: np.ndarray):\n        super().__init__(source_frame)\n        self.region = Region(0, 0, len(visible_rows), len(visible_cols))\n        self.__i_rows = visible_rows\n        self.__i_cols = visible_cols\n\n    def cell_value_at(self, row: int, col: int):\n        return self._source_frame.iat[self.__i_rows[row], self.__i_cols[col]]\n\n    def column_at(self, col: int):\n        return self._source_frame.columns[self.__i_cols[col]]\n\n    def index_at(self, row: int):\n        return self._source_frame.index[self.__i_rows[row]]\n\n    def get_column_info(self, col: int) -> VisibleColumnInfo:\n        return VisibleColumnInfo(self._source_frame.iloc[self.__i_rows, self.__i_cols[col]])\n\n    def to_frame(self, region: Region) -> DataFrame:\n        r = self.region.get_bounded_region(region)\n        i_rows = self.__i_rows[r.first_row:r.first_row + r.rows]\n        i_cols = self.__i_cols[r.first_col:r.first_col + r.cols]\n        return self._source_frame.iloc[i_rows, i_cols]\n\n    def to_source_frame_cell_coordinates(self, row: int, col: int) -> Tuple[int, int]:\n        return self.__i_rows[row], self.__i_cols[col]\n\n    def get_column_indices(self, part_start: int, max_columns: int) -> List[int]:\n        return list(self.__i_cols[part_start:part_start + max_columns])\n"
            },
            "styler": {
                "apply_map_patcher": "from typing import Optional\n\nfrom pandas import DataFrame\n\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\n\n\nclass ApplyMapPatcher(TodoPatcher):\n\n    def __init__(self, org_frame: DataFrame, todo: StylerTodo):\n        super().__init__(org_frame, todo)\n\n    def create_patched_todo(self, chunk: DataFrame) -> Optional[StylerTodo]:\n        return self._todo_builder(chunk).build()\n",
                "apply_patcher": "from typing import Optional, Union\n\nfrom pandas import DataFrame, Series\n\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\n\n\nclass ApplyPatcher(TodoPatcher):\n\n    def __init__(self, org_frame: DataFrame, todo: StylerTodo):\n        super().__init__(org_frame, todo)\n\n    def create_patched_todo(self, chunk: DataFrame) -> Optional[StylerTodo]:\n        builder = self._todo_builder(chunk)\n        if self.todo.should_provide_chunk_parent():\n            builder.with_style_func(self._wrap_with_chunk_parent_provider(self._styling_func))\n        else:\n            builder.with_style_func(self._styling_func)\n        return builder.build()\n\n    def _styling_func(self, chunk_or_series_from_chunk: Union[DataFrame, Series], **kwargs):\n        if chunk_or_series_from_chunk.empty:\n            return chunk_or_series_from_chunk\n        return self.todo.apply_args.style_func(chunk_or_series_from_chunk, **kwargs)\n",
                "background_gradient_patcher": "from typing import Optional, Union, Dict, Tuple\n\nimport numpy as np\nfrom pandas import DataFrame, Series\n\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\n\n\nclass BackgroundGradientPatcher(TodoPatcher):\n\n    def __init__(self, org_frame: DataFrame, todo: StylerTodo):\n        super().__init__(org_frame, todo)\n        self.__computed_params_cache: Dict[str, Tuple[float, float]] = {}\n\n    def create_patched_todo(self, chunk: DataFrame) -> Optional[StylerTodo]:\n        return self._todo_builder(chunk) \\\n            .with_style_func(self._wrap_with_chunk_parent_provider(self._styling_func)) \\\n            .build()\n\n    def _styling_func(self,\n                      chunk_or_series_from_chunk: Union[DataFrame, Series],\n                      chunk_parent: Union[DataFrame, Series],\n                      **kwargs,\n                      ):\n        if chunk_or_series_from_chunk.empty:\n            return chunk_or_series_from_chunk\n\n        vmin, vmax = self.__get_or_compute_parameters(chunk_parent, kwargs)\n\n        return self.todo.apply_args.style_func(\n            chunk_or_series_from_chunk,\n            **dict(kwargs, vmin=vmin, vmax=vmax),\n        )\n\n    def __get_or_compute_parameters(self,\n                                    chunk_parent: Union[DataFrame, Series],\n                                    kwargs: Dict,\n                                    ) -> Tuple[float, float]:\n        cache_key = \"frame\"\n        if isinstance(chunk_parent, Series):\n            cache_key = chunk_parent.name\n\n        params = self.__computed_params_cache.get(cache_key, None)\n\n        if params is None:\n            params = self.__compute_params(chunk_parent, kwargs)\n            self.__computed_params_cache[cache_key] = params\n\n        return params\n\n    @staticmethod\n    def __compute_params(chunk_parent: Union[DataFrame, Series], kwargs: Dict) -> Tuple[float, float]:\n        vmin = kwargs.get(\"vmin\", None)\n        vmax = kwargs.get(\"vmax\", None)\n\n        if vmin is None or vmax is None:\n            n = chunk_parent.to_numpy()\n            if vmin is None:\n                vmin = np.nanmin(n)\n            if vmax is None:\n                vmax = np.nanmax(n)\n\n        return vmin, vmax\n",
                "highlight_extrema_patcher": "from typing import Optional, Union\n\nimport numpy as np\nfrom pandas import DataFrame, Series\n\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\n\n\nclass HighlightExtremaPatcher(TodoPatcher):\n\n    def __init__(self, org_frame: DataFrame, todo: StylerTodo):\n        super().__init__(org_frame, todo)\n        self.__max: bool = todo.style_func_kwargs.get('max_', False)\n        self.__attribute: str = f\"background-color: {todo.style_func_kwargs.get('color', 'yellow')}\"\n        self.__computed_values_cache = {}\n\n    def create_patched_todo(self, chunk: DataFrame) -> Optional[StylerTodo]:\n        return self._todo_builder(chunk) \\\n            .with_style_func_kwargs({}) \\\n            .with_style_func(self._wrap_with_chunk_parent_provider(self._styling_func)) \\\n            .build()\n\n    def _styling_func(self,\n                      chunk_or_series_from_chunk: Union[DataFrame, Series],\n                      chunk_parent: Union[DataFrame, Series],\n                      ):\n        if chunk_or_series_from_chunk.empty:\n            return chunk_or_series_from_chunk\n\n        value = self.__get_or_compute_extrema(chunk_parent)\n\n        if self.__max:\n            extrema = chunk_or_series_from_chunk == value\n        else:\n            extrema = chunk_or_series_from_chunk == value\n\n        if chunk_or_series_from_chunk.ndim == 1:\n            return [self.__attribute if v else \"\" for v in extrema]\n        else:\n            return DataFrame(\n                np.where(extrema, self.__attribute, \"\"),\n                index=chunk_or_series_from_chunk.index,\n                columns=chunk_or_series_from_chunk.columns\n            )\n\n    def __get_or_compute_extrema(self, chunk_parent: Union[DataFrame, Series]):\n        cache_key = \"frame\"\n        if isinstance(chunk_parent, Series):\n            cache_key = chunk_parent.name\n\n        value = self.__computed_values_cache.get(cache_key, None)\n\n        if value is None:\n            if self.__max:\n                value = np.nanmax(chunk_parent.to_numpy())\n            else:\n                value = np.nanmin(chunk_parent.to_numpy())\n\n            self.__computed_values_cache[cache_key] = value\n\n        return value\n",
                "patched_styler": "from typing import List, Optional\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableSource\nfrom cms_rendner_sdfv.base.types import Region, TableSourceKind\nfrom cms_rendner_sdfv.pandas.styler.patched_styler_context import PatchedStylerContext\nfrom cms_rendner_sdfv.pandas.styler.style_functions_validator import StyleFunctionsValidator\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\nfrom cms_rendner_sdfv.pandas.styler.types import ValidatedTableFrame\n\n\nclass PatchedStyler(AbstractTableSource):\n    def __init__(self, context: PatchedStylerContext, fingerprint: str):\n        super().__init__(TableSourceKind.PATCHED_STYLER, context, fingerprint)\n        self.__patchers_to_skip_in_validation: List[TodoPatcher] = []\n\n    def validate_and_compute_chunk_table_frame(self,\n                                               first_row: int,\n                                               first_col: int,\n                                               rows: int,\n                                               cols: int,\n                                               exclude_row_header: bool = False,\n                                               exclude_col_header: bool = False,\n                                               ) -> ValidatedTableFrame:\n        region = Region(first_row, first_col, rows, cols)\n        validator = StyleFunctionsValidator(\n            self._context,\n            self.__patchers_to_skip_in_validation,\n        )\n        frame = ValidatedTableFrame(\n            frame=self._context.get_table_frame_generator().generate(\n                region=region,\n                exclude_row_header=exclude_row_header,\n                exclude_col_header=exclude_col_header,\n            ),\n            problems=validator.validate(region),\n        )\n        self.__patchers_to_skip_in_validation.extend(validator.failed_patchers)\n        return frame\n\n    def set_sort_criteria(self,\n                          by_column_index: Optional[List[int]] = None,\n                          ascending: Optional[List[bool]] = None,\n                          ):\n        self._context.set_sort_criteria(by_column_index, ascending)\n",
                "patched_styler_context": "from typing import List, Optional\n\nfrom pandas import Index, DataFrame\nfrom pandas.io.formats.style import Styler\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableFrameGenerator\nfrom cms_rendner_sdfv.base.types import Region\nfrom cms_rendner_sdfv.pandas.shared.pandas_table_source_context import PandasTableSourceContext\nfrom cms_rendner_sdfv.pandas.shared.types import FilterCriteria\nfrom cms_rendner_sdfv.pandas.shared.visible_frame import VisibleFrame\nfrom cms_rendner_sdfv.pandas.styler.apply_map_patcher import ApplyMapPatcher\nfrom cms_rendner_sdfv.pandas.styler.apply_patcher import ApplyPatcher\nfrom cms_rendner_sdfv.pandas.styler.background_gradient_patcher import BackgroundGradientPatcher\nfrom cms_rendner_sdfv.pandas.styler.highlight_extrema_patcher import HighlightExtremaPatcher\nfrom cms_rendner_sdfv.pandas.styler.style_function_name_resolver import StyleFunctionNameResolver\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\n\n\nclass StyledChunk:\n    def __init__(self, styler: Styler, visible_frame: VisibleFrame, region: Region):\n        self.__styler = styler\n        self.__visible_frame = visible_frame\n        self.region = region\n\n    @property\n    def row_labels_hidden(self):\n        return self.__styler.hidden_index\n\n    def cell_css_at(self, row: int, col: int):\n        return self.__styler.ctx[(row, col)]\n\n    def row_labels_at(self, row: int):\n        labels = self.__visible_frame.index_at(self.region.first_row + row)\n        if not isinstance(labels, tuple):\n            labels = [labels]\n        return labels\n\n    def col_labels_at(self, col: int):\n        labels = self.__visible_frame.column_at(self.region.first_col + col)\n        if not isinstance(labels, tuple):\n            labels = [labels]\n        return labels\n\n    def cell_value_at(self, row: int, col: int):\n        v = self.__visible_frame.cell_value_at(\n            self.region.first_row + row,\n            self.region.first_col + col,\n        )\n        return self.__styler._display_funcs[self.__to_source_frame_cell_coordinates(row, col)](v)\n\n    def __to_source_frame_cell_coordinates(self, row: int, col: int):\n        return self.__visible_frame.to_source_frame_cell_coordinates(\n            self.region.first_row + row,\n            self.region.first_col + col,\n        )\n\n\nclass StyledChunkComputer:\n    def __init__(self,\n                 visible_frame: VisibleFrame,\n                 org_styler: Styler,\n                 todo_patcher_list: List[TodoPatcher],\n                 ):\n        self.__visible_frame: VisibleFrame = visible_frame\n        self.__org_styler: Styler = org_styler\n        self.__todo_patcher_list: List[TodoPatcher] = todo_patcher_list\n\n    def compute(self, region: Region) -> StyledChunk:\n        region = self.__visible_frame.region.get_bounded_region(region)\n        chunk_df = self.__visible_frame.to_frame(region)\n\n        chunk_styler = chunk_df.style\n\n        chunk_styler._todo = [\n            p.create_patched_todo(chunk_df).to_tuple()\n            for p in self.__todo_patcher_list\n        ]\n        chunk_styler._compute()\n\n        chunk_styler._display_funcs = self.__org_styler._display_funcs\n        chunk_styler.hidden_index = self.__org_styler.hidden_index\n\n        return StyledChunk(\n            styler=chunk_styler,\n            visible_frame=self.__visible_frame,\n            region=region,\n        )\n\n\nclass PatchedStylerContext(PandasTableSourceContext):\n    def __init__(self, styler: Styler, filter_criteria: Optional[FilterCriteria] = None):\n        self.__has_hidden_columns = len(styler.hidden_columns) > 0\n        self.__styler = styler\n        self.__todo_patcher_list: List[TodoPatcher] = self.__create_patchers(styler)\n        super().__init__(styler.data, filter_criteria)\n\n    def create_styled_chunk_computer_for_validation(self, chunk: DataFrame, patcher: TodoPatcher) -> 'StyledChunkComputer':\n        return StyledChunkComputer(\n            visible_frame=VisibleFrame(chunk),\n            org_styler=self.__styler,\n            todo_patcher_list=[patcher.patcher_for_style_func_validation(chunk)]\n        )\n\n    def get_table_frame_generator(self) -> AbstractTableFrameGenerator:\n        from cms_rendner_sdfv.pandas.styler.table_frame_generator import TableFrameGenerator\n        return TableFrameGenerator(self)\n\n    def get_todo_patcher_list(self) -> List[TodoPatcher]:\n        return self.__todo_patcher_list\n\n    def compute_styled_chunk(self, region: Region) -> StyledChunk:\n        return StyledChunkComputer(\n            visible_frame=self.visible_frame,\n            org_styler=self.__styler,\n            todo_patcher_list=self.__todo_patcher_list,\n        ).compute(region)\n\n    def _get_initial_visible_frame_indexes(self):\n        index, columns = super()._get_initial_visible_frame_indexes()\n\n        if self.__has_hidden_columns:\n            columns = columns.delete(Index(self.__styler.hidden_columns))\n\n        return index, columns\n\n    def __create_patchers(self, styler: Styler) -> List[TodoPatcher]:\n        result: List[TodoPatcher] = []\n\n        org_frame = styler.data\n        for idx, t in enumerate(styler._todo):\n            st = StylerTodo.from_tuple(idx, t)\n            if st.is_pandas_style_func():\n                patcher = self.__get_patcher_for_supported_pandas_style_functions(org_frame, st)\n            else:\n                patcher = ApplyMapPatcher(org_frame, st) if st.is_applymap() else ApplyPatcher(org_frame, st)\n\n            if patcher is not None:\n                result.append(patcher)\n\n        return result\n\n    @staticmethod\n    def __get_patcher_for_supported_pandas_style_functions(org_frame: DataFrame, todo: StylerTodo) -> Optional[TodoPatcher]:\n        qname = StyleFunctionNameResolver.get_style_func_qname(todo)\n        if StyleFunctionNameResolver.is_pandas_background_gradient(qname):\n            return BackgroundGradientPatcher(org_frame, todo)\n        elif StyleFunctionNameResolver.is_pandas_highlight_min(qname, todo):\n            return HighlightExtremaPatcher(org_frame, todo)\n        elif StyleFunctionNameResolver.is_pandas_highlight_max(qname, todo):\n            return HighlightExtremaPatcher(org_frame, todo)\n        elif StyleFunctionNameResolver.is_pandas_highlight_null(qname):\n            return ApplyMapPatcher(org_frame, todo)\n        elif StyleFunctionNameResolver.is_pandas_set_properties(qname):\n            return ApplyMapPatcher(org_frame, todo)\n        return None\n",
                "style_func_with_chunk_parent": "from typing import Callable, Optional, Union\n\nfrom pandas import DataFrame, Series\nfrom pandas._typing import Axis\n\n\nclass StyleFuncWithChunkParent:\n    def __init__(self, delegate: Callable, axis: Optional[Axis], subset_frame: DataFrame):\n        self.__delegate = delegate\n        self.__axis = axis\n        self.__subset_frame = subset_frame\n\n    def __call__(self, chunk_or_series_from_chunk: Union[DataFrame, Series], *args, **kwargs):\n        if chunk_or_series_from_chunk.empty:\n            return chunk_or_series_from_chunk\n\n        kwargs['chunk_parent'] = self._get_parent(chunk_or_series_from_chunk)\n        return self.__delegate(chunk_or_series_from_chunk, *args, **kwargs)\n\n    def _get_parent(self, chunk_or_series_from_chunk: Union[DataFrame, Series]):\n        if self.__axis == 0 or self.__axis == \"index\":\n            return self.__subset_frame[chunk_or_series_from_chunk.name]\n        elif self.__axis == 1 or self.__axis == \"columns\":\n            return self.__subset_frame.loc[chunk_or_series_from_chunk.name]\n        else:\n            return self.__subset_frame\n",
                "style_function_name_resolver": "from functools import partial\n\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\n\n\nclass StyleFunctionNameResolver:\n\n    @staticmethod\n    def get_style_func_qname(todo: StylerTodo) -> str:\n        func = todo.apply_args.style_func\n        if isinstance(func, partial):\n            func = func.func\n        return getattr(func, '__qualname__', '')\n\n    @staticmethod\n    def resolve_style_func_name(todo: StylerTodo) -> str:\n        qname = StyleFunctionNameResolver.get_style_func_qname(todo)\n        if todo.is_pandas_style_func():\n            if StyleFunctionNameResolver.is_pandas_background_gradient(qname):\n                return \"background_gradient\"\n            elif StyleFunctionNameResolver.is_pandas_highlight_max(qname, todo):\n                return \"highlight_max\"\n            elif StyleFunctionNameResolver.is_pandas_highlight_min(qname, todo):\n                return \"highlight_min\"\n            elif StyleFunctionNameResolver.is_pandas_highlight_null(qname):\n                return \"highlight_null\"\n            elif StyleFunctionNameResolver.is_pandas_set_properties(qname):\n                return \"set_properties\"\n            else:\n                return qname.rpartition('.')[2]\n        else:\n            return qname.rpartition('.')[2]\n\n    @staticmethod\n    def is_pandas_background_gradient(style_func_qname: str) -> bool:\n        return style_func_qname == 'Styler._background_gradient'\n\n    @staticmethod\n    def is_pandas_highlight_max(style_func_qname: str, todo: StylerTodo) -> bool:\n        return style_func_qname.startswith('Styler._highlight_extrema') and todo.style_func_kwargs.get('max_', False)\n\n    @staticmethod\n    def is_pandas_highlight_min(style_func_qname: str, todo: StylerTodo) -> bool:\n        return style_func_qname.startswith('Styler._highlight_extrema') and not todo.style_func_kwargs.get('max_', False)\n\n    @staticmethod\n    def is_pandas_highlight_null(style_func_qname: str) -> bool:\n        return style_func_qname.startswith('Styler._highlight_null')\n\n    @staticmethod\n    def is_pandas_set_properties(style_func_qname: str) -> bool:\n        return style_func_qname.startswith('Styler.set_properties')\n",
                "style_functions_validator": "from typing import Optional, List\n\nfrom cms_rendner_sdfv.base.types import Region\nfrom cms_rendner_sdfv.pandas.styler.patched_styler_context import PatchedStylerContext, StyledChunk, StyledChunkComputer\nfrom cms_rendner_sdfv.pandas.styler.style_function_name_resolver import StyleFunctionNameResolver\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\nfrom cms_rendner_sdfv.pandas.styler.types import StyleFunctionValidationProblem, StyleFunctionInfo\n\n\nclass StyleFunctionsValidator:\n    def __init__(self, ctx: PatchedStylerContext, ignore_list: List[TodoPatcher] = None):\n        self.__ctx: PatchedStylerContext = ctx\n        self.__ignore_list = ignore_list or []\n        self.failed_patchers: List[TodoPatcher] = []\n\n    def validate(self, region: Optional[Region] = None) -> List[StyleFunctionValidationProblem]:\n        region = self.__ctx.visible_frame.region.get_bounded_region(region)\n\n        if region.is_empty():\n            return []\n\n        patchers_to_validate = [\n            p for p in self.__ctx.get_todo_patcher_list()\n            if not p.todo.is_applymap() and p not in self.__ignore_list\n        ]\n\n        if not patchers_to_validate:\n            return []\n\n        chunk_df = self.__ctx.visible_frame.to_frame(region)\n\n        validation_result = []\n        for patcher in patchers_to_validate:\n            is_equal = False\n\n            styled_chunk_computer = self.__ctx.create_styled_chunk_computer_for_validation(chunk_df, patcher)\n\n            try:\n                chunk = styled_chunk_computer.compute(region)\n\n                if patcher.todo.apply_args.axis_is_index():\n                    is_equal = self.__validate_horizontal_splitted(region, styled_chunk_computer, chunk)\n                elif patcher.todo.apply_args.axis_is_columns():\n                    is_equal = self.__validate_vertical_splitted(region, styled_chunk_computer, chunk)\n                else:\n                    is_equal = self.__validate_horizontal_splitted(region, styled_chunk_computer, chunk)\n                    if is_equal:\n                        is_equal = self.__validate_vertical_splitted(region, styled_chunk_computer, chunk)\n\n                if not is_equal:\n                    self.failed_patchers.append(patcher)\n                    validation_result.append(\n                        StyleFunctionValidationProblem(\n                            reason=\"NOT_EQUAL\",\n                            message=\"\",\n                            func_info=self.__create_style_func_info(patcher),\n                        )\n                    )\n\n            except Exception as e:\n                self.failed_patchers.append(patcher)\n                validation_result.append(\n                    StyleFunctionValidationProblem(\n                        reason=\"EXCEPTION\",\n                        message=str(e),\n                        func_info=self.__create_style_func_info(patcher),\n                    )\n                )\n\n        return validation_result\n\n    def __validate_horizontal_splitted(self, region: Region, computer: StyledChunkComputer, chunk: StyledChunk) -> bool:\n        for sub_region in region.iterate_local_chunkwise(self.__half_or_one(region.rows), region.cols):\n            sub_chunk = computer.compute(sub_region.translate(region.first_row, region.first_col))\n            if not self.__has_same_cell_styling(chunk, sub_chunk, sub_region):\n                return False\n        return True\n\n    def __validate_vertical_splitted(self, region: Region, computer: StyledChunkComputer, chunk: StyledChunk) -> bool:\n        for sub_region in region.iterate_local_chunkwise(region.rows, self.__half_or_one(region.cols)):\n            sub_chunk = computer.compute(sub_region.translate(region.first_row, region.first_col))\n            if not self.__has_same_cell_styling(chunk, sub_chunk, sub_region):\n                return False\n        return True\n\n    @staticmethod\n    def __create_style_func_info(patcher: TodoPatcher) -> StyleFunctionInfo:\n        todo = patcher.todo\n        return StyleFunctionInfo(\n            index=todo.index_in_org_styler,\n            qname=StyleFunctionNameResolver.get_style_func_qname(todo),\n            resolved_name=StyleFunctionNameResolver.resolve_style_func_name(todo),\n            axis='' if todo.is_applymap() else str(todo.apply_args.axis),\n            is_pandas_builtin=todo.is_pandas_style_func(),\n            is_supported=patcher.todo.is_pandas_style_func(),\n            is_apply=not todo.is_applymap(),\n            is_chunk_parent_requested=todo.should_provide_chunk_parent(),\n        )\n\n    @staticmethod\n    def __has_same_cell_styling(chunk: StyledChunk, sub_chunk: StyledChunk, sub_region: Region) -> bool:\n        for r in range(sub_region.rows):\n            for c in range(sub_region.cols):\n                expected = chunk.cell_css_at(sub_region.first_row + r, sub_region.first_col + c)\n                actual = sub_chunk.cell_css_at(r, c)\n                if expected != actual:\n                    return False\n        return True\n\n    @staticmethod\n    def __half_or_one(number: int):\n        return -(number // -2)\n",
                "styler_todo": "import inspect\nfrom dataclasses import dataclass\nfrom functools import partial\nfrom typing import Any, Callable, Optional, Tuple, Union\n\nfrom pandas._typing import Axis\n\n\n@dataclass(frozen=True)\nclass ApplyMapArgs:\n    style_func: Callable\n    subset: Optional[Any]\n\n    @classmethod\n    def from_tuple(cls, args: Tuple[Callable, Optional[Any]]):\n        return cls(args[0], args[1])\n\n    @staticmethod\n    def copy_with(style_func: Callable, subset: Optional[Any]):\n        return ApplyMapArgs(style_func, subset)\n\n    def to_tuple(self) -> Tuple[Callable, Optional[Any]]:\n        return self.style_func, self.subset\n\n\n@dataclass(frozen=True)\nclass ApplyArgs:\n    style_func: Callable\n    axis: Optional[Axis]\n    subset: Optional[Any]\n\n    @classmethod\n    def from_tuple(cls, args: Tuple[Callable, Optional[Axis], Optional[Any]]):\n        return cls(args[0], args[1], args[2])\n\n    def copy_with(self, style_func: Callable, subset: Optional[Any]):\n        return ApplyArgs(style_func, self.axis, subset)\n\n    def to_tuple(self) -> Tuple[Callable, Optional[Axis], Optional[Any]]:\n        return self.style_func, self.axis, self.subset\n\n    def axis_is_index(self) -> bool:\n        return self.axis == 'index' or self.axis == 0\n\n    def axis_is_columns(self) -> bool:\n        return self.axis == 'columns' or self.axis == 1\n\n\n@dataclass(frozen=True)\nclass StylerTodo:\n    index_in_org_styler: int\n    apply_func: Callable\n    apply_args: Union[ApplyArgs, ApplyMapArgs]\n    style_func_kwargs: dict\n\n    @classmethod\n    def from_tuple(cls, index_in_org_styler: int, todo: Tuple[Callable, tuple, dict]):\n        return cls(index_in_org_styler, todo[0], cls._to_apply_args(todo), todo[2])\n\n    @staticmethod\n    def _to_apply_args(todo: Tuple[Callable, tuple, dict]):\n        if StylerTodo.is_applymap_tuple(todo):\n            return ApplyMapArgs.from_tuple(todo[1])\n        else:\n            return ApplyArgs.from_tuple(todo[1])\n\n    @classmethod\n    def is_applymap_tuple(cls, todo: Tuple[Callable, tuple, dict]):\n        return cls.__is_apply_map_func(todo[0])\n\n    def is_applymap(self) -> bool:\n        return self.__is_apply_map_func(self.apply_func)\n\n    @staticmethod\n    def __is_apply_map_func(func: Callable) -> bool:\n        return getattr(func, '__qualname__', '').startswith('Styler.applymap')\n\n    def is_pandas_style_func(self) -> bool:\n        func = self.apply_args.style_func\n        if isinstance(func, partial):\n            func = func.func\n        inspect_result = inspect.getmodule(func)\n        return False if inspect_result is None else inspect.getmodule(func).__name__ == 'pandas.io.formats.style'\n\n    def should_provide_chunk_parent(self):\n        sig = inspect.signature(self.apply_args.style_func)\n        for param in sig.parameters.values():\n            if param.name == \"chunk_parent\" or param.kind == inspect.Parameter.VAR_KEYWORD:\n                return True\n        return False\n\n    def to_tuple(self) -> Tuple[Callable, tuple, dict]:\n        return self.apply_func, self.apply_args.to_tuple(), self.style_func_kwargs\n\n\nclass StylerTodoBuilder:\n\n    def __init__(self, source: StylerTodo):\n        self.source: StylerTodo = source\n        self.values: dict = {}\n\n    def with_subset(self, subset: Optional[Any]):\n        self.values[\"subset\"] = subset\n        return self\n\n    def with_style_func(self, style_func: Callable):\n        self.values[\"style_func\"] = style_func\n        return self\n\n    def with_style_func_kwargs(self, style_func_kwargs: dict):\n        self.values[\"style_func_kwargs\"] = style_func_kwargs\n        return self\n\n    def build(self) -> StylerTodo:\n        return StylerTodo(\n            self.source.index_in_org_styler,\n            self.source.apply_func,\n            self.source.apply_args.copy_with(\n                style_func=self.values.get(\"style_func\", self.source.apply_args.style_func),\n                subset=self.values.get(\"subset\", self.source.apply_args.subset),\n            ),\n            self.values.get(\"style_func_kwargs\", self.source.style_func_kwargs),\n        )\n",
                "table_frame_generator": "from typing import List, Union, Dict\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableFrameGenerator\nfrom cms_rendner_sdfv.base.types import Region, TableFrame, TableFrameCell, TableFrameColumn, TableFrameLegend\nfrom cms_rendner_sdfv.pandas.shared.value_formatter import ValueFormatter\nfrom cms_rendner_sdfv.pandas.styler.patched_styler_context import PatchedStylerContext, StyledChunk\n\n\nclass TableFrameGenerator(AbstractTableFrameGenerator):\n    def __init__(self, styler_context: PatchedStylerContext):\n        super().__init__(styler_context.visible_frame)\n        self.__styler_context: PatchedStylerContext = styler_context\n\n    def generate(self,\n                 region: Region = None,\n                 exclude_row_header: bool = False,\n                 exclude_col_header: bool = False,\n                 ) -> TableFrame:\n        formatter = ValueFormatter()\n        styled_chunk = self.__styler_context.compute_styled_chunk(region)\n\n        if styled_chunk.row_labels_hidden:\n            exclude_row_header = True\n\n        cells: List[List[TableFrameCell]] = []\n        columns: List[TableFrameColumn] = []\n        index_labels: List[List[str]] = []\n        for r in range(0, styled_chunk.region.rows):\n            row_cells = []\n            cells.append(row_cells)\n            for c in range(0, styled_chunk.region.cols):\n                if c == 0 and not exclude_row_header:\n                    row_labels = styled_chunk.row_labels_at(r)\n                    if row_labels:\n                        index_labels.append([formatter.format_index(lbl) for lbl in row_labels])\n                if r == 0 and not exclude_col_header:\n                    col_labels = styled_chunk.col_labels_at(c)\n                    if col_labels:\n                        info = self._visible_frame.get_column_info(styled_chunk.region.first_col + c)\n                        columns.append(\n                            TableFrameColumn(\n                                dtype=str(info.dtype),\n                                labels=[formatter.format_column(lbl) for lbl in col_labels],\n                                describe=info.describe(),\n                            ),\n                        )\n\n                css = styled_chunk.cell_css_at(r, c)\n                row_cells.append(\n                    TableFrameCell(\n                        value=formatter.format_cell(styled_chunk.cell_value_at(r, c)),\n                        css=self._css_to_dict(css),\n                    ),\n                )\n\n        return TableFrame(\n            index_labels=index_labels,\n            columns=columns,\n            cells=cells,\n            legend=None if exclude_col_header and exclude_row_header\n            else self._extract_legend_label(formatter, styled_chunk),\n        )\n\n    @staticmethod\n    def _css_to_dict(css: List[str]) -> Union[None, Dict[str, str]]:\n        if not css:\n            return None\n\n        css_dict = {}\n        for keyval in css:\n            if keyval:\n                k, v = [x.strip() for x in keyval.split(':')]\n                if k and v:\n                    css_dict[k] = v\n\n        return css_dict if css_dict else None\n\n    def _extract_legend_label(self, formatter: ValueFormatter, chunk: StyledChunk) -> Union[None, TableFrameLegend]:\n        if chunk.row_labels_hidden:\n            return None\n\n        index_legend = [\n            formatter.format_index(n)\n            for i, n in enumerate(self._visible_frame.index_names)\n            if n is not None\n        ]\n\n        column_legend = [\n            formatter.format_index(n)\n            for i, n in enumerate(self._visible_frame.column_names)\n            if n is not None\n        ]\n        return TableFrameLegend(index=index_legend, column=column_legend) if index_legend or column_legend else None\n",
                "table_source_factory": "from typing import Any, Union\n\nfrom pandas import DataFrame\nfrom pandas.io.formats.style import Styler\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableSource, AbstractTableSourceFactory\nfrom cms_rendner_sdfv.base.types import CreateTableSourceConfig, CreateTableSourceFailure\nfrom cms_rendner_sdfv.pandas.shared.create_fingerprint import create_fingerprint\nfrom cms_rendner_sdfv.pandas.shared.types import FilterCriteria\nfrom cms_rendner_sdfv.pandas.styler.patched_styler import PatchedStyler\nfrom cms_rendner_sdfv.pandas.styler.patched_styler_context import PatchedStylerContext\n\n\nclass TableSourceFactory(AbstractTableSourceFactory):\n\n    def _create_internal(self,\n                         data_source: Any,\n                         config: CreateTableSourceConfig,\n                         caller_globals: dict,\n                         ) -> Union[AbstractTableSource, CreateTableSourceFailure]:\n\n        if not isinstance(data_source, Styler):\n            return CreateTableSourceFailure(error_kind=\"UNSUPPORTED_DATA_SOURCE_TYPE\", info=str(type(data_source)))\n\n        ds_frame = data_source.data\n        ds_frame_style = data_source\n\n        pre_fingerprint = config.previous_fingerprint\n        cur_fingerprint = create_fingerprint(ds_frame, data_source)\n        if pre_fingerprint is not None and pre_fingerprint != cur_fingerprint:\n            return CreateTableSourceFailure(error_kind=\"INVALID_FINGERPRINT\", info=cur_fingerprint)\n\n        filter_frame = None\n        filter_eval_expr = config.filter_eval_expr\n        if filter_eval_expr is not None and filter_eval_expr != \"\":\n            try:\n                if config.filter_eval_expr_provide_frame:\n                    caller_globals[\"_df\"] = ds_frame\n                filter_frame = eval(filter_eval_expr, caller_globals)\n            except Exception as e:\n                return CreateTableSourceFailure(error_kind=\"FILTER_FRAME_EVAL_FAILED\", info=repr(e))\n\n            if not isinstance(filter_frame, DataFrame):\n                return CreateTableSourceFailure(error_kind=\"FILTER_FRAME_OF_WRONG_TYPE\", info=str(type(filter_frame)))\n\n        return PatchedStyler(\n            PatchedStylerContext(ds_frame_style, FilterCriteria.from_frame(filter_frame)),\n            fingerprint=cur_fingerprint,\n        )\n",
                "todo_patcher": "from abc import ABC, abstractmethod\nfrom typing import Optional, Callable, Any\n\nfrom pandas import DataFrame\nfrom pandas.core.indexing import _non_reducing_slice\n\nfrom cms_rendner_sdfv.pandas.styler.style_func_with_chunk_parent import StyleFuncWithChunkParent\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo, StylerTodoBuilder\n\n\nclass TodoPatcher(ABC):\n\n    def __init__(self, org_frame: DataFrame, todo: StylerTodo):\n        self.__org_subset_frame: DataFrame = self.__compute_org_subset_frame(org_frame, todo.apply_args.subset)\n        self.todo: StylerTodo = StylerTodoBuilder(todo).with_subset(None).build()\n\n    def patcher_for_style_func_validation(self, chunk: DataFrame) -> 'TodoPatcher':\n        subset = self.__calculate_chunk_subset(chunk)\n        return self.__class__(self.__org_subset_frame.loc[subset], self.todo)\n\n    @abstractmethod\n    def create_patched_todo(self, chunk: DataFrame) -> Optional[StylerTodo]:\n        pass\n\n    def _todo_builder(self, chunk: DataFrame) -> StylerTodoBuilder:\n        return StylerTodoBuilder(self.todo).with_subset(self.__calculate_chunk_subset(chunk))\n\n    def _wrap_with_chunk_parent_provider(self, style_func: Callable):\n        return StyleFuncWithChunkParent(style_func, self.todo.apply_args.axis, self.__org_subset_frame)\n\n    def __calculate_chunk_subset(self, chunk: DataFrame) -> Any:\n        index_intersection = chunk.index.intersection(self.__org_subset_frame.index)\n        column_intersection = chunk.columns.intersection(self.__org_subset_frame.columns)\n        return index_intersection, column_intersection\n\n    @staticmethod\n    def __compute_org_subset_frame(org_frame: DataFrame, subset: Optional[Any]) -> DataFrame:\n        subset_frame = org_frame\n\n        if subset is not None:\n\n            subset = slice(None) if subset is None else subset\n            subset = _non_reducing_slice(subset)\n            subset_frame = org_frame.loc[subset]\n\n            if org_frame.shape == subset_frame.shape:\n                subset_frame = org_frame\n\n        return subset_frame\n",
                "types": "from dataclasses import dataclass\nfrom typing import Optional, List\n\nfrom cms_rendner_sdfv.base.types import TableFrame\n\n\n@dataclass(frozen=True)\nclass StyleFunctionInfo:\n    index: int\n    qname: str\n    resolved_name: str\n    axis: str\n    is_chunk_parent_requested: bool\n    is_apply: bool\n    is_pandas_builtin: bool\n    is_supported: bool\n\n\n@dataclass(frozen=True)\nclass StyleFunctionValidationProblem:\n    reason: str\n    message: str\n    func_info: StyleFunctionInfo\n\n\n@dataclass(frozen=True)\nclass ValidatedTableFrame:\n    frame: Optional[TableFrame] = None\n    problems: Optional[List[StyleFunctionValidationProblem]] = None\n"
            }
        }
    }
}