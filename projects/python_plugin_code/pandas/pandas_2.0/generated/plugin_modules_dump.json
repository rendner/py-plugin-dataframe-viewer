{
    "cms_rendner_sdfv": {
        "pandas": {
            "frame": {
                "frame_context": "from cms_rendner_sdfv.base.table_source import AbstractTableFrameGenerator\nfrom cms_rendner_sdfv.pandas.frame.table_frame_generator import TableFrameGenerator\nfrom cms_rendner_sdfv.pandas.shared.pandas_table_source_context import PandasTableSourceContext\n\n\nclass FrameContext(PandasTableSourceContext):\n    def get_table_frame_generator(self) -> AbstractTableFrameGenerator:\n        return TableFrameGenerator(self.visible_frame)",
                "table_frame_generator": "from typing import Any, Callable, List, Optional\n\nfrom pandas import get_option\nfrom pandas.core.dtypes.common import (\n    is_complex,\n    is_float,\n    is_integer,\n)\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableFrameGenerator\nfrom cms_rendner_sdfv.base.types import Region, TableFrame, TableFrameCell, TableFrameColumn, TableFrameLegend\nfrom cms_rendner_sdfv.pandas.shared.value_formatter import ValueFormatter\nfrom cms_rendner_sdfv.pandas.shared.visible_frame import Chunk, VisibleFrame\n\n\nclass _ValueFormatter(ValueFormatter):\n    def __init__(self):\n        self._precision = get_option(\"display.precision\")\n        self._float_format: Optional[Callable] = get_option(\"display.float_format\")\n\n    def _default_format(self, x: Any, fallback_formatter) -> Any:\n        if is_float(x) or is_complex(x):\n            if callable(self._float_format):\n                return self._float_format(x)\n            return f\"{x:.{self._precision}f}\"\n        elif is_integer(x):\n            return str(x)\n\n        return fallback_formatter(x)\n\n    def format_column(self, value: Any) -> str:\n        return self._default_format(value, super().format_column)\n\n    def format_index(self, value: Any) -> str:\n        return self._default_format(value, super().format_index)\n\n    def format_cell(self, value: Any) -> str:\n        return self._default_format(value, super().format_cell)\n\n\nclass TableFrameGenerator(AbstractTableFrameGenerator):\n    def __init__(self, visible_frame: VisibleFrame):\n        super().__init__(visible_frame)\n\n    def generate(self,\n                 region: Region = None,\n                 exclude_row_header: bool = False,\n                 exclude_col_header: bool = False,\n                 ) -> TableFrame:\n        if self._exclude_headers:\n            exclude_row_header = True\n            exclude_col_header = True\n\n        chunk = self._visible_frame.get_chunk(region)\n        formatter = _ValueFormatter()\n\n        columns = [] if exclude_col_header else self._extract_columns(chunk, formatter)\n        index_labels = [] if exclude_row_header else self._extract_index_header_labels(chunk, formatter)\n        cells = self._extract_cells(chunk, formatter)\n        legend_label = None if exclude_col_header and exclude_row_header else self._extract_legend_label(formatter)\n\n        return TableFrame(\n            index_labels=index_labels,\n            columns=columns,\n            legend=legend_label,\n            cells=cells,\n        )\n\n    def _extract_columns(self, chunk: Chunk, formatter: ValueFormatter) -> List[TableFrameColumn]:\n        result: List[TableFrameColumn] = []\n\n        for col_offset in range(chunk.region.cols):\n            name = chunk.column_at(col_offset)\n            if isinstance(name, tuple):\n                labels = [formatter.format_column(h) for h in name]\n            else:\n                labels = [formatter.format_column(name)]\n\n            info = self._visible_frame.get_column_info(chunk.region.first_col + col_offset)\n            result.append(TableFrameColumn(dtype=str(info.dtype), labels=labels, describe=info.describe()))\n\n        return result\n\n    @staticmethod\n    def _extract_index_header_labels(chunk: Chunk, formatter: ValueFormatter) -> List[List[str]]:\n        result: List[List[str]] = []\n\n        for row_offset in range(chunk.region.rows):\n            name = chunk.index_at(row_offset)\n            if isinstance(name, tuple):\n                result.append([formatter.format_index(h) for h in name])\n            else:\n                result.append([formatter.format_index(name)])\n\n        return result\n\n    @staticmethod\n    def _extract_cells(chunk: Chunk, formatter: ValueFormatter) -> List[List[TableFrameCell]]:\n        result: List[List[TableFrameCell]] = []\n\n        col_range = range(chunk.region.cols)\n        for row_offset in range(chunk.region.rows):\n            result.append(\n                [TableFrameCell(\n                    value=formatter.format_cell(chunk.cell_value_at(row_offset, col_offset))\n                ) for col_offset in col_range])\n\n        return result\n\n    def _extract_legend_label(self, formatter: ValueFormatter) -> TableFrameLegend:\n        index_legend = [formatter.format_index(n) for n in self._visible_frame.index_names if n is not None]\n        column_legend = [formatter.format_index(n) for n in self._visible_frame.column_names if n is not None]\n        return TableFrameLegend(index=index_legend, column=column_legend) if index_legend or column_legend else None\n",
                "table_source": "from cms_rendner_sdfv.base.table_source import AbstractTableSource\nfrom cms_rendner_sdfv.base.types import TableSourceKind\nfrom cms_rendner_sdfv.pandas.frame.frame_context import FrameContext\n\n\nclass TableSource(AbstractTableSource):\n    def __init__(self, context: FrameContext, fingerprint: str):\n        super().__init__(TableSourceKind.TABLE_SOURCE, context, fingerprint)\n",
                "table_source_factory": "from typing import Any, Union\n\nfrom pandas import DataFrame\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableSource, AbstractTableSourceFactory\nfrom cms_rendner_sdfv.base.types import CreateTableSourceConfig, CreateTableSourceFailure\nfrom cms_rendner_sdfv.pandas.frame.table_source import TableSource\nfrom cms_rendner_sdfv.pandas.frame.frame_context import FrameContext\nfrom cms_rendner_sdfv.pandas.shared.create_fingerprint import create_fingerprint\nfrom cms_rendner_sdfv.pandas.shared.types import FilterCriteria\n\n\nclass TableSourceFactory(AbstractTableSourceFactory):\n\n    def _create_internal(self,\n                         data_source: Any,\n                         config: CreateTableSourceConfig,\n                         caller_globals: dict,\n                         ) -> Union[AbstractTableSource, CreateTableSourceFailure]:\n        ds_frame = None\n        if isinstance(data_source, dict):\n            if config.data_source_transform_hint == \"DictKeysAsRows\":\n                ds_frame = DataFrame.from_dict(data_source, orient='index')\n            elif all(name in data_source for name in [\"index\", \"columns\", \"data\", \"index_names\", \"column_names\"]):\n                ds_frame = DataFrame.from_dict(data_source, orient='tight')\n            else:\n                try:\n                    ds_frame = DataFrame.from_dict(data_source, orient='columns')\n                except ValueError as e:\n                    if str(e) == \"If using all scalar values, you must pass an index\":\n                        ds_frame = DataFrame(data_source, index=[0])\n        elif isinstance(data_source, DataFrame):\n            ds_frame = data_source\n        else:\n            return CreateTableSourceFailure(error_kind=\"UNSUPPORTED_DATA_SOURCE_TYPE\", info=str(type(data_source)))\n\n        pre_fingerprint = config.previous_fingerprint\n        cur_fingerprint = create_fingerprint(ds_frame, data_source)\n        if pre_fingerprint is not None and pre_fingerprint != cur_fingerprint:\n            return CreateTableSourceFailure(error_kind=\"INVALID_FINGERPRINT\", info=cur_fingerprint)\n\n        filter_frame = None\n        filter_eval_expr = config.filter_eval_expr\n        if filter_eval_expr is not None and filter_eval_expr != \"\":\n            try:\n                if config.filter_eval_expr_provide_frame:\n                    caller_globals[\"_df\"] = ds_frame\n                filter_frame = eval(filter_eval_expr, caller_globals)\n            except Exception as e:\n                return CreateTableSourceFailure(error_kind=\"FILTER_FRAME_EVAL_FAILED\", info=repr(e))\n\n            if not isinstance(filter_frame, DataFrame):\n                return CreateTableSourceFailure(error_kind=\"FILTER_FRAME_OF_WRONG_TYPE\", info=str(type(filter_frame)))\n\n        return TableSource(\n            FrameContext(ds_frame, FilterCriteria.from_frame(filter_frame)),\n            fingerprint=cur_fingerprint,\n        )\n"
            },
            "shared": {
                "create_fingerprint": "from hashlib import blake2b\nfrom typing import Any\n\nfrom pandas import DataFrame\n\n\ndef create_fingerprint(frame: DataFrame, org_data_source: Any = None) -> str:\n    fingerprint_input = [\n        id(org_data_source if org_data_source is not None else frame),\n        frame.shape,\n        frame.index[:60],\n        frame.dtypes[:60]\n    ]\n    return blake2b('-'.join(str(x) for x in fingerprint_input).encode(), digest_size=16).hexdigest()",
                "pandas_table_source_context": "from abc import ABC\nfrom typing import List, Optional\n\nfrom pandas import DataFrame\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableSourceContext\nfrom cms_rendner_sdfv.base.types import SortCriteria, TableStructure\nfrom cms_rendner_sdfv.pandas.shared.types import FilterCriteria\nfrom cms_rendner_sdfv.pandas.shared.visible_frame import VisibleFrame, MappedVisibleFrame\n\n\nclass PandasTableSourceContext(AbstractTableSourceContext, ABC):\n    def __init__(self, source_frame: DataFrame, filter_criteria: Optional[FilterCriteria] = None):\n        self._source_frame = source_frame\n        self._sort_criteria: SortCriteria = SortCriteria()\n        self._filter_criteria: FilterCriteria = filter_criteria if filter_criteria is not None else FilterCriteria()\n        self._visible_frame: VisibleFrame = self._recompute_visible_frame()\n\n    @property\n    def visible_frame(self) -> VisibleFrame:\n        return self._visible_frame\n\n    def get_table_structure(self, fingerprint: str) -> TableStructure:\n        rows_count = self._visible_frame.region.rows\n        columns_count = self._visible_frame.region.cols\n        if rows_count == 0 or columns_count == 0:\n            rows_count = columns_count = 0\n        return TableStructure(\n            org_rows_count=len(self._source_frame.index),\n            org_columns_count=len(self._source_frame.columns),\n            rows_count=rows_count,\n            columns_count=columns_count,\n            fingerprint=fingerprint,\n        )\n\n    def set_sort_criteria(self, sort_by_column_index: Optional[List[int]], sort_ascending: Optional[List[bool]]):\n        new_sort_criteria = SortCriteria(sort_by_column_index, sort_ascending)\n        if new_sort_criteria != self._sort_criteria:\n            self._sort_criteria = new_sort_criteria\n            self._visible_frame = self._recompute_visible_frame()\n\n    def _get_initial_visible_frame_indexes(self):\n        return self._source_frame.index, self._source_frame.columns\n\n    def _recompute_visible_frame(self) -> VisibleFrame:\n        index, columns = self._get_initial_visible_frame_indexes()\n\n        if self._filter_criteria.index is not None:\n            index = index.intersection(self._filter_criteria.index)\n\n        if self._filter_criteria.columns is not None:\n            columns = columns.intersection(self._filter_criteria.columns)\n\n        if not self._sort_criteria.is_empty():\n            sc = self._sort_criteria\n            frame = self._source_frame.loc[index, columns]\n            frame = frame.sort_values(\n                by=[frame.columns[i] for i in sc.by_column],\n                ascending=True if sc.ascending is None or len(sc.ascending) == 0 else sc.ascending,\n            )\n            index = frame.index\n\n        if index is self._source_frame.index and columns is self._source_frame.columns:\n            return VisibleFrame(self._source_frame)\n\n        return MappedVisibleFrame(\n            self._source_frame,\n            self._source_frame.index.get_indexer_for(index),\n            self._source_frame.columns.get_indexer_for(columns),\n        )\n",
                "types": "from dataclasses import dataclass\nfrom typing import Optional\n\nfrom pandas import DataFrame, Index\n\n\n@dataclass(frozen=True)\nclass FilterCriteria:\n    index: Optional[Index] = None\n    columns: Optional[Index] = None\n\n    @staticmethod\n    def from_frame(frame: Optional[DataFrame]):\n        return None if frame is None else FilterCriteria(frame.index, frame.columns)\n\n    def is_empty(self) -> bool:\n        return self.index is None and self.columns is None\n\n    def __eq__(self, other):\n        if isinstance(other, FilterCriteria):\n            def _equals(s: Optional[Index], o: Optional[Index]) -> bool:\n                if s is None and o is None:\n                    return True\n                return s is not None and o is not None and s.equals(o)\n\n            return _equals(self.columns, other.columns) and _equals(self.index, other.index)\n        return False\n",
                "value_formatter": "from typing import Any\n\nfrom pandas.errors import OptionError\nfrom pandas.io.formats.printing import pprint_thing, get_option\n\nfrom cms_rendner_sdfv.base.constants import CELL_MAX_STR_LEN\nfrom cms_rendner_sdfv.base.helpers import truncate_str\n\n\nclass ValueFormatter:\n\n    @staticmethod\n    def format_column(value: Any) -> str:\n        return value if isinstance(value, str) else pprint_thing(value)\n\n    @staticmethod\n    def format_index(value: Any) -> str:\n        return value if isinstance(value, str) else pprint_thing(value)\n\n    @staticmethod\n    def format_cell(value: Any) -> str:\n        v = value\n        if not isinstance(v, str):\n            max_seq_items = None\n            try:\n                max_seq_items = get_option(\"display.max_seq_items\", True)\n            except OptionError:\n                pass\n            v = pprint_thing(v, max_seq_items=max_seq_items or 42)\n        return truncate_str(v, CELL_MAX_STR_LEN)\n",
                "visible_frame": "from typing import Callable, List, Tuple, Dict\n\nimport numpy as np\nfrom pandas import DataFrame, Series\n\nfrom cms_rendner_sdfv.base.constants import DESCRIBE_COL_MAX_STR_LEN\nfrom cms_rendner_sdfv.base.helpers import truncate_str\nfrom cms_rendner_sdfv.base.table_source import AbstractVisibleFrame\nfrom cms_rendner_sdfv.base.types import Region\n\n\nclass Chunk:\n    def __init__(self, visible_frame: 'VisibleFrame', region: Region):\n        self._visible_frame = visible_frame\n        self._region = region\n\n    @property\n    def region(self) -> Region:\n        return self._region\n\n    def cell_value_at(self, row_offset: int, col_offset: int):\n        return self._visible_frame.cell_value_at(\n            self.region.first_row + row_offset,\n            self.region.first_col + col_offset,\n        )\n\n    def column_at(self, offset: int):\n        return self._visible_frame.column_at(self.region.first_col + offset)\n\n    def index_at(self, offset: int):\n        return self._visible_frame.index_at(self.region.first_row + offset)\n\n\nclass VisibleColumnInfo:\n    def __init__(self, column: Series):\n        self._column = column\n\n    @property\n    def dtype(self):\n        return self._column.dtype\n\n    def describe(self) -> Dict[str, str]:\n        try:\n            return {k: truncate_str(str(v), DESCRIBE_COL_MAX_STR_LEN) for k, v in self._column.describe().to_dict().items()}\n        except TypeError as e:\n            return {'error': str(e)}\n\n\nclass VisibleFrame(AbstractVisibleFrame):\n    def __init__(self, source_frame: DataFrame):\n        self._source_frame = source_frame\n        self._region = Region(0, 0, len(source_frame.index), len(source_frame.columns))\n\n    @property\n    def region(self) -> Region:\n        return self._region\n\n    @property\n    def index_names(self) -> list:\n        return self._source_frame.index.names\n\n    @property\n    def column_names(self) -> list:\n        return self._source_frame.columns.names\n\n    def cell_value_at(self, row: int, col: int):\n        return self._source_frame.iat[row, col]\n\n    def column_at(self, col: int):\n        return self._source_frame.columns[col]\n\n    def index_at(self, row: int):\n        return self._source_frame.index[row]\n\n    def get_column_info(self, col: int) -> VisibleColumnInfo:\n        return VisibleColumnInfo(self._source_frame.iloc[:, col])\n\n    def get_chunk(self, region: Region = None) -> Chunk:\n        return Chunk(self, self._region if region is None else self.region.get_bounded_region(region))\n\n    def to_frame(self, chunk: Chunk) -> DataFrame:\n        r = chunk.region\n        return self._source_frame.iloc[\n               r.first_row:r.first_row + r.rows,\n               r.first_col:r.first_col + r.cols,\n               ]\n\n    def create_to_source_frame_cell_coordinates_translator(self, chunk: Chunk) -> Callable[[Tuple[int, int]], Tuple[int, int]]:\n        r = chunk.region\n\n        def translate(k: Tuple[int, int]) -> Tuple[int, int]:\n            return r.first_row + k[0], r.first_col + k[1]\n\n        return translate\n\n    def get_column_indices(self, part_start: int, max_columns: int) -> List[int]:\n        r = self._region.get_bounded_region(Region(part_start, 0, max_columns, 0))\n        return list(range(r.first_row, r.first_row + r.rows))\n\n\nclass MappedVisibleFrame(VisibleFrame):\n    def __init__(self, source_frame: DataFrame, visible_rows: np.ndarray, visible_cols: np.ndarray):\n        super().__init__(source_frame)\n        self._i_rows = visible_rows\n        self._i_cols = visible_cols\n        self._region = Region(0, 0, len(visible_rows), len(visible_cols))\n\n    def cell_value_at(self, row: int, col: int):\n        return self._source_frame.iat[self._i_rows[row], self._i_cols[col]]\n\n    def column_at(self, col: int):\n        return self._source_frame.columns[self._i_cols[col]]\n\n    def index_at(self, row: int):\n        return self._source_frame.index[self._i_rows[row]]\n\n    def get_column_info(self, col: int) -> VisibleColumnInfo:\n        return VisibleColumnInfo(self._source_frame.iloc[self._i_rows, self._i_cols[col]])\n\n    def to_frame(self, chunk: Chunk) -> DataFrame:\n        r = chunk.region\n        i_rows = self._i_rows[r.first_row:r.first_row + r.rows]\n        i_cols = self._i_cols[r.first_col:r.first_col + r.cols]\n        return self._source_frame.iloc[i_rows, i_cols]\n\n    def create_to_source_frame_cell_coordinates_translator(self, chunk: Chunk) -> Callable[[Tuple[int, int]], Tuple[int, int]]:\n        r = chunk.region\n\n        def translate(k: Tuple[int, int]) -> Tuple[int, int]:\n            return self._i_rows[r.first_row + k[0]], self._i_cols[r.first_col + k[1]]\n\n        return translate\n\n    def get_column_indices(self, part_start: int, max_columns: int) -> List[int]:\n        return list(self._i_cols[part_start:part_start + max_columns])\n\n"
            },
            "styler": {
                "apply_map_patcher": "from typing import Optional\n\nfrom pandas import DataFrame\n\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\n\n\nclass ApplyMapPatcher(TodoPatcher):\n\n    def __init__(self, todo: StylerTodo):\n        super().__init__(todo)\n\n    def create_patched_todo(self, org_frame: DataFrame, chunk: DataFrame) -> Optional[StylerTodo]:\n        subset_frame = self._create_subset_frame(org_frame, self._todo.apply_args.subset)\n        return self._todo.builder() \\\n            .with_subset(self._calculate_chunk_subset(subset_frame, chunk)) \\\n            .build()\n",
                "apply_patcher": "from typing import Optional, Union\n\nfrom pandas import DataFrame, Series\n\nfrom cms_rendner_sdfv.pandas.styler.chunk_parent_provider import ChunkParentProvider\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\n\n\nclass ApplyPatcher(TodoPatcher):\n\n    def __init__(self, todo: StylerTodo):\n        super().__init__(todo)\n\n    def create_patched_todo(self, org_frame: DataFrame, chunk: DataFrame) -> Optional[StylerTodo]:\n        subset_frame = self._create_subset_frame(org_frame, self._todo.apply_args.subset)\n        builder = self._todo.builder().with_subset(self._calculate_chunk_subset(subset_frame, chunk))\n        if self._todo.should_provide_chunk_parent():\n            builder.with_style_func(\n                ChunkParentProvider(self._styling_func, self._todo.apply_args.axis, subset_frame),\n            )\n        else:\n            builder.with_style_func(self._styling_func)\n        return builder.build()\n\n    def _styling_func(self, chunk_or_series_from_chunk: Union[DataFrame, Series], **kwargs):\n        if chunk_or_series_from_chunk.empty:\n            return chunk_or_series_from_chunk\n        return self._todo.apply_args.style_func(chunk_or_series_from_chunk, **kwargs)\n",
                "background_gradient_patcher": "from typing import Optional, Union\n\nimport numpy as np\nfrom pandas import DataFrame, Series\nfrom pandas.io.formats.style import _validate_apply_axis_arg\n\nfrom cms_rendner_sdfv.pandas.styler.chunk_parent_provider import ChunkParentProvider\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\n\n\nclass BackgroundGradientPatcher(TodoPatcher):\n\n    def __init__(self, todo: StylerTodo):\n        super().__init__(todo)\n\n    def create_patched_todo(self, org_frame: DataFrame, chunk: DataFrame) -> Optional[StylerTodo]:\n        subset_frame = self._create_subset_frame(org_frame, self._todo.apply_args.subset)\n        return self._todo.builder() \\\n            .with_subset(self._calculate_chunk_subset(subset_frame, chunk)) \\\n            .with_style_func(ChunkParentProvider(self._styling_func, self._todo.apply_args.axis, subset_frame))\\\n            .build()\n\n    def _styling_func(self,\n                      chunk_or_series_from_chunk: Union[DataFrame, Series],\n                      chunk_parent: Union[DataFrame, Series],\n                      **kwargs,\n                      ):\n        if chunk_or_series_from_chunk.empty:\n            return chunk_or_series_from_chunk\n\n\n        vmin = kwargs.get(\"vmin\", None)\n        vmax = kwargs.get(\"vmax\", None)\n        gmap = kwargs.get(\"gmap\", None)\n\n        if gmap is None:\n            gmap = chunk_parent.to_numpy(dtype=float, na_value=np.nan)\n        else:\n            gmap = _validate_apply_axis_arg(gmap, \"gmap\", float, chunk_parent)\n\n        if vmin is None or vmax is None:\n            if vmin is None:\n                vmin = np.nanmin(gmap)\n            if vmax is None:\n                vmax = np.nanmax(gmap)\n\n        gmap = self._adjust_gmap_shape_to_chunk_shape(gmap, chunk_or_series_from_chunk, chunk_parent)\n\n        return self._todo.apply_args.style_func(\n            chunk_or_series_from_chunk,\n            **dict(kwargs, vmin=vmin, vmax=vmax, gmap=gmap),\n        )\n\n    def _adjust_gmap_shape_to_chunk_shape(self,\n                                          gmap: np.ndarray,\n                                          chunk_or_series_from_chunk: Union[DataFrame, Series],\n                                          chunk_parent: Union[DataFrame, Series],\n                                          ) -> np.ndarray:\n        if isinstance(chunk_or_series_from_chunk, Series):\n            return gmap[chunk_parent.index.get_indexer_for(chunk_or_series_from_chunk.index)]\n        elif isinstance(chunk_or_series_from_chunk, DataFrame) and self._todo.apply_args.axis is None:\n            ri = chunk_parent.index.get_indexer_for(chunk_or_series_from_chunk.index)\n            ci = chunk_parent.columns.get_indexer_for(chunk_or_series_from_chunk.columns)\n            if isinstance(gmap, DataFrame):\n                return gmap.iloc[(ri, ci)]\n            elif isinstance(gmap, np.ndarray):\n                return DataFrame(data=gmap, index=chunk_parent.index, columns=chunk_parent.columns).iloc[(ri, ci)]\n        return gmap\n",
                "chunk_parent_provider": "from typing import Callable, Optional, Union\n\nfrom pandas import DataFrame, Series\nfrom pandas._typing import Axis\n\n\nclass ChunkParentProvider:\n    def __init__(self, style_func: Callable, axis: Optional[Axis], subset_frame: DataFrame):\n        self.__style_func = style_func\n        self.__axis = axis\n        self.__subset_frame = subset_frame\n\n    def __call__(self, chunk_or_series_from_chunk: Union[DataFrame, Series], *args, **kwargs):\n        if chunk_or_series_from_chunk.empty:\n            return chunk_or_series_from_chunk\n\n        kwargs['chunk_parent'] = self._get_parent(chunk_or_series_from_chunk)\n        return self.__style_func(chunk_or_series_from_chunk, *args, **kwargs)\n\n    def _get_parent(self, chunk_or_series_from_chunk: Union[DataFrame, Series]):\n        if self.__axis == 0 or self.__axis == \"index\":\n            return self.__subset_frame[chunk_or_series_from_chunk.name]\n        elif self.__axis == 1 or self.__axis == \"columns\":\n            return self.__subset_frame.loc[chunk_or_series_from_chunk.name]\n        else:\n            return self.__subset_frame\n",
                "highlight_between_patcher": "from typing import Optional, Union\n\nimport numpy as np\nfrom pandas import DataFrame, Series\nfrom pandas.io.formats.style import _validate_apply_axis_arg\n\nfrom cms_rendner_sdfv.pandas.styler.chunk_parent_provider import ChunkParentProvider\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\n\n\nclass HighlightBetweenPatcher(TodoPatcher):\n\n    def __init__(self, todo: StylerTodo):\n        super().__init__(todo)\n\n    def create_patched_todo(self, org_frame: DataFrame, chunk: DataFrame) -> Optional[StylerTodo]:\n        subset_frame = self._create_subset_frame(org_frame, self._todo.apply_args.subset)\n        return self._todo.builder() \\\n            .with_subset(self._calculate_chunk_subset(subset_frame, chunk)) \\\n            .with_style_func(ChunkParentProvider(self._styling_func, self._todo.apply_args.axis, subset_frame)) \\\n            .build()\n\n    def _styling_func(self,\n                      chunk_or_series_from_chunk: Union[DataFrame, Series],\n                      chunk_parent: Union[DataFrame, Series],\n                      **kwargs,\n                      ):\n        if chunk_or_series_from_chunk.empty:\n            return chunk_or_series_from_chunk\n\n        left = kwargs.get(\"left\", None)\n        right = kwargs.get(\"right\", None)\n\n        if np.iterable(left) and not isinstance(left, str):\n            left = _validate_apply_axis_arg(left, \"left\", None, chunk_parent)\n            left = self._adjust_range_part(left, chunk_or_series_from_chunk, chunk_parent)\n\n        if np.iterable(right) and not isinstance(right, str):\n            right = _validate_apply_axis_arg(right, \"right\", None, chunk_parent)\n            right = self._adjust_range_part(right, chunk_or_series_from_chunk, chunk_parent)\n\n        return self._todo.apply_args.style_func(\n            chunk_or_series_from_chunk,\n            **dict(kwargs, left=left, right=right),\n        )\n\n    def _adjust_range_part(self,\n                           part: np.ndarray,\n                           chunk_or_series_from_chunk: Union[DataFrame, Series],\n                           chunk_parent: Union[DataFrame, Series],\n                           ) -> np.ndarray:\n        if isinstance(chunk_or_series_from_chunk, Series):\n            return part[chunk_parent.index.get_indexer_for(chunk_or_series_from_chunk.index)]\n        elif isinstance(chunk_or_series_from_chunk, DataFrame) and self._todo.apply_args.axis is None:\n            ri = chunk_parent.index.get_indexer_for(chunk_or_series_from_chunk.index)\n            ci = chunk_parent.columns.get_indexer_for(chunk_or_series_from_chunk.columns)\n            ri_slice = slice(ri[0], ri[-1] + 1)\n            ci_slice = slice(ci[0], ci[-1] + 1)\n            return part[ri_slice, ci_slice]\n        return part\n",
                "highlight_extrema_patcher": "from typing import Optional, Union\n\nimport numpy as np\nimport pandas as pd\nfrom pandas import DataFrame, Series\n\nfrom cms_rendner_sdfv.pandas.styler.chunk_parent_provider import ChunkParentProvider\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\n\n\nclass HighlightExtremaPatcher(TodoPatcher):\n\n    def __init__(self, todo: StylerTodo, op: str):\n        super().__init__(todo)\n        self._op: str = op\n        self._attribute: str = todo.style_func_kwargs.get('props', 'background-color: yellow')\n\n    def create_patched_todo(self, org_frame: DataFrame, chunk: DataFrame) -> Optional[StylerTodo]:\n        subset_frame = self._create_subset_frame(org_frame, self._todo.apply_args.subset)\n        return self._todo.builder() \\\n            .with_subset(self._calculate_chunk_subset(subset_frame, chunk)) \\\n            .with_style_func_kwargs({}) \\\n            .with_style_func(ChunkParentProvider(self._styling_func, self._todo.apply_args.axis, subset_frame)) \\\n            .build()\n\n    def _styling_func(self,\n                      chunk_or_series_from_chunk: Union[DataFrame, Series],\n                      chunk_parent: Union[DataFrame, Series],\n                      ):\n        if chunk_or_series_from_chunk.empty:\n            return chunk_or_series_from_chunk\n\n        value = getattr(chunk_parent, self._op)(skipna=True)\n\n        if isinstance(chunk_or_series_from_chunk, DataFrame):  # min/max must be done twice to return scalar\n            value = getattr(value, self._op)(skipna=True)\n        cond = chunk_or_series_from_chunk == value\n        cond = cond.where(pd.notna(cond), False)\n        return np.where(cond, self._attribute, \"\")\n",
                "patched_styler": "from typing import List, Optional, Union\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableSource\nfrom cms_rendner_sdfv.base.types import Region, TableSourceKind\nfrom cms_rendner_sdfv.pandas.styler.patched_styler_context import PatchedStylerContext\nfrom cms_rendner_sdfv.pandas.styler.style_function_name_resolver import StyleFunctionNameResolver\nfrom cms_rendner_sdfv.pandas.styler.style_functions_validator import StyleFunctionValidationProblem, \\\n    StyleFunctionsValidator, ValidationStrategyType\nfrom cms_rendner_sdfv.pandas.styler.todos_patcher import TodosPatcher\nfrom cms_rendner_sdfv.pandas.styler.types import StyleFunctionInfo\n\n\nclass PatchedStyler(AbstractTableSource):\n    def __init__(self, context: PatchedStylerContext, fingerprint: str):\n        super().__init__(TableSourceKind.PATCHED_STYLER, context, fingerprint)\n\n    def validate_style_functions(self,\n                                 first_row: int,\n                                 first_col: int,\n                                 rows: int,\n                                 cols: int,\n                                 strategy: Union[ValidationStrategyType, str, None] = None,\n                                 ) -> List[StyleFunctionValidationProblem]:\n        validation_strategy = ValidationStrategyType[strategy] if isinstance(strategy, str) else strategy\n        return StyleFunctionsValidator(self._context, validation_strategy)\\\n            .validate(Region(first_row, first_col, rows, cols))\n\n    def set_sort_criteria(self,\n                          by_column_index: Optional[List[int]] = None,\n                          ascending: Optional[List[bool]] = None,\n                          ):\n        self._context.set_sort_criteria(by_column_index, ascending)\n\n    def get_style_function_info(self) -> List[StyleFunctionInfo]:\n        result = []\n\n        for i, todo in enumerate(self._context.get_styler_todos()):\n            result.append(StyleFunctionInfo(\n                index=i,\n                qname=StyleFunctionNameResolver.get_style_func_qname(todo),\n                resolved_name=StyleFunctionNameResolver.resolve_style_func_name(todo),\n                axis='' if todo.is_applymap() else str(todo.apply_args.axis),\n                is_pandas_builtin=todo.is_pandas_style_func(),\n                is_supported=TodosPatcher.is_style_function_supported(todo),\n                is_apply=not todo.is_applymap(),\n                is_chunk_parent_requested=todo.should_provide_chunk_parent(),\n            ))\n\n        return result\n",
                "patched_styler_context": "from typing import Callable, List, Optional, Tuple\n\nfrom pandas import DataFrame, Index\nfrom pandas.io.formats.style import Styler\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableFrameGenerator, TableFrameValidator\nfrom cms_rendner_sdfv.pandas.shared.pandas_table_source_context import PandasTableSourceContext\nfrom cms_rendner_sdfv.pandas.shared.types import FilterCriteria\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todos_patcher import TodosPatcher\n\n\nclass PatchedStylerContext(PandasTableSourceContext):\n    def __init__(self, styler: Styler, filter_criteria: Optional[FilterCriteria] = None):\n        self._has_hidden_rows = len(styler.hidden_rows) > 0\n        self._has_hidden_columns = len(styler.hidden_columns) > 0\n        self._styler = styler\n        self._styler_todos = [StylerTodo.from_tuple(t) for t in styler._todo]\n        super().__init__(styler.data, filter_criteria)\n\n    def get_table_frame_generator(self) -> AbstractTableFrameGenerator:\n        from cms_rendner_sdfv.pandas.styler.table_frame_generator import TableFrameGenerator\n        return TableFrameGenerator(self)\n\n    def get_styler(self) -> Styler:\n        return self._styler\n\n    def get_styler_todos(self):\n        return self._styler_todos\n\n    def get_todo_validator(self, todo: StylerTodo) -> TableFrameValidator:\n        from cms_rendner_sdfv.pandas.styler.table_frame_generator import TableFrameGenerator\n        frame_generator = TableFrameGenerator(self, lambda x: x is todo)\n        frame_generator.exclude_headers()\n        return TableFrameValidator(self.visible_frame.region, frame_generator)\n\n    def create_patched_todos(self,\n                             chunk: DataFrame,\n                             todos_filter: Optional[Callable[[StylerTodo], bool]] = None,\n                             ) -> List[Tuple[Callable, tuple, dict]]:\n        filtered_todos = self._styler_todos if todos_filter is None else list(filter(todos_filter, self._styler_todos))\n        return TodosPatcher().patch_todos_for_chunk(filtered_todos, self._source_frame, chunk)\n\n    def _get_initial_visible_frame_indexes(self):\n        index, columns = super()._get_initial_visible_frame_indexes()\n\n        if self._has_hidden_columns:\n            columns = columns.delete(Index(self._styler.hidden_columns))\n        if self._has_hidden_rows:\n            index = index.delete(Index(self._styler.hidden_rows))\n\n        return index, columns\n",
                "style_function_name_resolver": "from functools import partial\n\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\n\n\nclass StyleFunctionNameResolver:\n\n    @staticmethod\n    def get_style_func_qname(todo: StylerTodo) -> str:\n        func = todo.apply_args.style_func\n        if isinstance(func, partial):\n            func = func.func\n        return getattr(func, '__qualname__', '')\n\n    @staticmethod\n    def resolve_style_func_name(todo: StylerTodo) -> str:\n        qname = StyleFunctionNameResolver.get_style_func_qname(todo)\n        if todo.is_pandas_style_func():\n            if StyleFunctionNameResolver.is_pandas_text_gradient(qname, todo):\n                return \"text_gradient\"\n            elif StyleFunctionNameResolver.is_pandas_background_gradient(qname):\n                return \"background_gradient\"\n            elif StyleFunctionNameResolver.is_pandas_highlight_max(qname, todo):\n                return \"highlight_max\"\n            elif StyleFunctionNameResolver.is_pandas_highlight_min(qname, todo):\n                return \"highlight_min\"\n            elif StyleFunctionNameResolver.is_pandas_highlight_null(qname):\n                return \"highlight_null\"\n            elif StyleFunctionNameResolver.is_pandas_highlight_between(qname):\n                return \"highlight_between or highlight_quantile\"\n            elif StyleFunctionNameResolver.is_pandas_set_properties(qname):\n                return \"set_properties\"\n            else:\n                return qname.rpartition('.')[2]\n        else:\n            return qname.rpartition('.')[2]\n\n    @staticmethod\n    def is_pandas_background_gradient(style_func_qname: str) -> bool:\n        return style_func_qname == '_background_gradient'\n\n    @staticmethod\n    def is_pandas_text_gradient(style_func_qname: str, todo: StylerTodo) -> bool:\n        return style_func_qname == '_background_gradient' \\\n               and todo.style_func_kwargs.get(\"text_only\", False)\n\n    @staticmethod\n    def is_pandas_highlight_max(style_func_qname: str, todo: StylerTodo) -> bool:\n        return style_func_qname == '_highlight_value' \\\n               and isinstance(todo.apply_args.style_func, partial) \\\n               and todo.apply_args.style_func.keywords.get('op', '') == 'max'\n\n    @staticmethod\n    def is_pandas_highlight_min(style_func_qname: str, todo: StylerTodo) -> bool:\n        return style_func_qname == '_highlight_value' \\\n               and isinstance(todo.apply_args.style_func, partial) \\\n               and todo.apply_args.style_func.keywords.get('op', '') == 'min'\n\n    @staticmethod\n    def is_pandas_highlight_null(style_func_qname: str) -> bool:\n        return style_func_qname.startswith('Styler.highlight_null')\n\n    @staticmethod\n    def is_pandas_highlight_between(style_func_qname: str) -> bool:\n        return style_func_qname == '_highlight_between'\n\n    @staticmethod\n    def is_pandas_set_properties(style_func_qname: str) -> bool:\n        return style_func_qname.startswith('Styler.set_properties')\n",
                "style_functions_validator": "from abc import ABC, abstractmethod\nfrom typing import List, Optional, Tuple\n\nfrom cms_rendner_sdfv.base.types import Region\nfrom cms_rendner_sdfv.pandas.styler.patched_styler_context import PatchedStylerContext\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.types import StyleFunctionValidationProblem, ValidationStrategyType\n\n\nclass _AbstractValidationStrategy(ABC):\n    def __init__(self, strategy_type: ValidationStrategyType):\n        self._strategy_type: ValidationStrategyType = strategy_type\n\n    @property\n    def strategy_type(self):\n        return self._strategy_type\n\n    @abstractmethod\n    def get_chunk_size(self, rows_in_region: int, columns_in_region: int) -> Tuple[int, int]:\n        pass\n\n    @staticmethod\n    def _ceiling_division(n, d):\n        return -(n // -d)\n\n\nclass _PrecisionValidationStrategy(_AbstractValidationStrategy):\n    def __init__(self):\n        super().__init__(ValidationStrategyType.PRECISION)\n\n    def get_chunk_size(self, rows_in_region: int, columns_in_region: int) -> Tuple[int, int]:\n        rows_per_chunk = max(1, self._ceiling_division(rows_in_region, 2))\n        cols_per_chunk = max(1, self._ceiling_division(columns_in_region, 2))\n        return rows_per_chunk, cols_per_chunk\n\n\nclass _FastValidationStrategy(_AbstractValidationStrategy):\n    def __init__(self):\n        super().__init__(ValidationStrategyType.FAST)\n        self.__split_vertical = True\n\n    def get_chunk_size(self, rows_in_region: int, columns_in_region: int) -> Tuple[int, int]:\n        rows_per_chunk = rows_in_region\n        cols_per_chunk = columns_in_region\n\n        if self.__split_vertical:\n            cols_per_chunk = max(1, self._ceiling_division(cols_per_chunk, 2))\n        else:\n            rows_per_chunk = max(1, self._ceiling_division(rows_per_chunk, 2))\n\n        self.__split_vertical = not self.__split_vertical\n        return rows_per_chunk, cols_per_chunk\n\n\nclass StyleFunctionsValidator:\n    def __init__(self, ctx: PatchedStylerContext, strategy_type: Optional[ValidationStrategyType] = None):\n        self.__ctx: PatchedStylerContext = ctx\n        self.__apply_todos_count: int = self.__count_apply_todos(ctx.get_styler_todos())\n        self.__validation_strategy: _AbstractValidationStrategy = self.__create_validation_strategy(strategy_type)\n\n    def validate(self, region: Region = None) -> List[StyleFunctionValidationProblem]:\n        if self.__apply_todos_count == 0:\n            return []\n\n        if region is None:\n            region = self.__ctx.visible_frame.region\n\n        rows_per_chunk, cols_per_chunk = self.__validation_strategy.get_chunk_size(region.rows, region.cols)\n\n        if self.__apply_todos_count == 1:\n            return self.__validate_todos_separately(region, rows_per_chunk, cols_per_chunk)\n\n        try:\n            validator = self.__ctx.get_table_frame_validator()\n            if validator.validate(rows_per_chunk, cols_per_chunk, region).is_equal:\n                return []\n        except Exception:\n            pass\n\n        return self.__validate_todos_separately(region, rows_per_chunk, cols_per_chunk)\n\n    def __validate_todos_separately(self,\n                                    region: Region,\n                                    rows_per_chunk: int,\n                                    cols_per_chunk: int,\n                                    ) -> List[StyleFunctionValidationProblem]:\n        validation_result = []\n\n        for i, todo in enumerate(self.__ctx.get_styler_todos()):\n            try:\n                if todo.is_applymap():\n                    continue\n                validator = self.__ctx.get_todo_validator(todo)\n                result = validator.validate(rows_per_chunk, cols_per_chunk, region)\n                if not result.is_equal:\n                    validation_result.append(StyleFunctionValidationProblem(i, \"NOT_EQUAL\"))\n            except Exception as e:\n                validation_result.append(StyleFunctionValidationProblem(i, \"EXCEPTION\", str(e)))\n\n        return validation_result\n\n    @staticmethod\n    def __count_apply_todos(todos: List[StylerTodo]) -> int:\n        return 0 if not todos else len([not t.is_applymap() for t in todos])\n\n    @staticmethod\n    def __create_validation_strategy(strategy_type: Optional[ValidationStrategyType] = None):\n        if strategy_type is ValidationStrategyType.PRECISION:\n            return _PrecisionValidationStrategy()\n        else:\n            return _FastValidationStrategy()\n",
                "styler_todo": "import inspect\nfrom dataclasses import dataclass\nfrom functools import partial\nfrom typing import Callable, Optional, Tuple, Union\n\nfrom pandas._typing import Axis\nfrom pandas.io.formats.style_render import Subset\n\n\n@dataclass(frozen=True)\nclass ApplyMapArgs:\n    style_func: Callable\n    subset: Optional[Subset]\n\n    @classmethod\n    def from_tuple(cls, args: Tuple[Callable, Optional[Subset]]):\n        return cls(args[0], args[1])\n\n    @staticmethod\n    def copy_with(style_func: Callable, subset: Optional[Subset]):\n        return ApplyMapArgs(style_func, subset)\n\n    def to_tuple(self) -> Tuple[Callable, Optional[Subset]]:\n        return self.style_func, self.subset\n\n\n@dataclass(frozen=True)\nclass ApplyArgs:\n    style_func: Callable\n    axis: Optional[Axis]\n    subset: Optional[Subset]\n\n    @classmethod\n    def from_tuple(cls, args: Tuple[Callable, Optional[Axis], Optional[Subset]]):\n        return cls(args[0], args[1], args[2])\n\n    def copy_with(self, style_func: Callable, subset: Optional[Subset]):\n        return ApplyArgs(style_func, self.axis, subset)\n\n    def to_tuple(self) -> Tuple[Callable, Optional[Axis], Optional[Subset]]:\n        return self.style_func, self.axis, self.subset\n\n\n@dataclass(frozen=True)\nclass StylerTodo:\n    apply_func: Callable\n    apply_args: Union[ApplyArgs, ApplyMapArgs]\n    style_func_kwargs: dict\n\n    @classmethod\n    def from_tuple(cls, todo: Tuple[Callable, tuple, dict]):\n        return cls(todo[0], cls._to_apply_args(todo), todo[2])\n\n    def builder(self):\n        return StylerTodoBuilder(self)\n\n    @staticmethod\n    def _to_apply_args(todo: Tuple[Callable, tuple, dict]):\n        if StylerTodo.is_applymap_tuple(todo):\n            return ApplyMapArgs.from_tuple(todo[1])\n        else:\n            return ApplyArgs.from_tuple(todo[1])\n\n    @classmethod\n    def is_applymap_tuple(cls, todo: Tuple[Callable, tuple, dict]):\n        return cls.__is_apply_map_func(todo[0])\n\n    def is_applymap(self) -> bool:\n        return self.__is_apply_map_func(self.apply_func)\n\n    @staticmethod\n    def __is_apply_map_func(func: Callable) -> bool:\n        return getattr(func, '__qualname__', '').startswith('Styler.applymap')\n\n    def is_pandas_style_func(self) -> bool:\n        func = self.apply_args.style_func\n        if isinstance(func, partial):\n            func = func.func\n        inspect_result = inspect.getmodule(func)\n        return False if inspect_result is None else inspect.getmodule(func).__name__ == 'pandas.io.formats.style'\n\n    def should_provide_chunk_parent(self):\n        sig = inspect.signature(self.apply_args.style_func)\n        for param in sig.parameters.values():\n            if param.name == \"chunk_parent\" or param.kind == inspect.Parameter.VAR_KEYWORD:\n                return True\n        return False\n\n    def to_tuple(self) -> Tuple[Callable, tuple, dict]:\n        return self.apply_func, self.apply_args.to_tuple(), self.style_func_kwargs\n\n\nclass StylerTodoBuilder:\n\n    def __init__(self, source: StylerTodo):\n        self.source: StylerTodo = source\n        self.values: dict = {}\n\n    def with_subset(self, subset: Optional[Subset]):\n        self.values[\"subset\"] = subset\n        return self\n\n    def with_style_func(self, style_func: Callable):\n        self.values[\"style_func\"] = style_func\n        return self\n\n    def with_style_func_kwargs(self, style_func_kwargs: dict):\n        self.values[\"style_func_kwargs\"] = style_func_kwargs\n        return self\n\n    def build(self) -> StylerTodo:\n        return StylerTodo(\n            self.source.apply_func,\n            self.source.apply_args.copy_with(\n                style_func=self.values.get(\"style_func\", self.source.apply_args.style_func),\n                subset=self.values.get(\"subset\", self.source.apply_args.subset),\n            ),\n            self.values.get(\"style_func_kwargs\", self.source.style_func_kwargs),\n        )\n",
                "table_frame_generator": "from typing import Callable, List, Optional, Union\n\nfrom pandas import Series\nfrom pandas.io.formats.style import Styler\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableFrameGenerator\nfrom cms_rendner_sdfv.base.types import Region, TableFrame, TableFrameCell, TableFrameColumn, TableFrameLegend\nfrom cms_rendner_sdfv.pandas.shared.value_formatter import ValueFormatter\nfrom cms_rendner_sdfv.pandas.styler.patched_styler_context import PatchedStylerContext\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\n\n\nclass TableFrameGenerator(AbstractTableFrameGenerator):\n    def __init__(self,\n                 styler_context: PatchedStylerContext,\n                 todos_filter: Optional[Callable[[StylerTodo], bool]] = None,\n                 ):\n        super().__init__(styler_context.visible_frame)\n        self.__styler_context: PatchedStylerContext = styler_context\n        self.__todos_filter: Optional[Callable[[StylerTodo], bool]] = todos_filter\n\n    def generate(self,\n                 region: Region = None,\n                 exclude_row_header: bool = False,\n                 exclude_col_header: bool = False,\n                 ) -> TableFrame:\n        org_styler = self.__styler_context.get_styler()\n\n        if self._exclude_headers:\n            exclude_row_header = True\n            exclude_col_header = True\n        else:\n            if org_styler.hide_index_names:\n                exclude_row_header = True\n            if org_styler.hide_column_names:\n                exclude_col_header = True\n\n        chunk = self._visible_frame.get_chunk(region)\n        chunk_df = self._visible_frame.to_frame(chunk)\n\n        chunk_aware_todos = self.__styler_context.create_patched_todos(chunk_df, self.__todos_filter)\n\n        copy = org_styler.data.style\n        copy._todo = chunk_aware_todos\n        computed_styler = copy._compute()\n\n        formatter = ValueFormatter()\n        translate_pos = self._visible_frame.create_to_source_frame_cell_coordinates_translator(chunk)\n\n        cells: List[List[TableFrameCell]] = []\n        columns: List[TableFrameColumn] = []\n        index_labels: List[List[str]] = []\n        for ri, row_tuple in enumerate(chunk_df.itertuples(index=False, name=None)):\n            row_cells = []\n            cells.append(row_cells)\n            for ci in range(0, chunk.region.cols):\n                if ci == 0:\n                    if not exclude_row_header:\n                        row_name = chunk_df.index[ri]\n                        if isinstance(row_name, tuple):\n                            row_name = [formatter.format_index(x) for x in row_name]\n                        else:\n                            row_name = [formatter.format_index(row_name)]\n                        row_name = [v for i, v in enumerate(row_name) if not org_styler.hide_index_[i]]\n                        if row_name:\n                            index_labels.append(row_name)\n                if ri == 0:\n                    if not exclude_col_header:\n                        col_series: Series = chunk_df[chunk_df.columns[ci]]\n                        col_name = col_series.name\n                        if isinstance(col_name, tuple):\n                            col_name = [formatter.format_index(n) for n in col_name]\n                        else:\n                            col_name = [formatter.format_index(col_name)]\n                        col_name = [v for i, v in enumerate(col_name) if not org_styler.hide_columns_[i]]\n                        if col_name:\n                            info = self._visible_frame.get_column_info(chunk.region.first_col + ci)\n                            columns.append(\n                                TableFrameColumn(dtype=str(info.dtype), labels=col_name, describe=info.describe()),\n                            )\n                org_cell_pos = translate_pos((ri, ci))\n                css = computed_styler.ctx[org_cell_pos]\n                row_cells.append(\n                    TableFrameCell(\n                        value=formatter.format_cell(computed_styler._display_funcs[org_cell_pos](row_tuple[ci])),\n                        css=None if not css or css is None else {k: v for k, v in css},\n                    ),\n                )\n\n        return TableFrame(\n            index_labels=index_labels,\n            columns=columns,\n            cells=cells,\n            legend=None if exclude_col_header and exclude_row_header else self._extract_legend_label(formatter,\n                                                                                                     org_styler),\n        )\n\n    def _extract_legend_label(self, formatter: ValueFormatter, org_styler: Styler) -> Union[None, TableFrameLegend]:\n        index_legend = [\n            formatter.format_index(n)\n            for i, n in enumerate(self._visible_frame.index_names)\n            if n is not None and not org_styler.hide_index_[i]\n        ]\n\n        if not index_legend and any(org_styler.hide_index_):\n            return None\n\n        column_legend = [\n            formatter.format_index(n)\n            for i, n in enumerate(self._visible_frame.column_names)\n            if n is not None and not org_styler.hide_columns_[i]\n        ]\n        return TableFrameLegend(index=index_legend, column=column_legend) if index_legend or column_legend else None\n",
                "table_source_factory": "from typing import Any, Union\n\nfrom pandas import DataFrame\nfrom pandas.io.formats.style import Styler\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableSource, AbstractTableSourceFactory\nfrom cms_rendner_sdfv.base.types import CreateTableSourceConfig, CreateTableSourceFailure\nfrom cms_rendner_sdfv.pandas.shared.create_fingerprint import create_fingerprint\nfrom cms_rendner_sdfv.pandas.shared.types import FilterCriteria\nfrom cms_rendner_sdfv.pandas.styler.patched_styler import PatchedStyler\nfrom cms_rendner_sdfv.pandas.styler.patched_styler_context import PatchedStylerContext\n\n\nclass TableSourceFactory(AbstractTableSourceFactory):\n\n    def _create_internal(self,\n                         data_source: Any,\n                         config: CreateTableSourceConfig,\n                         caller_globals: dict,\n                         ) -> Union[AbstractTableSource, CreateTableSourceFailure]:\n\n        if not isinstance(data_source, Styler):\n            return CreateTableSourceFailure(error_kind=\"UNSUPPORTED_DATA_SOURCE_TYPE\", info=str(type(data_source)))\n\n        ds_frame = data_source.data\n        ds_frame_style = data_source\n\n        pre_fingerprint = config.previous_fingerprint\n        cur_fingerprint = create_fingerprint(ds_frame, data_source)\n        if pre_fingerprint is not None and pre_fingerprint != cur_fingerprint:\n            return CreateTableSourceFailure(error_kind=\"INVALID_FINGERPRINT\", info=cur_fingerprint)\n\n        filter_frame = None\n        filter_eval_expr = config.filter_eval_expr\n        if filter_eval_expr is not None and filter_eval_expr != \"\":\n            try:\n                if config.filter_eval_expr_provide_frame:\n                    caller_globals[\"_df\"] = ds_frame\n                filter_frame = eval(filter_eval_expr, caller_globals)\n            except Exception as e:\n                return CreateTableSourceFailure(error_kind=\"FILTER_FRAME_EVAL_FAILED\", info=repr(e))\n\n            if not isinstance(filter_frame, DataFrame):\n                return CreateTableSourceFailure(error_kind=\"FILTER_FRAME_OF_WRONG_TYPE\", info=str(type(filter_frame)))\n\n        return PatchedStyler(\n            PatchedStylerContext(ds_frame_style, FilterCriteria.from_frame(filter_frame)),\n            fingerprint=cur_fingerprint,\n        )\n",
                "todo_patcher": "from abc import ABC, abstractmethod\nfrom typing import Optional\n\nfrom pandas import DataFrame\nfrom pandas.io.formats.style_render import Subset, non_reducing_slice\n\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\n\n\nclass TodoPatcher(ABC):\n\n    def __init__(self, todo: StylerTodo):\n        self._todo: StylerTodo = todo\n\n    @abstractmethod\n    def create_patched_todo(self, org_frame: DataFrame, chunk: DataFrame) -> Optional[StylerTodo]:\n        pass\n\n    @staticmethod\n    def _calculate_chunk_subset(org_subset_frame: DataFrame, chunk: DataFrame) -> Subset:\n        index_intersection = chunk.index.intersection(org_subset_frame.index)\n        column_intersection = chunk.columns.intersection(org_subset_frame.columns)\n        return index_intersection, column_intersection\n\n    @staticmethod\n    def _create_subset_frame(org_frame: DataFrame, subset: Optional[Subset]) -> DataFrame:\n        subset = slice(None) if subset is None else subset\n        subset = non_reducing_slice(subset)\n        return org_frame.loc[subset]\n",
                "todos_patcher": "from typing import Callable, List, Optional, Tuple\n\nfrom pandas import DataFrame\n\nfrom cms_rendner_sdfv.pandas.styler.apply_map_patcher import ApplyMapPatcher\nfrom cms_rendner_sdfv.pandas.styler.apply_patcher import ApplyPatcher\nfrom cms_rendner_sdfv.pandas.styler.background_gradient_patcher import BackgroundGradientPatcher\nfrom cms_rendner_sdfv.pandas.styler.highlight_between_patcher import HighlightBetweenPatcher\nfrom cms_rendner_sdfv.pandas.styler.highlight_extrema_patcher import HighlightExtremaPatcher\nfrom cms_rendner_sdfv.pandas.styler.style_function_name_resolver import StyleFunctionNameResolver\nfrom cms_rendner_sdfv.pandas.styler.styler_todo import StylerTodo\nfrom cms_rendner_sdfv.pandas.styler.todo_patcher import TodoPatcher\n\n\nclass TodosPatcher:\n\n    def patch_todos_for_chunk(self,\n                              todos: List[StylerTodo],\n                              org_frame: DataFrame,\n                              chunk: DataFrame,\n                              ) -> List[Tuple[Callable, tuple, dict]]:\n        result: List[Tuple[Callable, tuple, dict]] = []\n\n        for t in todos:\n\n            if t.is_pandas_style_func():\n                patcher = self.__get_patcher_for_pandas_style_function(t)\n            else:\n                if t.is_applymap():\n                    patcher = ApplyMapPatcher(t)\n                else:\n                    patcher = ApplyPatcher(t)\n\n            if patcher is not None:\n                result.append(patcher.create_patched_todo(org_frame, chunk).to_tuple())\n\n        return result\n\n    @staticmethod\n    def is_style_function_supported(todo: StylerTodo) -> bool:\n        if todo.is_pandas_style_func():\n            return TodosPatcher.__get_patcher_for_pandas_style_function(todo) is not None\n        return True\n\n    @staticmethod\n    def __get_patcher_for_pandas_style_function(todo: StylerTodo) -> Optional[TodoPatcher]:\n        qname = StyleFunctionNameResolver.get_style_func_qname(todo)\n        if StyleFunctionNameResolver.is_pandas_text_gradient(qname, todo):\n            return BackgroundGradientPatcher(todo)\n        elif StyleFunctionNameResolver.is_pandas_background_gradient(qname):\n            return BackgroundGradientPatcher(todo)\n        elif StyleFunctionNameResolver.is_pandas_highlight_max(qname, todo):\n            return HighlightExtremaPatcher(todo, 'max')\n        elif StyleFunctionNameResolver.is_pandas_highlight_min(qname, todo):\n            return HighlightExtremaPatcher(todo, 'min')\n        elif StyleFunctionNameResolver.is_pandas_highlight_null(qname):\n            return ApplyPatcher(todo)\n        elif StyleFunctionNameResolver.is_pandas_highlight_between(qname):\n            return HighlightBetweenPatcher(todo)\n        elif StyleFunctionNameResolver.is_pandas_set_properties(qname):\n            return ApplyMapPatcher(todo)\n        return None\n",
                "types": "from dataclasses import dataclass\nfrom enum import Enum\n\n\n@dataclass(frozen=True)\nclass StyleFunctionValidationProblem:\n    index: int\n    reason: str\n    message: str = \"\"\n\n\nclass ValidationStrategyType(Enum):\n    FAST = \"fast\"\n    PRECISION = \"precision\"\n\n\n@dataclass(frozen=True)\nclass StyleFunctionInfo:\n    index: int\n    qname: str\n    resolved_name: str\n    axis: str\n    is_chunk_parent_requested: bool\n    is_apply: bool\n    is_pandas_builtin: bool\n    is_supported: bool\n"
            }
        }
    }
}